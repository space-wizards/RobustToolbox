using System.Threading.Tasks;
using Microsoft.CodeAnalysis.CSharp.Testing;
using Microsoft.CodeAnalysis.Testing;
using NUnit.Framework;
using VerifyCS =
    Microsoft.CodeAnalysis.CSharp.Testing.CSharpAnalyzerVerifier<Robust.Analyzers.PrototypeAnalyzer, Microsoft.CodeAnalysis.Testing.DefaultVerifier>;

namespace Robust.Analyzers.Tests;

[Parallelizable(ParallelScope.All | ParallelScope.Fixtures)]
public sealed class PrototypeAnalyzerTest
{
    private static Task Verifier(string code, params DiagnosticResult[] expected)
    {
        var test = new CSharpAnalyzerTest<PrototypeAnalyzer, DefaultVerifier>()
        {
            TestState =
            {
                Sources = { code }
            },
        };

        test.TestState.Sources.Add(("PrototypeAttribute.cs", PrototypeAttributeDef));

        // ExpectedDiagnostics cannot be set, so we need to AddRange here...
        test.TestState.ExpectedDiagnostics.AddRange(expected);

        return test.RunAsync();
    }

    private const string PrototypeAttributeDef = """
        using System;

        namespace Robust.Shared.Prototypes
        {
            public class PrototypeAttribute : Attribute
            {
                public string? Type { get; internal set; }
                public readonly int LoadPriority = 1;

                public PrototypeAttribute(string? type = null, int loadPriority = 1)
                {
                    Type = type;
                    LoadPriority = loadPriority;
                }

                public PrototypeAttribute(int loadPriority)
                {
                    Type = null;
                    LoadPriority = loadPriority;
                }
            }
            public interface IPrototype;
        }
    """;

    [Test]
    public async Task RedundantTypeTest()
    {
        const string code = """
            using Robust.Shared.Prototypes;

            [Prototype]
            public sealed partial class GoodAutoPrototype : IPrototype;

            [Prototype("someOtherName")]
            public sealed partial class GoodUnmatchedPrototype : IPrototype;

            [Prototype("badMatched")]
            public sealed partial class BadMatchedPrototype : IPrototype;

            [Prototype(ProtoName)]
            public sealed partial class GoodNonLiteralMatchedPrototype : IPrototype
            {
                public const string ProtoName = "goodNonLiteralMatched";
            }

            [Prototype(ProtoName)]
            public sealed partial class GoodNonLiteralUnmatchedPrototype : IPrototype
            {
                public const string ProtoName = "someOtherNameEntirely";
            }

            [Prototype("goodDoesNotEndWithPrototypeWord")]
            public sealed partial class GoodDoesNotEndWithPrototypeWord : IPrototype;
            """;

        await Verifier(code,
            // /0/Test0.cs(9,2): warning RA0033: Prototype BadMatchedPrototype has explicitly set type "badMatched" that matches autogenerated value
            VerifyCS.Diagnostic(PrototypeAnalyzer.PrototypeRedundantTypeRule).WithSpan(9, 12, 9, 24).WithArguments("BadMatchedPrototype", "badMatched")
        );
    }

    [Test]
    public async Task NameEndsWithPrototypeTest()
    {
        const string code = """
            using Robust.Shared.Prototypes;

            [Prototype]
            public sealed partial class GoodAutoPrototype : IPrototype;

            [Prototype("ThisIsFine")]
            public sealed partial class GoodManual : IPrototype;

            [Prototype]
            public sealed partial class BadAuto : IPrototype;
            """;

        await Verifier(code,
            // /0/Test0.cs(10,29): warning RA0036: Prototype BadAuto does not end with the word Prototype
            VerifyCS.Diagnostic(PrototypeAnalyzer.PrototypeEndsWithPrototypeRule).WithSpan(10, 29, 10, 36).WithArguments("BadAuto")
        );
    }
}
