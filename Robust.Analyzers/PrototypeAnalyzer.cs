#nullable enable
using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Diagnostics;
using Robust.Roslyn.Shared;
using Robust.Shared.Prototypes;

namespace Robust.Analyzers;

[DiagnosticAnalyzer(LanguageNames.CSharp)]
public sealed class PrototypeAnalyzer : DiagnosticAnalyzer
{
    public static readonly DiagnosticDescriptor PrototypeRedundantTypeRule = new(
        Diagnostics.IdPrototypeRedundantType,
        "Redundant Prototype Type specification",
        "Prototype {0} has explicitly set type \"{1}\" that matches autogenerated value",
        "Usage",
        DiagnosticSeverity.Warning,
        true,
        "Remove the redundant type specification."
    );

    public static readonly DiagnosticDescriptor PrototypeEndsWithPrototypeRule = new(
        Diagnostics.IdPrototypeEndsWithPrototype,
        "Prototype name must end with the word Prototype",
        "Prototype {0} does not end with the word Prototype",
        "Usage",
        DiagnosticSeverity.Error,
        true,
        "Add the word Prototype to the end of the class name or manually specify a name in the Prototype attribute."
    );

    public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics => [PrototypeRedundantTypeRule, PrototypeEndsWithPrototypeRule];

    public override void Initialize(AnalysisContext context)
    {
        context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.Analyze | GeneratedCodeAnalysisFlags.ReportDiagnostics);
        context.EnableConcurrentExecution();

        context.RegisterCompilationStartAction(static ctx =>
        {
            var prototypeAttribute =
                ctx.Compilation.GetTypeByMetadataName("Robust.Shared.Prototypes.PrototypeAttribute");

            // No attribute, no analyzer.
            if (prototypeAttribute is null)
                return;

            ctx.RegisterSymbolAction(symCtx => AnalyzePrototype(symCtx, prototypeAttribute), SymbolKind.NamedType);
        });
    }

    private static void AnalyzePrototype(SymbolAnalysisContext context, INamedTypeSymbol attributeSymbol)
    {
        if (context.Symbol is not INamedTypeSymbol namedType)
            return;

        var className = namedType.Name;

        if (!AttributeHelper.HasAttribute(namedType, attributeSymbol, out var matchedAttribute))
            return;

        // Check for autogenerated type
        if (matchedAttribute.ConstructorArguments.Length == 0)
        {
            if (!className.EndsWith(PrototypeUtility.PrototypeNameEnding))
            {
                context.ReportDiagnostic(Diagnostic.Create(PrototypeEndsWithPrototypeRule,
                    namedType.Locations[0],
                    namedType.Locations,
                    className));
            }
            return;
        }

        if (matchedAttribute.ConstructorArguments[0] is not { Value: string specifiedName })
            return;

        var autoName = PrototypeUtility.CalculatePrototypeName(className);

        // Check for name redundancy
        if (autoName == specifiedName)
        {
            // If the class name does not end with "Prototype", allow the redundancy
            if (!className.EndsWith(PrototypeUtility.PrototypeNameEnding))
                return;

            context.ReportDiagnostic(Diagnostic.Create(PrototypeRedundantTypeRule,
                matchedAttribute.ApplicationSyntaxReference?.GetSyntax().GetLocation(),
                className,
                specifiedName));
        }
    }
}
