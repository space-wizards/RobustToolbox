<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Robust.Shared</name>
    </assembly>
    <members>
        <member name="P:Robust.Shared.Analyzers.AccessAttribute.Self">
            <summary>
                Access permissions for the type itself, or the type containing the member.
            </summary>
        </member>
        <member name="T:Robust.Shared.Analyzers.AutoGenerateComponentStateAttribute">
            <summary>
                When a component is marked with this attribute, any members it has marked with <see cref="T:Robust.Shared.Analyzers.AutoNetworkedFieldAttribute"/>
                will automatically be replicated using component states to clients. Systems which need to have more intelligent
                component state replication beyond just directly setting variables should not use this attribute.
            </summary>
        </member>
        <member name="F:Robust.Shared.Analyzers.AutoGenerateComponentStateAttribute.RaiseAfterAutoHandleState">
            <summary>
                If this is true, the autogenerated code will raise a <see cref="T:Robust.Shared.Analyzers.AfterAutoHandleStateEvent"/> component event
                so that user-defined systems can have effects after handling state without redefining all replication.
            </summary>
        </member>
        <member name="T:Robust.Shared.Analyzers.AutoNetworkedFieldAttribute">
            <summary>
                Used to mark component members which should be automatically replicated, assuming the component is marked with
                <see cref="T:Robust.Shared.Analyzers.AutoGenerateComponentStateAttribute"/>.
            </summary>
        </member>
        <member name="T:Robust.Shared.Analyzers.AfterAutoHandleStateEvent">
            <summary>
                Raised as a component event after auto handling state is done, if
                <see cref="F:Robust.Shared.Analyzers.AutoGenerateComponentStateAttribute.RaiseAfterAutoHandleState"/> is true, so that other systems
                can have effects after handling state without having to redefine all replication.
            </summary>
        </member>
        <member name="M:Robust.Shared.Analyzers.AfterAutoHandleStateEvent.#ctor(Robust.Shared.GameObjects.IComponentState)">
            <summary>
                Raised as a component event after auto handling state is done, if
                <see cref="F:Robust.Shared.Analyzers.AutoGenerateComponentStateAttribute.RaiseAfterAutoHandleState"/> is true, so that other systems
                can have effects after handling state without having to redefine all replication.
            </summary>
        </member>
        <member name="T:Robust.Shared.Analyzers.AutoGenerateComponentPauseAttribute">
            <summary>
            Indicate that a <see cref="T:Robust.Shared.GameObjects.Component"/> should automatically handle unpausing of timer fields.
            </summary>
            <remarks>
            When this attribute is set on a <see cref="T:Robust.Shared.GameObjects.Component"/>, an <see cref="T:Robust.Shared.GameObjects.EntitySystem"/> will automatically be
            generated that increments any fields tagged with <see cref="T:Robust.Shared.Analyzers.AutoPausedFieldAttribute"/> when the entity is unpaused
            (<see cref="T:Robust.Shared.GameObjects.EntityUnpausedEvent"/>).
            </remarks>
        </member>
        <member name="T:Robust.Shared.Analyzers.AutoPausedFieldAttribute">
            <summary>
            Mark a field or property to automatically handle unpausing with <see cref="T:Robust.Shared.Analyzers.AutoGenerateComponentPauseAttribute"/>.
            </summary>
            <remarks>
            The type of the field or prototype must be <see cref="T:System.TimeSpan"/> (potentially nullable).
            </remarks>
        </member>
        <member name="T:Robust.Shared.Analyzers.MustCallBaseAttribute">
            <summary>
            Indicates that overriders of this method must always call the base function.
            </summary>
            <param name="onlyOverrides">
            If true, only base calls to *overrides* are necessary.
            This is intended for base classes where the base function is always empty,
            so a base call from the first override may be ommitted.
            </param>
        </member>
        <member name="M:Robust.Shared.Analyzers.MustCallBaseAttribute.#ctor(System.Boolean)">
            <summary>
            Indicates that overriders of this method must always call the base function.
            </summary>
            <param name="onlyOverrides">
            If true, only base calls to *overrides* are necessary.
            This is intended for base classes where the base function is always empty,
            so a base call from the first override may be ommitted.
            </param>
        </member>
        <member name="T:Robust.Shared.Analyzers.PreferOtherTypeAttribute">
            <summary>
            Marks that use of a generic Type should be replaced with a specific other Type
            when the type argument T is a certain Type.
            </summary>
        </member>
        <member name="M:Robust.Shared.Analyzers.PreferOtherTypeAttribute.#ctor(System.Type,System.Type)">
            <summary>
            Marks that use of a generic Type should be replaced with a specific other Type
            when the type argument T is a certain Type.
            </summary>
        </member>
        <member name="T:Robust.Shared.Analyzers.RobustAutoGeneratedAttribute">
            <summary>
                Placed on auto-generated classes to mark to certain robust analyzers that they are auto-generated
                and may need to be ignored (e.g. the access analyzer)
            </summary>
        </member>
        <member name="T:Robust.Shared.Analyzers.VirtualAttribute">
            <summary>
            Specify that this class is allowed to be inherited.
            </summary>
            <remarks>
            Robust uses analyzers to prevent accidental usage of non-sealed classes:
            a class must be either marked [Virtual], abstract, or sealed.
            </remarks>
        </member>
        <member name="T:Robust.Shared.Animations.AnimatableAttribute">
            <summary>
                Specifies that a property can be animated, or that a method can be called by animations.
            </summary>
        </member>
        <member name="M:Robust.Shared.Animations.AnimationHelper.SetAnimatableProperty(System.Object,System.String,System.Object)">
            <summary>
                Sets properties marked with <see cref="T:Robust.Shared.Animations.AnimatableAttribute"/> on an object.
            </summary>
            <remarks>
                This does not use <see cref="T:Robust.Shared.Animations.IAnimationProperties"/>.
            </remarks>
            <param name="target">The object to set the property on.</param>
            <param name="name">The name of the property to set.</param>
            <param name="value">The value to set.</param>
            <exception cref="T:System.ArgumentException">
                Thrown if the property does not exist or does not have <see cref="T:Robust.Shared.Animations.AnimatableAttribute"/>.
            </exception>
        </member>
        <member name="M:Robust.Shared.Animations.AnimationHelper.GetAnimatableProperty(System.Object,System.String)">
            <summary>
                Gets the value of a property marked with <see cref="T:Robust.Shared.Animations.AnimatableAttribute"/> from an object.
            </summary>
            <remarks>
                This does not use <see cref="T:Robust.Shared.Animations.IAnimationProperties"/>.
            </remarks>
            <param name="target">The object to get the property from.</param>
            <param name="name">The name of the property to get.</param>
            <returns>The current value of the property.</returns>
            <exception cref="T:System.ArgumentException">
                Thrown if the property does not exist or does not have <see cref="T:Robust.Shared.Animations.AnimatableAttribute"/>.
            </exception>
        </member>
        <member name="T:Robust.Shared.Animations.AnimationInterpolationMode">
            <summary>
                Specifies how animated properties are interpolated between two keyframes.
            </summary>
        </member>
        <member name="F:Robust.Shared.Animations.AnimationInterpolationMode.Linear">
            <summary>
                Use a linear interpolation for supported values.
                For unsupported values, this falls back to <see cref="F:Robust.Shared.Animations.AnimationInterpolationMode.Previous"/>.
            </summary>
        </member>
        <member name="F:Robust.Shared.Animations.AnimationInterpolationMode.Cubic">
            <summary>
                Use a cubic interpolation for supported values.
                For unsupported values, this falls back to <see cref="F:Robust.Shared.Animations.AnimationInterpolationMode.Previous"/>.
            </summary>
        </member>
        <member name="F:Robust.Shared.Animations.AnimationInterpolationMode.Nearest">
            <summary>
                Use nearest neighbor as interpolation.
            </summary>
            <remarks>
                Nearest neighbor discretely flips between the previous and next keyframe 50% in between the two.
            </remarks>
        </member>
        <member name="F:Robust.Shared.Animations.AnimationInterpolationMode.Previous">
            <summary>
                Use the previous keyframe as value.
            </summary>
        </member>
        <member name="T:Robust.Shared.Animations.IAnimationProperties">
            <summary>
                Specifies that this object has special animation properties
                that are not able to be represented with <see cref="T:Robust.Shared.Animations.AnimatableAttribute"/>.
            </summary>
        </member>
        <member name="M:Robust.Shared.Asynchronous.ITaskManager.RunOnMainThread(System.Action)">
            <summary>
                Run a delegate on the main thread sometime later.
                Thread safe.
            </summary>
            <remarks>
                Useful if you want to run a callback from a separate thread.
            </remarks>
            <param name="callback">The callback that will be invoked on the main thread.</param>
        </member>
        <member name="M:Robust.Shared.Asynchronous.ITaskManager.BlockWaitOnTask(System.Threading.Tasks.Task)">
            <summary>
            Synchronously wait for a main-thread task to complete.
            This is effectively what you need to safely .Result a task on the main thread.
            </summary>
            <remarks>
            Use of this method is only ever recommended in rare scenarios like shutdown. For most other scenarios you should really avoid blocking the main thread and use proper async instead.
            </remarks>
        </member>
        <member name="M:Robust.Shared.Asynchronous.TaskManagerExt.TaskOnMainThread(Robust.Shared.Asynchronous.ITaskManager,System.Action)">
            <summary>
            Run a callback on the main thread, returning a task that represents its completion.
            </summary>
            <seealso cref="M:Robust.Shared.Asynchronous.ITaskManager.RunOnMainThread(System.Action)"/>
        </member>
        <member name="T:Robust.Shared.Audio.AudioLoading.AudioLoader">
            <summary>
            Implements functionality for loading audio files.
            </summary>
            <seealso cref="T:Robust.Shared.Audio.AudioLoading.AudioLoaderOgg"/>
            <seealso cref="T:Robust.Shared.Audio.AudioLoading.AudioLoaderWav"/>
        </member>
        <member name="M:Robust.Shared.Audio.AudioLoading.AudioLoader.IsLoadableAudioFile(System.ReadOnlySpan{System.Char})">
            <summary>
            Test if the given file name is something that we can load.
            </summary>
            <remarks>
            This is detected based on file extension.
            </remarks>
        </member>
        <member name="M:Robust.Shared.Audio.AudioLoading.AudioLoader.LoadAudioMetadata(System.IO.Stream,System.ReadOnlySpan{System.Char})">
            <summary>
            Load metadata about an audio file. Can handle all supported audio file types.
            </summary>
            <param name="stream">Stream containing audio file data to load.</param>
            <param name="filename">File name of the audio file. Used to detect which file type it is.</param>
        </member>
        <member name="T:Robust.Shared.Audio.AudioLoading.AudioMetadata">
            <summary>
            Contains basic metadata of an audio file.
            </summary>
            <seealso cref="T:Robust.Shared.Audio.AudioLoading.AudioLoader"/>
        </member>
        <member name="M:Robust.Shared.Audio.AudioLoading.AudioMetadata.#ctor(System.TimeSpan,System.Int32,System.String,System.String)">
            <summary>
            Contains basic metadata of an audio file.
            </summary>
            <seealso cref="T:Robust.Shared.Audio.AudioLoading.AudioLoader"/>
        </member>
        <member name="T:Robust.Shared.Audio.AudioLoading.AudioLoaderOgg">
            <summary>
            Implements functionality for loading ogg audio files.
            </summary>
            <seealso cref="T:Robust.Shared.Audio.AudioLoading.AudioLoaderOgg"/>
        </member>
        <member name="M:Robust.Shared.Audio.AudioLoading.AudioLoaderOgg.LoadAudioMetadata(System.IO.Stream)">
            <summary>
            Load metadata for an ogg audio file.
            </summary>
            <param name="stream">Audio file stream to load.</param>
        </member>
        <member name="M:Robust.Shared.Audio.AudioLoading.AudioLoaderOgg.LoadAudioData(System.IO.Stream)">
            <summary>
            Load an ogg file into raw samples and metadata.
            </summary>
            <param name="stream">Audio file stream to load.</param>
        </member>
        <member name="T:Robust.Shared.Audio.AudioLoading.AudioLoaderWav">
            <summary>
            Implements functionality for loading wav audio files.
            </summary>
            <seealso cref="T:Robust.Shared.Audio.AudioLoading.AudioLoaderOgg"/>
        </member>
        <member name="M:Robust.Shared.Audio.AudioLoading.AudioLoaderWav.LoadAudioMetadata(System.IO.Stream)">
            <summary>
            Load metadata for a wav audio file.
            </summary>
            <param name="stream">Audio file stream to load.</param>
        </member>
        <member name="M:Robust.Shared.Audio.AudioLoading.AudioLoaderWav.LoadAudioData(System.IO.Stream)">
            <summary>
            Load a wav file into raw samples and metadata.
            </summary>
            <param name="stream">Audio file stream to load.</param>
        </member>
        <member name="T:Robust.Shared.Audio.AudioLoading.AudioLoaderWav.WavData">
            <summary>
                See http://soundfile.sapp.org/doc/WaveFormat/ for reference.
            </summary>
        </member>
        <member name="T:Robust.Shared.Audio.AudioMetadataPrototype">
            <summary>
            Stores server-side metadata about an audio file.
            These prototypes get automatically generated when packaging the server,
            to allow the server to know audio lengths without shipping the large audio files themselves.
            </summary>
        </member>
        <member name="T:Robust.Shared.Audio.AudioParams">
            <summary>
                Contains common audio parameters for audio playback on the client.
            </summary>
        </member>
        <member name="P:Robust.Shared.Audio.AudioParams.Volume">
            <summary>
                Base volume to play the audio at, in dB.
            </summary>
        </member>
        <member name="P:Robust.Shared.Audio.AudioParams.Pitch">
            <summary>
                Scale for the audio pitch.
            </summary>
        </member>
        <member name="P:Robust.Shared.Audio.AudioParams.MaxDistance">
            <summary>
                Only applies to positional audio.
                The maximum distance from which the audio is hearable.
            </summary>
        </member>
        <member name="P:Robust.Shared.Audio.AudioParams.RolloffFactor">
            <summary>
                Used for distance attenuation calculations. Set to 0f to make a sound exempt from distance attenuation.
            </summary>
        </member>
        <member name="P:Robust.Shared.Audio.AudioParams.ReferenceDistance">
            <summary>
                Equivalent of the minimum distance to use for an audio source.
            </summary>
        </member>
        <member name="P:Robust.Shared.Audio.AudioParams.Variation">
            <summary>
                If not null, this will randomly modify the pitch scale by adding a number drawn from a normal distribution with this deviation.
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.AudioParams.Default">
            <summary>
                The "default" audio configuration.
            </summary>
        </member>
        <member name="M:Robust.Shared.Audio.AudioParams.WithVolume(System.Single)">
            <summary>
                Returns a copy of this instance with a new volume set, for easy chaining.
            </summary>
            <param name="volume">The new volume.</param>
        </member>
        <member name="M:Robust.Shared.Audio.AudioParams.AddVolume(System.Single)">
            <summary>
                Returns a copy of this instance with a modified volume set, for easy chaining.
            </summary>
            <param name="volume">The volume to add.</param>
        </member>
        <member name="M:Robust.Shared.Audio.AudioParams.WithVariation(System.Nullable{System.Single})">
            <summary>
                Returns a copy of this instance with a new variation set, for easy chaining.
            </summary>
        </member>
        <member name="M:Robust.Shared.Audio.AudioParams.WithPitchScale(System.Single)">
            <summary>
                Returns a copy of this instance with a new pitch scale set, for easy chaining.
            </summary>
            <param name="pitch">The new pitch scale.</param>
        </member>
        <member name="M:Robust.Shared.Audio.AudioParams.WithMaxDistance(System.Single)">
            <summary>
                Returns a copy of this instance with a new max distance set, for easy chaining.
            </summary>
            <param name="dist">The new max distance.</param>
        </member>
        <member name="M:Robust.Shared.Audio.AudioParams.WithRolloffFactor(System.Single)">
            <summary>
                Returns a copy of this instance with a new rolloff factor set, for easy chaining.
            </summary>
            <param name="rolloffFactor">The new rolloff factor.</param>
        </member>
        <member name="M:Robust.Shared.Audio.AudioParams.WithReferenceDistance(System.Single)">
            <summary>
                Returns a copy of this instance with a new reference distance set, for easy chaining.
            </summary>
            <param name="refDistance">The new reference distance.</param>
        </member>
        <member name="M:Robust.Shared.Audio.AudioParams.WithLoop(System.Boolean)">
            <summary>
                Returns a copy of this instance with a loop set, for easy chaining.
            </summary>
            <param name="loop">The new loop.</param>
        </member>
        <member name="M:Robust.Shared.Audio.AudioParams.InternalCopy(Robust.Shared.Audio.AudioParams@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Audio.AudioParams.Copy(Robust.Shared.Audio.AudioParams@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Audio.AudioParams.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Audio.AudioParams.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Shared.Audio.AudioPresetPrototype">
            <summary>
            Contains audio defaults to set for sounds.
            This can be used by <see cref="!:Content.Shared.Audio.SharedContentAudioSystem"/> to apply an audio preset.
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.AudioPresetPrototype.CreateAuxiliary">
            <summary>
            Should the engine automatically create an auxiliary audio effect slot for this.
            </summary>
        </member>
        <member name="T:Robust.Shared.Audio.Components.AudioAuxiliaryComponent">
            <summary>
            Can have Audio passed to it to apply effects or filters.
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Components.AudioAuxiliaryComponent.Effect">
            <summary>
            Audio effect to attach to this auxiliary audio slot.
            </summary>
        </member>
        <member name="M:Robust.Shared.Audio.Components.AudioAuxiliaryComponent.InternalCopy(Robust.Shared.Audio.Components.AudioAuxiliaryComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Audio.Components.AudioAuxiliaryComponent.Copy(Robust.Shared.Audio.Components.AudioAuxiliaryComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Audio.Components.AudioAuxiliaryComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Audio.Components.AudioAuxiliaryComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Audio.Components.AudioAuxiliaryComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Audio.Components.AudioAuxiliaryComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Audio.Components.AudioAuxiliaryComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Shared.Audio.Components.AudioComponent">
            <summary>
            Stores the audio data for an audio entity.
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Components.AudioComponent.AudioStart">
            <summary>
            Used for synchronising audio on client that comes into PVS range.
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Components.AudioComponent.ExcludedEntity">
            <summary>
            If this sound was predicted do we exclude it from a specific entity.
            Useful for predicted audio.
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Components.AudioComponent.IncludedEntities">
            <summary>
            If the sound was filtered what entities were included.
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Components.AudioComponent.Params">
            <summary>
            Audio params. Set this if you want to adjust default volume, max distance, etc.
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Components.AudioComponent.Source">
            <summary>
            Audio source that interacts with OpenAL.
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Components.AudioComponent.Auxiliary">
            <summary>
            Auxiliary entity to pass audio to.
            </summary>
        </member>
        <member name="M:Robust.Shared.Audio.Components.AudioComponent.StartPlaying">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Audio.Components.AudioComponent.StopPlaying">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Audio.Components.AudioComponent.Restart">
            <inheritdoc />
        </member>
        <member name="F:Robust.Shared.Audio.Components.AudioComponent.PauseTime">
            <summary>
            Time when the audio was paused so we can offset it later if relevant.
            </summary>
        </member>
        <member name="P:Robust.Shared.Audio.Components.AudioComponent.Playing">
            <summary>
            <see cref="P:Robust.Shared.Audio.Sources.IAudioSource.Playing"/>
            </summary>
        </member>
        <member name="P:Robust.Shared.Audio.Components.AudioComponent.Looping">
            <summary>
            <see cref="P:Robust.Shared.Audio.Sources.IAudioSource.Looping"/>
            </summary>
        </member>
        <member name="P:Robust.Shared.Audio.Components.AudioComponent.Global">
            <summary>
            <see cref="P:Robust.Shared.Audio.Sources.IAudioSource.Global"/>
            </summary>
        </member>
        <member name="P:Robust.Shared.Audio.Components.AudioComponent.Pitch">
            <summary>
            <see cref="P:Robust.Shared.Audio.Sources.IAudioSource.Pitch"/>
            </summary>
        </member>
        <member name="P:Robust.Shared.Audio.Components.AudioComponent.MaxDistance">
            <summary>
            <see cref="P:Robust.Shared.Audio.Sources.IAudioSource.MaxDistance"/>
            </summary>
        </member>
        <member name="P:Robust.Shared.Audio.Components.AudioComponent.RolloffFactor">
            <summary>
            <see cref="P:Robust.Shared.Audio.Sources.IAudioSource.RolloffFactor"/>
            </summary>
        </member>
        <member name="P:Robust.Shared.Audio.Components.AudioComponent.ReferenceDistance">
            <summary>
            <see cref="P:Robust.Shared.Audio.Sources.IAudioSource.ReferenceDistance"/>
            </summary>
        </member>
        <member name="P:Robust.Shared.Audio.Components.AudioComponent.Position">
            <summary>
            <see cref="P:Robust.Shared.Audio.Sources.IAudioSource.Position"/>
            </summary>
            <remarks>
            Not replicated as audio always tracks the entity's position.
            </remarks>
        </member>
        <member name="P:Robust.Shared.Audio.Components.AudioComponent.Volume">
            <summary>
            <see cref="P:Robust.Shared.Audio.Sources.IAudioSource.Volume"/>
            </summary>
        </member>
        <member name="P:Robust.Shared.Audio.Components.AudioComponent.Gain">
            <summary>
            <see cref="P:Robust.Shared.Audio.Sources.IAudioSource.Gain"/>
            </summary>
        </member>
        <member name="P:Robust.Shared.Audio.Components.AudioComponent.Occlusion">
            <summary>
            <see cref="P:Robust.Shared.Audio.Sources.IAudioSource.Occlusion"/>
            </summary>
        </member>
        <member name="P:Robust.Shared.Audio.Components.AudioComponent.PlaybackPosition">
            <summary>
            <see cref="P:Robust.Shared.Audio.Sources.IAudioSource.PlaybackPosition"/>
            </summary>
        </member>
        <member name="P:Robust.Shared.Audio.Components.AudioComponent.Velocity">
            <summary>
            <see cref="P:Robust.Shared.Audio.Sources.IAudioSource.Velocity"/>
            </summary>
            <remarks>
            Not replicated.
            </remarks>
        </member>
        <member name="M:Robust.Shared.Audio.Components.AudioComponent.InternalCopy(Robust.Shared.Audio.Components.AudioComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Audio.Components.AudioComponent.Copy(Robust.Shared.Audio.Components.AudioComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Audio.Components.AudioComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Audio.Components.AudioComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Audio.Components.AudioComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Audio.Components.AudioComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Audio.Components.AudioComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="F:Robust.Shared.Audio.Components.AudioFlags.GridAudio">
            <summary>
            Should the audio act as if attached to a grid?
            </summary>
        </member>
        <member name="T:Robust.Shared.Audio.Components.AudioEffectComponent">
            <summary>
            Stores OpenAL audio effect data that can be bound to an <see cref="T:Robust.Shared.Audio.Components.AudioAuxiliaryComponent"/>.
            </summary>
        </member>
        <member name="P:Robust.Shared.Audio.Components.AudioEffectComponent.Density">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Components.AudioEffectComponent.Diffusion">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Components.AudioEffectComponent.Gain">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Components.AudioEffectComponent.GainHF">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Components.AudioEffectComponent.GainLF">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Components.AudioEffectComponent.DecayTime">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Components.AudioEffectComponent.DecayHFRatio">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Components.AudioEffectComponent.DecayLFRatio">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Components.AudioEffectComponent.ReflectionsGain">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Components.AudioEffectComponent.ReflectionsDelay">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Components.AudioEffectComponent.ReflectionsPan">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Components.AudioEffectComponent.LateReverbGain">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Components.AudioEffectComponent.LateReverbDelay">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Components.AudioEffectComponent.LateReverbPan">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Components.AudioEffectComponent.EchoTime">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Components.AudioEffectComponent.EchoDepth">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Components.AudioEffectComponent.ModulationTime">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Components.AudioEffectComponent.ModulationDepth">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Components.AudioEffectComponent.AirAbsorptionGainHF">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Components.AudioEffectComponent.HFReference">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Components.AudioEffectComponent.LFReference">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Components.AudioEffectComponent.RoomRolloffFactor">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Components.AudioEffectComponent.DecayHFLimit">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Audio.Components.AudioEffectComponent.InternalCopy(Robust.Shared.Audio.Components.AudioEffectComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Audio.Components.AudioEffectComponent.Copy(Robust.Shared.Audio.Components.AudioEffectComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Audio.Components.AudioEffectComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Audio.Components.AudioEffectComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Audio.Components.AudioEffectComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Audio.Components.AudioEffectComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Audio.Components.AudioEffectComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Shared.Audio.Components.AudioPresetComponent">
            <summary>
            Marks this entity as being spawned for audio presets in case we need to reload.
            </summary>
        </member>
        <member name="M:Robust.Shared.Audio.Components.AudioPresetComponent.InternalCopy(Robust.Shared.Audio.Components.AudioPresetComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Audio.Components.AudioPresetComponent.Copy(Robust.Shared.Audio.Components.AudioPresetComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Audio.Components.AudioPresetComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Audio.Components.AudioPresetComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Audio.Components.AudioPresetComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Audio.Components.AudioPresetComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Audio.Components.AudioPresetComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Shared.Audio.Effects.DummyAudioEffect">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Effects.DummyAudioEffect.Density">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Effects.DummyAudioEffect.Diffusion">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Effects.DummyAudioEffect.Gain">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Effects.DummyAudioEffect.GainHF">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Effects.DummyAudioEffect.GainLF">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Effects.DummyAudioEffect.DecayTime">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Effects.DummyAudioEffect.DecayHFRatio">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Effects.DummyAudioEffect.DecayLFRatio">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Effects.DummyAudioEffect.ReflectionsGain">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Effects.DummyAudioEffect.ReflectionsDelay">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Effects.DummyAudioEffect.ReflectionsPan">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Effects.DummyAudioEffect.LateReverbGain">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Effects.DummyAudioEffect.LateReverbDelay">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Effects.DummyAudioEffect.LateReverbPan">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Effects.DummyAudioEffect.EchoTime">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Effects.DummyAudioEffect.EchoDepth">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Effects.DummyAudioEffect.ModulationTime">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Effects.DummyAudioEffect.ModulationDepth">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Effects.DummyAudioEffect.AirAbsorptionGainHF">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Effects.DummyAudioEffect.HFReference">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Effects.DummyAudioEffect.LFReference">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Effects.DummyAudioEffect.RoomRolloffFactor">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Effects.DummyAudioEffect.DecayHFLimit">
            <inheritdoc />
        </member>
        <member name="T:Robust.Shared.Audio.Effects.DummyAuxiliaryAudio">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Audio.Effects.DummyAuxiliaryAudio.SetEffect(Robust.Shared.Audio.Effects.IAudioEffect)">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Effects.IAudioEffect.Density">
            <summary>
            Gets the preset value for <see cref="!:EffectFloat.ReverbDensity"/>.
            </summary>
        </member>
        <member name="P:Robust.Shared.Audio.Effects.IAudioEffect.Diffusion">
            <summary>
            Gets the preset value for <see cref="!:EffectFloat.ReverbDiffusion"/>.
            </summary>
        </member>
        <member name="P:Robust.Shared.Audio.Effects.IAudioEffect.Gain">
            <summary>
            Gets the preset value for <ReverbGainsee cref="!:EffectFloat.ReverbGain"/>.
            </summary>
        </member>
        <member name="P:Robust.Shared.Audio.Effects.IAudioEffect.GainHF">
            <summary>
            Gets the preset value for <see cref="!:EffectFloat.ReverbGainHF"/>.
            </summary>
        </member>
        <member name="P:Robust.Shared.Audio.Effects.IAudioEffect.GainLF">
            <summary>
            Gets the preset value for <see cref="!:EffectFloat.EaxReverbGainLF"/>.
            </summary>
        </member>
        <member name="P:Robust.Shared.Audio.Effects.IAudioEffect.DecayTime">
            <summary>
            Gets the preset value for <see cref="!:EffectFloat.ReverbDecayTime"/>.
            </summary>
        </member>
        <member name="P:Robust.Shared.Audio.Effects.IAudioEffect.DecayHFRatio">
            <summary>
            Gets the preset value for <see cref="!:EffectFloat.ReverbDecayHFRatio"/>.
            </summary>
        </member>
        <member name="P:Robust.Shared.Audio.Effects.IAudioEffect.DecayLFRatio">
            <summary>
            Gets the preset value for <see cref="!:EffectFloat.EaxReverbDecayLFRatio"/>.
            </summary>
        </member>
        <member name="P:Robust.Shared.Audio.Effects.IAudioEffect.ReflectionsGain">
            <summary>
            Gets the preset value for <see cref="!:EffectFloat.ReverbReflectionsGain"/>.
            </summary>
        </member>
        <member name="P:Robust.Shared.Audio.Effects.IAudioEffect.ReflectionsDelay">
            <summary>
            Gets the preset value for <see cref="!:EffectFloat.ReverbReflectionsDelay"/>.
            </summary>
        </member>
        <member name="P:Robust.Shared.Audio.Effects.IAudioEffect.ReflectionsPan">
            <summary>
            Gets the preset value for <see cref="!:EffectVector3.EaxReverbReflectionsPan"/>.
            </summary>
        </member>
        <member name="P:Robust.Shared.Audio.Effects.IAudioEffect.LateReverbGain">
            <summary>
            Gets the preset value for <see cref="!:EffectFloat.ReverbLateReverbGain"/>.
            </summary>
        </member>
        <member name="P:Robust.Shared.Audio.Effects.IAudioEffect.LateReverbDelay">
            <summary>
            Gets the preset value for <see cref="!:EffectFloat.ReverbLateReverbDelay"/>.
            </summary>
        </member>
        <member name="P:Robust.Shared.Audio.Effects.IAudioEffect.LateReverbPan">
            <summary>
            Gets the preset value for <see cref="!:EffectVector3.EaxReverbLateReverbPan"/>.
            </summary>
        </member>
        <member name="P:Robust.Shared.Audio.Effects.IAudioEffect.EchoTime">
            <summary>
            Gets the preset value for <see cref="!:EffectFloat.EaxReverbEchoTime"/>.
            </summary>
        </member>
        <member name="P:Robust.Shared.Audio.Effects.IAudioEffect.EchoDepth">
            <summary>
            Gets the preset value for <see cref="!:EffectFloat.EaxReverbEchoDepth"/>.
            </summary>
        </member>
        <member name="P:Robust.Shared.Audio.Effects.IAudioEffect.ModulationTime">
            <summary>
            Gets the preset value for <see cref="!:EffectFloat.EaxReverbModulationTime"/>.
            </summary>
        </member>
        <member name="P:Robust.Shared.Audio.Effects.IAudioEffect.ModulationDepth">
            <summary>
            Gets the preset value for <see cref="!:EffectFloat.EaxReverbModulationDepth"/>.
            </summary>
        </member>
        <member name="P:Robust.Shared.Audio.Effects.IAudioEffect.AirAbsorptionGainHF">
            <summary>
            Gets the preset value for <see cref="!:EffectFloat.ReverbAirAbsorptionGainHF"/>.
            </summary>
        </member>
        <member name="P:Robust.Shared.Audio.Effects.IAudioEffect.HFReference">
            <summary>
            Gets the preset value for <see cref="!:EffectFloat.EaxReverbHFReference"/>.
            </summary>
        </member>
        <member name="P:Robust.Shared.Audio.Effects.IAudioEffect.LFReference">
            <summary>
            Gets the preset value for <see cref="!:EffectFloat.EaxReverbLFReference"/>.
            </summary>
        </member>
        <member name="P:Robust.Shared.Audio.Effects.IAudioEffect.RoomRolloffFactor">
            <summary>
            Gets the preset value for <see cref="!:EffectFloat.ReverbRoomRolloffFactor"/>.
            </summary>
        </member>
        <member name="P:Robust.Shared.Audio.Effects.IAudioEffect.DecayHFLimit">
            <summary>
            Gets the preset value for <see cref="!:EffectInteger.ReverbDecayHFLimit"/>.
            </summary>
        </member>
        <member name="M:Robust.Shared.Audio.Effects.IAuxiliaryAudio.SetEffect(Robust.Shared.Audio.Effects.IAudioEffect)">
            <summary>
            Sets the audio effect for this auxiliary audio slot.
            </summary>
        </member>
        <member name="T:Robust.Shared.Audio.Effects.ReverbPresets">
            <summary>
            A set of reverb presets that can be used with the extension.
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.Generic">
            <summary>
            A reverb preset (approximating a generic location).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.PaddedCell">
            <summary>
            A reverb preset (approximating a padded cell).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.Room">
            <summary>
            A reverb preset (approximating a room).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.Bathroom">
            <summary>
            A reverb preset (approximating a bathroom).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.LivingRoom">
            <summary>
            A reverb preset (approximating a living room).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.StoneRoom">
            <summary>
            A reverb preset (approximating a stone room).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.Auditorium">
            <summary>
            A reverb preset (approximating an auditorium).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.ConcertHall">
            <summary>
            A reverb preset (approximating a concert hall).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.Cave">
            <summary>
            A reverb preset (approximating a cave).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.Arena">
            <summary>
            A reverb preset (approximating an arena).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.Hangar">
            <summary>
            A reverb preset (approximating a hangar).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.CarpetedHallway">
            <summary>
            A reverb preset (approximating a carpeted hallway).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.Hallway">
            <summary>
            A reverb preset (approximating a hallway).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.StoneCorridor">
            <summary>
            A reverb preset (approximating a stone corridor).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.Alley">
            <summary>
            A reverb preset (approximating an alley).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.Forest">
            <summary>
            A reverb preset (approximating a forest).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.City">
            <summary>
            A reverb preset (approximating a city).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.Mountains">
            <summary>
            A reverb preset (approximating a mountain).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.Quarry">
            <summary>
            A reverb preset (approximating a quarry).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.Plain">
            <summary>
            A reverb preset (approximating a plain).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.ParkingLot">
            <summary>
            A reverb preset (approximating a parking lot).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.Sewerpipe">
            <summary>
            A reverb preset (approximating a sewer pipe).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.Underwater">
            <summary>
            A reverb preset (approximating an underwater location).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.Drugged">
            <summary>
            A reverb preset (approximating a drugged state).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.Dizzy">
            <summary>
            A reverb preset (approximating a dizzy state).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.Psychotic">
            <summary>
            A reverb preset (approximating a psychotic state).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.CastleSmallRoom">
            <summary>
            A reverb preset (approximating a small room in a castle).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.CastleShortPassage">
            <summary>
            A reverb preset (approximating a short passage in a castle).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.CastleMediumRoom">
            <summary>
            A reverb preset (approximating a medium room in a castle).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.CastleLargeRoom">
            <summary>
            A reverb preset (approximating a large room in a castle).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.CastleLongPassage">
            <summary>
            A reverb preset (approximating a long passage in a castle).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.CastleHall">
            <summary>
            A reverb preset (approximating a hall in a castle).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.CastleCupboard">
            <summary>
            A reverb preset (approximating a cupboard in a castle).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.CastleCourtyard">
            <summary>
            A reverb preset (approximating a castle courtyard).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.CastleAlcove">
            <summary>
            A reverb preset (approximating an alcove in a castle).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.FactorySmallRoom">
            <summary>
            A reverb preset (approximating a small room in a factory).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.FactoryShortPassage">
            <summary>
            A reverb preset (approximating a short passage in a factory).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.FactoryMediumRoom">
            <summary>
            A reverb preset (approximating a medium room in a factory).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.FactoryLargeRoom">
            <summary>
            A reverb preset (approximating a large room in a factory).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.FactoryLongPassage">
            <summary>
            A reverb preset (approximating a long passage in a factory).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.FactoryHall">
            <summary>
            A reverb preset (approximating a hall in a factory).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.FactoryCupboard">
            <summary>
            A reverb preset (approximating a cupboard in a factory).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.FactoryCourtyard">
            <summary>
            A reverb preset (approximating a factory courtyard).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.FactoryAlcove">
            <summary>
            A reverb preset (approximating an alcove in a factory).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.IcePalaceSmallRoom">
            <summary>
            A reverb preset (approximating a small room in an ice palace).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.IcePalaceShortPassage">
            <summary>
            A reverb preset (approximating a short passage in an ice palace).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.IcePalaceMediumRoom">
            <summary>
            A reverb preset (approximating a medium room in an ice palace).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.IcePalaceLargeRoom">
            <summary>
            A reverb preset (approximating a large room in an ice palace).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.IcePalaceLongPassage">
            <summary>
            A reverb preset (approximating a long passage in an ice palace).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.IcePalaceHall">
            <summary>
            A reverb preset (approximating a hall in an ice palace).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.IcePalaceCupboard">
            <summary>
            A reverb preset (approximating a cupboard in an ice palace).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.IcePalaceCourtyard">
            <summary>
            A reverb preset (approximating an ice palace courtyard).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.IcePalaceAlcove">
            <summary>
            A reverb preset (approximating an alcove in an ice palace).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.SpaceStationSmallRoom">
            <summary>
            A reverb preset (approximating a small room in a space station).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.SpaceStationShortPassage">
            <summary>
            A reverb preset (approximating a short passage in a space station).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.SpaceStationMediumRoom">
            <summary>
            A reverb preset (approximating a medium room in a space station).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.SpaceStationLargeRoom">
            <summary>
            A reverb preset (approximating a large room in a space station).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.SpaceStationLongPassage">
            <summary>
            A reverb preset (approximating a long passage in a space station).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.SpaceStationHall">
            <summary>
            A reverb preset (approximating a hall in a space station).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.SpaceStationCupboard">
            <summary>
            A reverb preset (approximating a cupboard in a space station).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.SpaceStationAlcove">
            <summary>
            A reverb preset (approximating an alcove in a space station).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.WoodenGalleonSmallRoom">
            <summary>
            A reverb preset (approximating a small room in a wooden galleon).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.WoodenGalleonShortPassage">
            <summary>
            A reverb preset (approximating a short passage in a wooden galleon).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.WoodenGalleonMediumRoom">
            <summary>
            A reverb preset (approximating a medium room in a wooden galleon).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.WoodenGalleonLargeRoom">
            <summary>
            A reverb preset (approximating a large room in a wooden galleon).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.WoodenGalleonLongPassage">
            <summary>
            A reverb preset (approximating a long passsage in a wooden galleon).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.WoodenGalleonHall">
            <summary>
            A reverb preset (approximating a hall in a wooden galleon).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.WoodenGalleonCupboard">
            <summary>
            A reverb preset (approximating a cupboard in a wooden galleon).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.WoodenGalleonCourtyard">
            <summary>
            A reverb preset (approximating a courtyard on a wooden galleon).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.WoodenGalleonAlcove">
            <summary>
            A reverb preset (approximating an alcove in a wooden galleon).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.SportEmptyStadium">
            <summary>
            A reverb preset (approximating an empty sports stadium).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.SportSquashCourt">
            <summary>
            A reverb preset (approximating a squash court).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.SportSmallSwimmingPool">
            <summary>
            A reverb preset (approximating a small swimming pool).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.SportLargeSwimmingPool">
            <summary>
            A reverb preset (approximating a large swimming pool).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.SportGymnasium">
            <summary>
            A reverb preset (approximating a gymnasium).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.SportFullStadium">
            <summary>
            A reverb preset (approximating a full stadium).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.SportStadiumTannoy">
            <summary>
            A reverb preset (approximating a tannoy stadium).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.PrefabWorkshop">
            <summary>
            A reverb preset (approximating a workshop).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.PrefabSchoolRoom">
            <summary>
            A reverb preset (approximating a school room).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.PrefabPractiseRoom">
            <summary>
            A reverb preset (approximating a practise room).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.PrefabOuthouse">
            <summary>
            A reverb preset (approximating an outhouse).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.PrefabCaravan">
            <summary>
            A reverb preset (approximating a caravan).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.DomeTomb">
            <summary>
            A reverb preset (approximating a dome in a tomb).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.PipeSmall">
            <summary>
            A reverb preset (approximating a small pipe).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.DomeSaintPauls">
            <summary>
            A reverb preset (approximating the dome in St. Paul's Cathedral, London).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.PipeLongThin">
            <summary>
            A reverb preset (approximating a long, thin pipe).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.PipeLarge">
            <summary>
            A reverb preset (approximating a large pipe).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.PipeResonant">
            <summary>
            A reverb preset (approximating a resonant pipe).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.OutdoorsBackyard">
            <summary>
            A reverb preset (approximating an outdoors backyard).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.OutdoorsRollingPlains">
            <summary>
            A reverb preset (approximating rolling plains).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.OutdoorsDeepCanyon">
            <summary>
            A reverb preset (approximating a deep canyon).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.OutdoorsCreek">
            <summary>
            A reverb preset (approximating a creek).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.OutdoorsValley">
            <summary>
            A reverb preset (approximating a valley).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.MoodHeaven">
            <summary>
            A reverb preset (approximating a heavenly mood).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.MoodHell">
            <summary>
            A reverb preset (approximating a hellish mood).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.MoodMemory">
            <summary>
            A reverb preset (approximating an abstract memory).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.DrivingCommentator">
            <summary>
            A reverb preset (approximating a person in the commentator's seat).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.DrivingPitGarage">
            <summary>
            A reverb preset (approximating a pit or garage).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.DrivingInCarRacer">
            <summary>
            A reverb preset (approximating driving in a race car).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.DrivingInCarSports">
            <summary>
            A reverb preset (approximating driving in a sports car).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.DrivingInCarLuxury">
            <summary>
            A reverb preset (approximating driving in a luxury car).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.DrivingFullGrandStand">
            <summary>
            A reverb preset (approximating driving on a course with a full grand stand).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.DrivingEmptyGrandStand">
            <summary>
            A reverb preset (approximating an empty grand stand).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.DrivingTunnel">
            <summary>
            A reverb preset (approximating driving in a tunnel).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.CityStreets">
            <summary>
            A reverb preset (approximating city streets).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.CitySubway">
            <summary>
            A reverb preset (approximating a subway).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.CityMuseum">
            <summary>
            A reverb preset (approximating a museum).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.CityLibrary">
            <summary>
            A reverb preset (approximating a library).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.CityUnderpass">
            <summary>
            A reverb preset (approximating an underpass).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.CityAbandoned">
            <summary>
            A reverb preset (approximating an abandoned location).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.DustyRoom">
            <summary>
            A reverb preset (approximating a dusty room).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.Chapel">
            <summary>
            A reverb preset (approximating a chapel).
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbPresets.SmallWaterRoom">
            <summary>
            A reverb preset (approximating a small, water-filled room).
            </summary>
        </member>
        <member name="T:Robust.Shared.Audio.Effects.ReverbProperties">
            <summary>
            Defines a set of predefined reverb properties.
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbProperties.Density">
            <summary>
            Gets the preset value for <see cref="!:EffectFloat.ReverbDensity"/>.
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbProperties.Diffusion">
            <summary>
            Gets the preset value for <see cref="!:EffectFloat.ReverbDiffusion"/>.
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbProperties.Gain">
            <summary>
            Gets the preset value for <ReverbGainsee cref="!:EffectFloat.ReverbGain"/>.
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbProperties.GainHF">
            <summary>
            Gets the preset value for <see cref="!:EffectFloat.ReverbGainHF"/>.
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbProperties.GainLF">
            <summary>
            Gets the preset value for <see cref="!:EffectFloat.EaxReverbGainLF"/>.
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbProperties.DecayTime">
            <summary>
            Gets the preset value for <see cref="!:EffectFloat.ReverbDecayTime"/>.
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbProperties.DecayHFRatio">
            <summary>
            Gets the preset value for <see cref="!:EffectFloat.ReverbDecayHFRatio"/>.
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbProperties.DecayLFRatio">
            <summary>
            Gets the preset value for <see cref="!:EffectFloat.EaxReverbDecayLFRatio"/>.
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbProperties.ReflectionsGain">
            <summary>
            Gets the preset value for <see cref="!:EffectFloat.ReverbReflectionsGain"/>.
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbProperties.ReflectionsDelay">
            <summary>
            Gets the preset value for <see cref="!:EffectFloat.ReverbReflectionsDelay"/>.
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbProperties.ReflectionsPan">
            <summary>
            Gets the preset value for <see cref="!:EffectVector3.EaxReverbReflectionsPan"/>.
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbProperties.LateReverbGain">
            <summary>
            Gets the preset value for <see cref="!:EffectFloat.ReverbLateReverbGain"/>.
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbProperties.LateReverbDelay">
            <summary>
            Gets the preset value for <see cref="!:EffectFloat.ReverbLateReverbDelay"/>.
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbProperties.LateReverbPan">
            <summary>
            Gets the preset value for <see cref="!:EffectVector3.EaxReverbLateReverbPan"/>.
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbProperties.EchoTime">
            <summary>
            Gets the preset value for <see cref="!:EffectFloat.EaxReverbEchoTime"/>.
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbProperties.EchoDepth">
            <summary>
            Gets the preset value for <see cref="!:EffectFloat.EaxReverbEchoDepth"/>.
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbProperties.ModulationTime">
            <summary>
            Gets the preset value for <see cref="!:EffectFloat.EaxReverbModulationTime"/>.
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbProperties.ModulationDepth">
            <summary>
            Gets the preset value for <see cref="!:EffectFloat.EaxReverbModulationDepth"/>.
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbProperties.AirAbsorptionGainHF">
            <summary>
            Gets the preset value for <see cref="!:EffectFloat.ReverbAirAbsorptionGainHF"/>.
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbProperties.HFReference">
            <summary>
            Gets the preset value for <see cref="!:EffectFloat.EaxReverbHFReference"/>.
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbProperties.LFReference">
            <summary>
            Gets the preset value for <see cref="!:EffectFloat.EaxReverbLFReference"/>.
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbProperties.RoomRolloffFactor">
            <summary>
            Gets the preset value for <see cref="!:EffectFloat.ReverbRoomRolloffFactor"/>.
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Effects.ReverbProperties.DecayHFLimit">
            <summary>
            Gets the preset value for <see cref="!:EffectInteger.ReverbDecayHFLimit"/>.
            </summary>
        </member>
        <member name="M:Robust.Shared.Audio.Effects.ReverbProperties.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,Robust.Shared.Maths.Vector3,System.Single,System.Single,Robust.Shared.Maths.Vector3,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Robust.Shared.Audio.Effects.ReverbProperties"/> struct.
            </summary>
            <param name="density">See <see cref="F:Robust.Shared.Audio.Effects.ReverbProperties.Density"/>.</param>
            <param name="diffusion">See <see cref="F:Robust.Shared.Audio.Effects.ReverbProperties.Diffusion"/>.</param>
            <param name="gain">See <see cref="F:Robust.Shared.Audio.Effects.ReverbProperties.Gain"/>.</param>
            <param name="gainHF">See <see cref="F:Robust.Shared.Audio.Effects.ReverbProperties.GainHF"/>.</param>
            <param name="gainLF">See <see cref="F:Robust.Shared.Audio.Effects.ReverbProperties.GainLF"/>.</param>
            <param name="decayTime">See <see cref="F:Robust.Shared.Audio.Effects.ReverbProperties.DecayTime"/>.</param>
            <param name="decayHFRatio">See <see cref="F:Robust.Shared.Audio.Effects.ReverbProperties.DecayHFRatio"/>.</param>
            <param name="decayLFRatio">See <see cref="F:Robust.Shared.Audio.Effects.ReverbProperties.DecayLFRatio"/>.</param>
            <param name="reflectionsGain">See <see cref="F:Robust.Shared.Audio.Effects.ReverbProperties.ReflectionsGain"/>.</param>
            <param name="reflectionsDelay">See <see cref="F:Robust.Shared.Audio.Effects.ReverbProperties.ReflectionsDelay"/>.</param>
            <param name="reflectionsPan">See <see cref="F:Robust.Shared.Audio.Effects.ReverbProperties.ReflectionsPan"/>.</param>
            <param name="lateReverbGain">See <see cref="F:Robust.Shared.Audio.Effects.ReverbProperties.LateReverbGain"/>.</param>
            <param name="lateReverbDelay">See <see cref="F:Robust.Shared.Audio.Effects.ReverbProperties.LateReverbDelay"/>.</param>
            <param name="lateReverbPan">See <see cref="F:Robust.Shared.Audio.Effects.ReverbProperties.LateReverbPan"/>.</param>
            <param name="echoTime">See <see cref="F:Robust.Shared.Audio.Effects.ReverbProperties.EchoTime"/>.</param>
            <param name="echoDepth">See <see cref="F:Robust.Shared.Audio.Effects.ReverbProperties.EchoDepth"/>.</param>
            <param name="modulationTime">See <see cref="F:Robust.Shared.Audio.Effects.ReverbProperties.ModulationTime"/>.</param>
            <param name="modulationDepth">See <see cref="F:Robust.Shared.Audio.Effects.ReverbProperties.ModulationDepth"/>.</param>
            <param name="airAbsorptionGainHF">See <see cref="F:Robust.Shared.Audio.Effects.ReverbProperties.AirAbsorptionGainHF"/>.</param>
            <param name="hfReference">See <see cref="F:Robust.Shared.Audio.Effects.ReverbProperties.HFReference"/>.</param>
            <param name="lfReference">See <see cref="F:Robust.Shared.Audio.Effects.ReverbProperties.LFReference"/>.</param>
            <param name="roomRolloffFactor">See <see cref="F:Robust.Shared.Audio.Effects.ReverbProperties.RoomRolloffFactor"/>.</param>
            <param name="decayHFLimit">See <see cref="F:Robust.Shared.Audio.Effects.ReverbProperties.DecayHFLimit"/>.</param>
        </member>
        <member name="T:Robust.Shared.Audio.Midi.RobustMidiCommand">
            <summary>
                Helper enum that keeps track of all MIDI commands that Robust currently supports.
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Midi.RobustMidiCommand.NoteOff">
            <summary>
                NoteOff event.              <br/>
                data1 - Key,                <br/>
                data2 - undefined
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Midi.RobustMidiCommand.NoteOn">
            <summary>
                NoteOn event.               <br/>
                data1 - Key,                <br/>
                data2 - Velocity
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Midi.RobustMidiCommand.AfterTouch">
            <summary>
                AfterTouch event.           <br/>
                data1 - Key,                <br/>
                data2 - Value
            </summary>
            <remarks>Also known as "KeyPressure".</remarks>
        </member>
        <member name="F:Robust.Shared.Audio.Midi.RobustMidiCommand.ControlChange">
            <summary>
                ControlChange (CC) event.   <br/>
                data1 - Control,            <br/>
                data2 - Value
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Midi.RobustMidiCommand.ProgramChange">
            <summary>
                ProgramChange event.        <br/>
                data1 - Program,            <br/>
                data2 - undefined
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Midi.RobustMidiCommand.ChannelPressure">
            <summary>
                ChannelPressure event.      <br/>
                data1 - Value,              <br/>
                data2 - undefined
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Midi.RobustMidiCommand.PitchBend">
            <summary>
                PitchBend event.            <br/>
                data1 - Lower Pitch Nibble, <br/>
                data2 - Higher Pitch Nibble
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Midi.RobustMidiCommand.SystemMessage">
            <summary>
                SystemMessage event.        <br/>
                data1 - Control             <br/>
                data2 - undefined
            </summary>
        </member>
        <member name="T:Robust.Shared.Audio.Midi.RobustMidiEvent">
            <summary>
                This class is a lightweight data representation of a Midi Event.
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Midi.RobustMidiEvent.Status">
            <summary>
                Byte that stores both Command Type and Channel.
            </summary>
        </member>
        <member name="F:Robust.Shared.Audio.Midi.RobustMidiEvent.Tick">
            <summary>
                Sequencer tick to schedule this event at.
            </summary>
        </member>
        <member name="M:Robust.Shared.Audio.Midi.RobustMidiEvent.#ctor(Robust.Shared.Audio.Midi.RobustMidiEvent,System.UInt32)">
            <summary>
                Clones another event but with a different tick value.
            </summary>
        </member>
        <member name="M:Robust.Shared.Audio.Midi.RobustMidiEvent.MakeStatus(System.Byte,System.Byte)">
            <summary> Returns a status byte given a channel byte and a command type byte. </summary>
        </member>
        <member name="M:Robust.Shared.Audio.Midi.RobustMidiEvent.MakeStatus(System.Byte,Robust.Shared.Audio.Midi.RobustMidiCommand)">
            <summary> Returns a status byte given a channel byte and a command type. </summary>
        </member>
        <member name="M:Robust.Shared.Audio.Midi.RobustMidiEvent.NoteOff(System.Byte,System.Byte,System.UInt32)">
            <summary> Creates and returns an event to turn off a note on a given channel. </summary>
        </member>
        <member name="M:Robust.Shared.Audio.Midi.RobustMidiEvent.NoteOn(System.Byte,System.Byte,System.Byte,System.UInt32)">
            <summary> Creates and returns an event to turn on a note on a given channel. </summary>
        </member>
        <member name="M:Robust.Shared.Audio.Midi.RobustMidiEvent.AfterTouch(System.Byte,System.Byte,System.Byte,System.UInt32)">
            <summary> Creates and returns an event to change the velocity on an active note on a given channel. </summary>
        </member>
        <member name="M:Robust.Shared.Audio.Midi.RobustMidiEvent.ControlChange(System.Byte,System.Byte,System.Byte,System.UInt32)">
            <summary> Creates and returns an event to change a specific controller value on a given channel. </summary>
        </member>
        <member name="M:Robust.Shared.Audio.Midi.RobustMidiEvent.ProgramChange(System.Byte,System.Byte,System.UInt32)">
            <summary> Creates and returns an event to change the program on a given channel. </summary>
        </member>
        <member name="M:Robust.Shared.Audio.Midi.RobustMidiEvent.ChannelPressure(System.Byte,System.Byte,System.UInt32)">
            <summary> Creates and returns an event to change the note pressure on a given channel. </summary>
        </member>
        <member name="M:Robust.Shared.Audio.Midi.RobustMidiEvent.PitchBend(System.Byte,System.UInt16,System.UInt32)">
            <summary> Creates and returns an event to bend the pitch on a given channel. </summary>
        </member>
        <member name="M:Robust.Shared.Audio.Midi.RobustMidiEvent.BankSelect(System.Byte,System.Byte,System.UInt32)">
            <summary> Creates and returns an event to select the bank on a given channel. </summary>
        </member>
        <member name="M:Robust.Shared.Audio.Midi.RobustMidiEvent.AllNotesOff(System.Byte,System.UInt32)">
            <summary> Creates and returns an event to turn all notes off on a given channel. </summary>
        </member>
        <member name="M:Robust.Shared.Audio.Midi.RobustMidiEvent.ResetAllControllers(System.UInt32)">
            <summary> Creates and returns an event to reset all controllers. </summary>
        </member>
        <member name="M:Robust.Shared.Audio.Midi.RobustMidiEvent.SystemMessage(System.Byte,System.Byte,System.UInt32)">
            <summary> Creates and returns a system message event. </summary>
        </member>
        <member name="M:Robust.Shared.Audio.Midi.RobustMidiEvent.SystemReset(System.UInt32)">
            <summary> Creates and returns a system reset event. </summary>
        </member>
        <member name="M:Robust.Shared.Audio.SoundSpecifier.InternalCopy(Robust.Shared.Audio.SoundSpecifier@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Audio.SoundSpecifier.Copy(Robust.Shared.Audio.SoundSpecifier@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Audio.SoundSpecifier.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Audio.SoundSpecifier.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Audio.SoundPathSpecifier.InternalCopy(Robust.Shared.Audio.SoundPathSpecifier@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Audio.SoundPathSpecifier.Copy(Robust.Shared.Audio.SoundPathSpecifier@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Audio.SoundPathSpecifier.Copy(Robust.Shared.Audio.SoundSpecifier@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Audio.SoundPathSpecifier.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Audio.SoundPathSpecifier.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Audio.SoundCollectionSpecifier.InternalCopy(Robust.Shared.Audio.SoundCollectionSpecifier@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Audio.SoundCollectionSpecifier.Copy(Robust.Shared.Audio.SoundCollectionSpecifier@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Audio.SoundCollectionSpecifier.Copy(Robust.Shared.Audio.SoundSpecifier@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Audio.SoundCollectionSpecifier.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Audio.SoundCollectionSpecifier.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Shared.Audio.Sources.DummyAudioSource">
            <summary>
                Hey look, it's AudioSource's evil twin brother!
            </summary>
        </member>
        <member name="M:Robust.Shared.Audio.Sources.DummyAudioSource.Pause">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Audio.Sources.DummyAudioSource.StartPlaying">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Audio.Sources.DummyAudioSource.StopPlaying">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Audio.Sources.DummyAudioSource.Restart">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Sources.DummyAudioSource.Playing">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Sources.DummyAudioSource.Looping">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Sources.DummyAudioSource.Global">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Sources.DummyAudioSource.Position">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Sources.DummyAudioSource.Pitch">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Sources.DummyAudioSource.Volume">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Sources.DummyAudioSource.Gain">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Sources.DummyAudioSource.MaxDistance">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Sources.DummyAudioSource.RolloffFactor">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Sources.DummyAudioSource.ReferenceDistance">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Sources.DummyAudioSource.Occlusion">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Sources.DummyAudioSource.PlaybackPosition">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Audio.Sources.DummyAudioSource.Velocity">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Audio.Sources.DummyAudioSource.InternalCopy(Robust.Shared.Audio.Sources.DummyAudioSource@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Audio.Sources.DummyAudioSource.Copy(Robust.Shared.Audio.Sources.DummyAudioSource@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Audio.Sources.DummyAudioSource.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Audio.Sources.DummyAudioSource.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Shared.Audio.Sources.DummyBufferedAudioSource">
            <summary>
                Hey look, it's Audio.BufferedAudioSource's evil twin brother!
            </summary>
        </member>
        <member name="T:Robust.Shared.Audio.Sources.IAudioSource">
            <summary>
            Engine audio source that directly interacts with OpenAL.
            </summary>
            <remarks>
            This just exists so client can interact with OpenAL and server can interact with nothing.
            </remarks>
        </member>
        <member name="M:Robust.Shared.Audio.Sources.IAudioSource.StartPlaying">
            <summary>
            Tries to start playing the audio if not already playing.
            </summary>
        </member>
        <member name="M:Robust.Shared.Audio.Sources.IAudioSource.StopPlaying">
            <summary>
            Stops playing a source if it is currently playing.
            </summary>
        </member>
        <member name="M:Robust.Shared.Audio.Sources.IAudioSource.Restart">
            <summary>
            Restarts the audio source from the beginning.
            </summary>
        </member>
        <member name="P:Robust.Shared.Audio.Sources.IAudioSource.Playing">
            <summary>
            Is the audio source currently playing.
            </summary>
        </member>
        <member name="P:Robust.Shared.Audio.Sources.IAudioSource.Looping">
            <summary>
            Will the audio source loop when finished playing?
            </summary>
        </member>
        <member name="P:Robust.Shared.Audio.Sources.IAudioSource.Global">
            <summary>
            Is the audio source relative to the listener or to the world (global or local).
            </summary>
        </member>
        <member name="P:Robust.Shared.Audio.Sources.IAudioSource.Position">
            <summary>
            Position of the audio relative to listener.
            </summary>
        </member>
        <member name="P:Robust.Shared.Audio.Sources.IAudioSource.Volume">
            <summary>
            Decibels of the audio. Converted to gain when setting.
            </summary>
        </member>
        <member name="P:Robust.Shared.Audio.Sources.IAudioSource.Gain">
            <summary>
            Direct gain for audio.
            </summary>
        </member>
        <member name="P:Robust.Shared.Audio.Sources.IAudioSource.PlaybackPosition">
            <summary>
            Current playback position.
            </summary>
        </member>
        <member name="P:Robust.Shared.Audio.Sources.IAudioSource.Velocity">
            <summary>
            Audio source velocity. Used for the doppler effect.
            </summary>
        </member>
        <member name="M:Robust.Shared.Audio.Sources.IAudioSource.SetAuxiliary(Robust.Shared.Audio.Effects.IAuxiliaryAudio)">
            <summary>
            Set the auxiliary sendfilter for this audio source.
            </summary>
        </member>
        <member name="T:Robust.Shared.Audio.Systems.SharedAudioSystem">
            <summary>
            Handles audio for robust toolbox inside of the sim.
            </summary>
            <remarks>
            Interacts with AudioManager internally.
            </remarks>
        </member>
        <member name="F:Robust.Shared.Audio.Systems.SharedAudioSystem.DefaultSoundRange">
            <summary>
            Default max range at which the sound can be heard.
            </summary>
        </member>
        <member name="P:Robust.Shared.Audio.Systems.SharedAudioSystem.OcclusionCollisionMask">
            <summary>
            Used in the PAS to designate the physics collision mask of occluders.
            </summary>
        </member>
        <member name="M:Robust.Shared.Audio.Systems.SharedAudioSystem.SetPlaybackPosition(System.Nullable{Robust.Shared.GameObjects.Entity{Robust.Shared.Audio.Components.AudioComponent}},System.Single)">
            <summary>
            Sets the playback position of audio to the specified spot.
            </summary>
        </member>
        <member name="M:Robust.Shared.Audio.Systems.SharedAudioSystem.GetPlaybackPosition(Robust.Shared.Audio.Components.AudioComponent)">
            <summary>
            Calculates playback position considering length paused.
            </summary>
            <param name="component"></param>
            <returns></returns>
        </member>
        <member name="M:Robust.Shared.Audio.Systems.SharedAudioSystem.SetMapAudio(System.Nullable{Robust.Shared.GameObjects.Entity{Robust.Shared.Audio.Components.AudioComponent}})">
            <summary>
            Marks this audio as being map-based.
            </summary>
        </member>
        <member name="M:Robust.Shared.Audio.Systems.SharedAudioSystem.SetState(System.Nullable{Robust.Shared.GameObjects.EntityUid},Robust.Shared.Audio.Components.AudioState,System.Boolean,Robust.Shared.Audio.Components.AudioComponent)">
            <summary>
            Sets the shared state for an audio entity.
            </summary>
        </member>
        <member name="M:Robust.Shared.Audio.Systems.SharedAudioSystem.GetAudioDistance(System.Single)">
            <summary>
            Considers Z-offset for audio and gets the adjusted distance.
            </summary>
            <remarks>
            Really it's just doing pythagoras for you.
            </remarks>
        </member>
        <member name="M:Robust.Shared.Audio.Systems.SharedAudioSystem.GetSound(Robust.Shared.Audio.SoundSpecifier)">
            <summary>
            Resolves the filepath to a sound file.
            </summary>
        </member>
        <member name="M:Robust.Shared.Audio.Systems.SharedAudioSystem.SetGain(System.Nullable{Robust.Shared.GameObjects.EntityUid},System.Single,Robust.Shared.Audio.Components.AudioComponent)">
            <summary>
            Sets the audio params volume for an entity.
            </summary>
        </member>
        <member name="M:Robust.Shared.Audio.Systems.SharedAudioSystem.SetVolume(System.Nullable{Robust.Shared.GameObjects.EntityUid},System.Single,Robust.Shared.Audio.Components.AudioComponent)">
            <summary>
            Sets the audio params volume for an entity.
            </summary>
        </member>
        <member name="M:Robust.Shared.Audio.Systems.SharedAudioSystem.GetAudioLength(System.String)">
            <summary>
            Gets the timespan of the specified audio.
            </summary>
        </member>
        <member name="M:Robust.Shared.Audio.Systems.SharedAudioSystem.Stop(System.Nullable{Robust.Shared.GameObjects.EntityUid},Robust.Shared.Audio.Components.AudioComponent)">
            <summary>
            Stops the specified audio entity from playing.
            </summary>
            <remarks>
            Returns null so you can inline the call.
            </remarks>
        </member>
        <member name="M:Robust.Shared.Audio.Systems.SharedAudioSystem.PlayGlobal(System.String,Robust.Shared.Player.Filter,System.Boolean,System.Nullable{Robust.Shared.Audio.AudioParams})">
            <summary>
            Play an audio file globally, without position.
            </summary>
            <param name="filename">The resource path to the OGG Vorbis file to play.</param>
            <param name="playerFilter">The set of players that will hear the sound.</param>
        </member>
        <member name="M:Robust.Shared.Audio.Systems.SharedAudioSystem.PlayGlobal(Robust.Shared.Audio.SoundSpecifier,Robust.Shared.Player.Filter,System.Boolean,System.Nullable{Robust.Shared.Audio.AudioParams})">
            <summary>
            Play an audio file globally, without position.
            </summary>
            <param name="sound">The sound specifier that points the audio file(s) that should be played.</param>
            <param name="playerFilter">The set of players that will hear the sound.</param>
        </member>
        <member name="M:Robust.Shared.Audio.Systems.SharedAudioSystem.PlayGlobal(System.String,Robust.Shared.Player.ICommonSession,System.Nullable{Robust.Shared.Audio.AudioParams})">
            <summary>
            Play an audio file globally, without position.
            </summary>
            <param name="filename">The resource path to the OGG Vorbis file to play.</param>
            <param name="recipient">The player that will hear the sound.</param>
        </member>
        <member name="M:Robust.Shared.Audio.Systems.SharedAudioSystem.PlayGlobal(Robust.Shared.Audio.SoundSpecifier,Robust.Shared.Player.ICommonSession)">
            <summary>
            Play an audio file globally, without position.
            </summary>
            <param name="sound">The sound specifier that points the audio file(s) that should be played.</param>
            <param name="recipient">The player that will hear the sound.</param>
        </member>
        <member name="M:Robust.Shared.Audio.Systems.SharedAudioSystem.PlayGlobal(System.String,Robust.Shared.GameObjects.EntityUid,System.Nullable{Robust.Shared.Audio.AudioParams})">
            <summary>
            Play an audio file globally, without position.
            </summary>
            <param name="filename">The resource path to the OGG Vorbis file to play.</param>
            <param name="recipient">The player that will hear the sound.</param>
        </member>
        <member name="M:Robust.Shared.Audio.Systems.SharedAudioSystem.PlayGlobal(Robust.Shared.Audio.SoundSpecifier,Robust.Shared.GameObjects.EntityUid,System.Nullable{Robust.Shared.Audio.AudioParams})">
            <summary>
            Play an audio file globally, without position.
            </summary>
            <param name="sound">The sound specifier that points the audio file(s) that should be played.</param>
            <param name="recipient">The player that will hear the sound.</param>
        </member>
        <member name="M:Robust.Shared.Audio.Systems.SharedAudioSystem.PlayEntity(System.String,Robust.Shared.Player.Filter,Robust.Shared.GameObjects.EntityUid,System.Boolean,System.Nullable{Robust.Shared.Audio.AudioParams})">
            <summary>
            Play an audio file following an entity.
            </summary>
            <param name="filename">The resource path to the OGG Vorbis file to play.</param>
            <param name="playerFilter">The set of players that will hear the sound.</param>
            <param name="uid">The UID of the entity "emitting" the audio.</param>
        </member>
        <member name="M:Robust.Shared.Audio.Systems.SharedAudioSystem.PlayEntity(System.String,Robust.Shared.Player.ICommonSession,Robust.Shared.GameObjects.EntityUid,System.Nullable{Robust.Shared.Audio.AudioParams})">
            <summary>
            Play an audio file following an entity.
            </summary>
            <param name="filename">The resource path to the OGG Vorbis file to play.</param>
            <param name="recipient">The player that will hear the sound.</param>
            <param name="uid">The UID of the entity "emitting" the audio.</param>
        </member>
        <member name="M:Robust.Shared.Audio.Systems.SharedAudioSystem.PlayEntity(System.String,Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.EntityUid,System.Nullable{Robust.Shared.Audio.AudioParams})">
            <summary>
            Play an audio file following an entity.
            </summary>
            <param name="filename">The resource path to the OGG Vorbis file to play.</param>
            <param name="recipient">The player that will hear the sound.</param>
            <param name="uid">The UID of the entity "emitting" the audio.</param>
        </member>
        <member name="M:Robust.Shared.Audio.Systems.SharedAudioSystem.PlayEntity(Robust.Shared.Audio.SoundSpecifier,Robust.Shared.Player.Filter,Robust.Shared.GameObjects.EntityUid,System.Boolean,System.Nullable{Robust.Shared.Audio.AudioParams})">
            <summary>
            Play an audio file following an entity.
            </summary>
            <param name="sound">The sound specifier that points the audio file(s) that should be played.</param>
            <param name="playerFilter">The set of players that will hear the sound.</param>
            <param name="uid">The UID of the entity "emitting" the audio.</param>
        </member>
        <member name="M:Robust.Shared.Audio.Systems.SharedAudioSystem.PlayEntity(Robust.Shared.Audio.SoundSpecifier,Robust.Shared.Player.ICommonSession,Robust.Shared.GameObjects.EntityUid,System.Nullable{Robust.Shared.Audio.AudioParams})">
            <summary>
            Play an audio file following an entity.
            </summary>
            <param name="sound">The sound specifier that points the audio file(s) that should be played.</param>
            <param name="recipient">The player that will hear the sound.</param>
            <param name="uid">The UID of the entity "emitting" the audio.</param>
        </member>
        <member name="M:Robust.Shared.Audio.Systems.SharedAudioSystem.PlayEntity(Robust.Shared.Audio.SoundSpecifier,Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.EntityUid,System.Nullable{Robust.Shared.Audio.AudioParams})">
            <summary>
            Play an audio file following an entity.
            </summary>
            <param name="sound">The sound specifier that points the audio file(s) that should be played.</param>
            <param name="recipient">The player that will hear the sound.</param>
            <param name="uid">The UID of the entity "emitting" the audio.</param>
        </member>
        <member name="M:Robust.Shared.Audio.Systems.SharedAudioSystem.PlayPvs(Robust.Shared.Audio.SoundSpecifier,Robust.Shared.GameObjects.EntityUid,System.Nullable{Robust.Shared.Audio.AudioParams})">
            <summary>
            Play an audio file following an entity for every entity in PVS range.
            </summary>
            <param name="sound">The sound specifier that points the audio file(s) that should be played.</param>
            <param name="uid">The UID of the entity "emitting" the audio.</param>
        </member>
        <member name="M:Robust.Shared.Audio.Systems.SharedAudioSystem.PlayPvs(Robust.Shared.Audio.SoundSpecifier,Robust.Shared.Map.EntityCoordinates,System.Nullable{Robust.Shared.Audio.AudioParams})">
            <summary>
            Play an audio file at the specified EntityCoordinates for every entity in PVS range.
            </summary>
            <param name="sound">The sound specifier that points the audio file(s) that should be played.</param>
            <param name="coordinates">The EntityCoordinates to attach the audio source to.</param>
        </member>
        <member name="M:Robust.Shared.Audio.Systems.SharedAudioSystem.PlayPvs(System.String,Robust.Shared.Map.EntityCoordinates,System.Nullable{Robust.Shared.Audio.AudioParams})">
            <summary>
            Play an audio file at the specified EntityCoordinates for every entity in PVS range.
            </summary>
            <param name="sound">The sound specifier that points the audio file(s) that should be played.</param>
            <param name="coordinates">The EntityCoordinates to attach the audio source to.</param>
        </member>
        <member name="M:Robust.Shared.Audio.Systems.SharedAudioSystem.PlayPvs(System.String,Robust.Shared.GameObjects.EntityUid,System.Nullable{Robust.Shared.Audio.AudioParams})">
            <summary>
            Play an audio file following an entity for every entity in PVS range.
            </summary>
            <param name="filename">The resource path to the OGG Vorbis file to play.</param>
            <param name="uid">The UID of the entity "emitting" the audio.</param>
        </member>
        <member name="M:Robust.Shared.Audio.Systems.SharedAudioSystem.PlayPredicted(Robust.Shared.Audio.SoundSpecifier,Robust.Shared.GameObjects.EntityUid,System.Nullable{Robust.Shared.GameObjects.EntityUid},System.Nullable{Robust.Shared.Audio.AudioParams})">
            <summary>
            Plays a predicted sound following an entity. The server will send the sound to every player in PVS range,
            unless that player is attached to the "user" entity that initiated the sound. The client-side system plays
            this sound as normal
            </summary>
            <param name="sound">The sound specifier that points the audio file(s) that should be played.</param>
            <param name="source">The UID of the entity "emitting" the audio.</param>
            <param name="user">The UID of the user that initiated this sound. This is usually some player's controlled entity.</param>
        </member>
        <member name="M:Robust.Shared.Audio.Systems.SharedAudioSystem.PlayPredicted(Robust.Shared.Audio.SoundSpecifier,Robust.Shared.Map.EntityCoordinates,System.Nullable{Robust.Shared.GameObjects.EntityUid},System.Nullable{Robust.Shared.Audio.AudioParams})">
            <summary>
            Plays a predicted sound following an EntityCoordinates. The server will send the sound to every player in PVS range,
            unless that player is attached to the "user" entity that initiated the sound. The client-side system plays
            this sound as normal
            </summary>
            <param name="sound">The sound specifier that points the audio file(s) that should be played.</param>
            <param name="coordinates">The entitycoordinates "emitting" the audio</param>
            <param name="user">The UID of the user that initiated this sound. This is usually some player's controlled entity.</param>
        </member>
        <member name="M:Robust.Shared.Audio.Systems.SharedAudioSystem.PlayStatic(System.String,Robust.Shared.Player.Filter,Robust.Shared.Map.EntityCoordinates,System.Boolean,System.Nullable{Robust.Shared.Audio.AudioParams})">
            <summary>
            Play an audio file at a static position.
            </summary>
            <param name="filename">The resource path to the OGG Vorbis file to play.</param>
            <param name="playerFilter">The set of players that will hear the sound.</param>
            <param name="coordinates">The coordinates at which to play the audio.</param>
        </member>
        <member name="M:Robust.Shared.Audio.Systems.SharedAudioSystem.PlayStatic(System.String,Robust.Shared.Player.ICommonSession,Robust.Shared.Map.EntityCoordinates,System.Nullable{Robust.Shared.Audio.AudioParams})">
            <summary>
            Play an audio file at a static position.
            </summary>
            <param name="filename">The resource path to the OGG Vorbis file to play.</param>
            <param name="recipient">The player that will hear the sound.</param>
            <param name="coordinates">The coordinates at which to play the audio.</param>
        </member>
        <member name="M:Robust.Shared.Audio.Systems.SharedAudioSystem.PlayStatic(System.String,Robust.Shared.GameObjects.EntityUid,Robust.Shared.Map.EntityCoordinates,System.Nullable{Robust.Shared.Audio.AudioParams})">
            <summary>
            Play an audio file at a static position.
            </summary>
            <param name="filename">The resource path to the OGG Vorbis file to play.</param>
            <param name="recipient">The player that will hear the sound.</param>
            <param name="coordinates">The coordinates at which to play the audio.</param>
        </member>
        <member name="M:Robust.Shared.Audio.Systems.SharedAudioSystem.PlayStatic(Robust.Shared.Audio.SoundSpecifier,Robust.Shared.Player.Filter,Robust.Shared.Map.EntityCoordinates,System.Boolean,System.Nullable{Robust.Shared.Audio.AudioParams})">
            <summary>
            Play an audio file at a static position.
            </summary>
            <param name="sound">The sound specifier that points the audio file(s) that should be played.</param>
            <param name="playerFilter">The set of players that will hear the sound.</param>
            <param name="coordinates">The coordinates at which to play the audio.</param>
        </member>
        <member name="M:Robust.Shared.Audio.Systems.SharedAudioSystem.PlayStatic(Robust.Shared.Audio.SoundSpecifier,Robust.Shared.Player.ICommonSession,Robust.Shared.Map.EntityCoordinates,System.Nullable{Robust.Shared.Audio.AudioParams})">
            <summary>
            Play an audio file at a static position.
            </summary>
            <param name="sound">The sound specifier that points the audio file(s) that should be played.</param>
            <param name="recipient">The player that will hear the sound.</param>
            <param name="coordinates">The coordinates at which to play the audio.</param>
        </member>
        <member name="M:Robust.Shared.Audio.Systems.SharedAudioSystem.PlayStatic(Robust.Shared.Audio.SoundSpecifier,Robust.Shared.GameObjects.EntityUid,Robust.Shared.Map.EntityCoordinates,System.Nullable{Robust.Shared.Audio.AudioParams})">
            <summary>
            Play an audio file at a static position.
            </summary>
            <param name="sound">The sound specifier that points the audio file(s) that should be played.</param>
            <param name="recipient">The player that will hear the sound.</param>
            <param name="coordinates">The coordinates at which to play the audio.</param>
        </member>
        <member name="P:Robust.Shared.Audio.Systems.SharedAudioSystem.Auxiliaries">
            <summary>
            Pre-calculated auxiliary effect slots for audio presets.
            </summary>
        </member>
        <member name="M:Robust.Shared.Audio.Systems.SharedAudioSystem.CreateAuxiliary">
            <summary>
            Creates an auxiliary audio slot that can have an audio source or audio effect applied to it.
            </summary>
        </member>
        <member name="M:Robust.Shared.Audio.Systems.SharedAudioSystem.CreateEffect">
            <summary>
            Creates an audio effect that can be used with an auxiliary audio slot.
            </summary>
        </member>
        <member name="M:Robust.Shared.Audio.Systems.SharedAudioSystem.SetAuxiliary(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Audio.Components.AudioComponent,System.Nullable{Robust.Shared.GameObjects.EntityUid})">
            <summary>
            Sets the auxiliary effect slot for a specified audio source.
            </summary>
        </member>
        <member name="M:Robust.Shared.Audio.Systems.SharedAudioSystem.SetEffect(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Audio.Components.AudioAuxiliaryComponent,System.Nullable{Robust.Shared.GameObjects.EntityUid})">
            <summary>
            Sets the audio effect for a specified auxiliary effect slot.
            </summary>
        </member>
        <member name="M:Robust.Shared.Audio.Systems.SharedAudioSystem.SetEffectPreset(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Audio.Components.AudioEffectComponent,Robust.Shared.Audio.AudioPresetPrototype)">
            <summary>
            Applies an audio preset prototype to an audio effect entity.
            </summary>
        </member>
        <member name="M:Robust.Shared.Audio.Systems.SharedAudioSystem.SetEffectPreset(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Audio.Components.AudioEffectComponent,Robust.Shared.Audio.Effects.ReverbProperties)">
            <summary>
            Applies an EAX reverb effect preset to an audio effect.
            </summary>
        </member>
        <member name="T:Robust.Shared.Collections.InvokeList`1">
            <summary>
            Alternative to multi-cast delegates that has separate equality keys.
            </summary>
            <typeparam name="T">The type of delegate to store.</typeparam>
            <remarks>
            While this type is immutable (via copies), creating a copy (via add or remove) is not currently thread safe.
            This is in contrast to multi-cast delegate.
            </remarks>
        </member>
        <member name="M:Robust.Shared.Collections.InvokeList`1.AddInPlace(`0,System.Object)">
            <summary>
            Add an entry to the current invoke list, mutating it.
            </summary>
            <param name="value">Actual value to store.</param>
            <param name="equality">Equality comparison key.</param>
        </member>
        <member name="M:Robust.Shared.Collections.InvokeList`1.Add(`0,System.Object)">
            <summary>
            Add an entry to the invoke list, returning a new instance. The original list is not modified.
            </summary>
            <param name="value">Actual value to store.</param>
            <param name="equality">Equality comparison key.</param>
        </member>
        <member name="M:Robust.Shared.Collections.InvokeList`1.RemoveInPlace(System.Object)">
            <summary>
            Remove an entry from the current invoke list, mutating it.
            </summary>
            <param name="equality">Equality comparison key.</param>
        </member>
        <member name="M:Robust.Shared.Collections.InvokeList`1.Remove(System.Object)">
            <summary>
            Remove an entry from the invoke list, returning a new instance. The original list is not modified.
            </summary>
            <param name="equality">Equality comparison key.</param>
        </member>
        <member name="T:Robust.Shared.Collections.OverflowDictionary`2">
            <summary>
            A dictionary with a maximum capacity which will override the oldest inserted value when a new value is inserted.
            </summary>
            <typeparam name="TKey">The type of keys in the dictionary.</typeparam>
            <typeparam name="TValue">The type of values in the dictionary.</typeparam>
        </member>
        <member name="P:Robust.Shared.Collections.OverflowDictionary`2.Capacity">
            <summary>
            The maximum capacity of the dictionary.
            </summary>
        </member>
        <member name="F:Robust.Shared.Collections.OverflowDictionary`2._valueDisposer">
            <summary>
            A function used to dispose of values overwritten by the overflow functionality.
            </summary>
        </member>
        <member name="M:Robust.Shared.Collections.OverflowDictionary`2.#ctor(System.Int32,System.Action{`1})">
            <param name="capacity">The maximum capacity of the dictionary.</param>
            <param name="valueDisposer">A function used to dispose of values overwritten by the overflow functionality.</param>
            <exception cref="T:System.InvalidOperationException">Thrown in the <paramref name="capacity"/> is less than 1.</exception>
        </member>
        <member name="M:Robust.Shared.Collections.OverflowDictionary`2.Add(`0,`1,System.Nullable{System.ValueTuple{`0,`1}}@)">
            <summary>
                Variant of <see cref="M:Robust.Shared.Collections.OverflowDictionary`2.Add(`0,`1)"/> that also returns any entry that was removed to make room for the new entry.
            </summary>
        </member>
        <member name="T:Robust.Shared.Collections.OverflowQueue`1">
            <summary>
            A fixed-size queue that discards the oldest entry if a new entry is enqueued when the queue is full.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Robust.Shared.Collections.OverflowQueue`1.Size">
            <summary>
            The size of the queue-buffer.
            </summary>
        </member>
        <member name="M:Robust.Shared.Collections.OverflowQueue`1.#ctor(System.Int32)">
            <param name="size">size of the queue-buffer</param>
        </member>
        <member name="M:Robust.Shared.Collections.OverflowQueue`1.Enqueue(`0)">
            <summary>
            Enqueues the <paramref name="item"/>. Overrides the oldest item if the queue is full.
            </summary>
            <param name="item">The item to enqueue</param>
        </member>
        <member name="M:Robust.Shared.Collections.OverflowQueue`1.Dequeue">
            <summary>
            Removes the item at the head of the queue and returns it. If the queue is empty, this method throws an InvalidOperationException.
            </summary>
            <returns>The dequeued item.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the queue is empty.</exception>
        </member>
        <member name="M:Robust.Shared.Collections.OverflowQueue`1.TryDequeue(`0@)">
            <summary>
            Tries to dequeue an item.
            </summary>
            <param name="item">The item which got dequeued. Null if the queue was empty</param>
            <returns>True if an item was dequeued, false if not.</returns>
        </member>
        <member name="M:Robust.Shared.Collections.OverflowQueue`1.Peek">
            <summary>
            Returns the item at the head of the queue. The object remains in the queue. If the queue is empty, this method throws an InvalidOperationException.
            </summary>
            <returns>The item at the head of the queue.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the queue is empty.</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Robust.Shared.Collections.OverflowQueue`1.Contains(`0)" -->
        <member name="M:Robust.Shared.Collections.OverflowQueue`1.ToArray">
            <summary>
            Returns the queue contents first to last as an array.
            </summary>
            <returns>The array containing the queue contents.</returns>
        </member>
        <member name="T:Robust.Shared.Collections.RingBufferList`1">
            <summary>
            Datastructure that acts like a <see cref="T:System.Collections.Generic.List`1"/>, but is actually stored as a ring buffer internally.
            This facilitates efficient removal from the start.
            </summary>
            <typeparam name="T">Type of item contained in the collection.</typeparam>
        </member>
        <member name="T:Robust.Shared.Collections.ValueList`1">
            <summary>
            Implementation of <see cref="T:System.Collections.Generic.List`1"/> that is stored in a struct instead.
            </summary>
            <remarks>
            <para>
            Storing this implementation in a struct reduces GC and memory overhead from list instances drastically.
            It is only recommended you use this class for private data;
            public APIs probably shouldn't expose it unless you know what you're doing.
            </para>
            <para>
            This implementation does not complain if you modify it during iteration. Be careful!
            </para>
            <para>
            The implementation uses an array to store the contained items.
            This array may be larger (<see cref="P:Robust.Shared.Collections.ValueList`1.Capacity"/>) than the amount of "actual" items stored (<see cref="P:Robust.Shared.Collections.ValueList`1.Count"/>).
            Adding or removing elements to the list shrinks or grows the available capacity at the end of the array.
            If there is no remaining capacity left when inserting,
            a new, larger, array is allocated and elements are copied over.
            </para>
            </remarks>
            <typeparam name="T">The type of item to store in the list.</typeparam>
        </member>
        <member name="M:Robust.Shared.Collections.ValueList`1.#ctor(System.Collections.Generic.List{`0})">
            <summary>
            Creates a list by copying the contents of the source list.
            </summary>
        </member>
        <member name="M:Robust.Shared.Collections.ValueList`1.#ctor(System.Collections.Generic.List{`0},System.Int32,System.Int32)">
            <summary>
            Creates a list by copying the contents of the source list.
            </summary>
        </member>
        <member name="M:Robust.Shared.Collections.ValueList`1.#ctor(System.Collections.Generic.IReadOnlyCollection{`0})">
            <summary>
            Creates a list by copying the contents of the source list.
            </summary>
        </member>
        <member name="M:Robust.Shared.Collections.ValueList`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Create a list by copying the contents from another enumerable.
            </summary>
            <param name="collection">The enumerable to copy the items from.</param>
        </member>
        <member name="M:Robust.Shared.Collections.ValueList`1.OwningArray(`0[])">
            <summary>
            Create a list by taking ownership of an existing array.
            Mutations of the list may mutate the passed array.
            The count and capacity of the list are both set equal to the array length.
            </summary>
            <remarks>
            If null is passed, it is treated equivalently to an empty array.
            </remarks>
        </member>
        <member name="M:Robust.Shared.Collections.ValueList`1.OwningArray(`0[],System.Int32)">
            <summary>
            Create a list by taking ownership of an existing array.
            Mutations of the list may mutate the passed array.
            The capacity is set to the length of the list.
            The count can be set separately if the array has more space than valid items.
            </summary>
            <remarks>
            If null is passed, it is treated equivalently to an empty array.
            </remarks>
            <exception cref="T:System.ArgumentException">
            Thrown if count is negative or if count is greater than the array capacity.
            </exception>
        </member>
        <member name="P:Robust.Shared.Collections.ValueList`1.Span">
            <summary>
            Span containing the items inside the list.
            Note that resizing of the backing array will cause this span to be invalidated.
            </summary>
        </member>
        <member name="M:Robust.Shared.Collections.ValueList`1.EnsureCapacity(System.Int32)">
            <summary>
            Ensures that the capacity of this list is at least the specified <paramref name="capacity"/>.
            If the current capacity of the list is less than specified <paramref name="capacity"/>,
            the capacity is increased by continuously twice current capacity until it is at least the specified <paramref name="capacity"/>.
            </summary>
            <param name="capacity">The minimum capacity to ensure.</param>
            <returns>The new capacity of this list.</returns>
        </member>
        <member name="M:Robust.Shared.Collections.ValueList`1.Grow(System.Int32)">
            <summary>
            Increase the capacity of this list to at least the specified <paramref name="capacity"/>.
            </summary>
            <param name="capacity">The minimum capacity to ensure.</param>
        </member>
        <member name="M:Robust.Shared.Collections.ValueList`1.RemoveSwap(System.Int32)">
            <summary>
            <see cref="T:System.Collections.Generic.CollectionExtensions"/>
            </summary>
        </member>
        <member name="M:Robust.Shared.Collections.ValueList`1.AddRange(Robust.Shared.Collections.ValueList{`0})">
            <summary>
            Adds a range of values from the source list.
            </summary>
        </member>
        <member name="M:Robust.Shared.Collections.ValueList`1.AddRange(System.Collections.Generic.List{`0})">
            <summary>
            Adds a range of values from the source list.
            </summary>
        </member>
        <member name="M:Robust.Shared.Collections.ValueList`1.EnsureLength(System.Int32)">
            <summary>
            Fills this with default data up to the specified count.
            </summary>
        </member>
        <member name="T:Robust.Shared.ComponentTrees.ComponentTreeSystem`2">
            <summary>
                Keeps track of <see cref="T:Robust.Shared.Physics.DynamicTree`1"/>s for various rendering-related components.
            </summary>
        </member>
        <member name="P:Robust.Shared.ComponentTrees.ComponentTreeSystem`2.DoFrameUpdate">
            <summary>
                If true, this system will update the tree positions every frame update. See also <see cref="P:Robust.Shared.ComponentTrees.ComponentTreeSystem`2.DoTickUpdate"/>. Some systems may need to do both.
            </summary>
        </member>
        <member name="P:Robust.Shared.ComponentTrees.ComponentTreeSystem`2.DoTickUpdate">
            <summary>
                If true, this system will update the tree positions every tick update. See also <see cref="P:Robust.Shared.ComponentTrees.ComponentTreeSystem`2.DoFrameUpdate"/>. Some systems may need to do both.
            </summary>
        </member>
        <member name="P:Robust.Shared.ComponentTrees.ComponentTreeSystem`2.InitialCapacity">
            <summary>
                Initial tree capacity. Note that client-side trees will remove entities as they leave PVS range.
            </summary>
        </member>
        <member name="P:Robust.Shared.ComponentTrees.ComponentTreeSystem`2.Recursive">
            <summary>
                If true, this tree requires all children to be recursively updated whenever ANY entity moves. If false, this
                will only update when an entity with the given component moves.
            </summary>
        </member>
        <member name="M:Robust.Shared.ComponentTrees.ComponentTreeSystem`2.UpdateTreePositions">
            <summary>
                Processes any pending position updates. Note that this should generally always get run before directly
                querying a tree.
            </summary>
        </member>
        <member name="T:Robust.Shared.ComponentTrees.IComponentTreeEntry`1">
            <summary>
                Interface that must be implemented by components that can be stored on component trees.
            </summary>
        </member>
        <member name="P:Robust.Shared.ComponentTrees.IComponentTreeEntry`1.TreeUid">
            <summary>
                The tree that the component is currently stored on.
            </summary>
        </member>
        <member name="P:Robust.Shared.ComponentTrees.IComponentTreeEntry`1.Tree">
            <summary>
                The tree that the component is currently stored on.
            </summary>
        </member>
        <member name="P:Robust.Shared.ComponentTrees.IComponentTreeEntry`1.AddToTree">
            <summary>
                Whether or not the component should currently be added to a tree.
            </summary>
        </member>
        <member name="T:Robust.Shared.ComponentTrees.RecursiveMoveSystem">
            <summary>
                This system will recursively raise events to update component tree positions any time any entity moves.
            </summary>
            <remarks>
                This is used by some client-side systems (e.g., sprites, lights, etc). However this can be quite expensive and if possible should not be used by the server.
            </remarks>
        </member>
        <member name="T:Robust.Shared.Configuration.ConfigurationManager">
            <summary>
                Stores and manages global configuration variables.
            </summary>
        </member>
        <member name="M:Robust.Shared.Configuration.ConfigurationManager.#ctor">
            <summary>
                Constructs a new ConfigurationManager.
            </summary>
        </member>
        <member name="M:Robust.Shared.Configuration.ConfigurationManager.LoadFromTomlStream(System.IO.Stream)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Configuration.ConfigurationManager.LoadFromFile(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Configuration.ConfigurationManager.SaveToTomlStream(System.IO.Stream,System.Collections.Generic.IEnumerable{System.String})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Configuration.ConfigurationManager.SaveToFile">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Configuration.ConfigurationManager.IsCVarRegistered(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Configuration.ConfigurationManager.GetRegisteredCVars">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Configuration.ConfigurationManager.SetCVar(System.String,System.Object,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Configuration.ConfigurationManager.GetCVar``1(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Configuration.ConfigurationManager.TypeConvert(Nett.TomlObject)">
            <summary>
                Converts a TomlObject into its native type.
            </summary>
            <param name="obj">The object to convert.</param>
            <returns>The boxed native type of the TomlObject.</returns>
        </member>
        <member name="M:Robust.Shared.Configuration.ConfigurationManager.ConvertToCVarType(System.Object,System.Type)">
            <summary>
            Try to convert a compatible value to the actual registration type of a CVar.
            </summary>
            <remarks>
            When CVars are parsed from TOML, their in-code type is not known.
            This function does the necessary conversions from e.g. int to long.
            </remarks>
            <param name="value">
            The value to convert.
            This must be a simple type like strings or integers.
            </param>
            <param name="cVar">
            The registration type of the CVar.
            </param>
            <returns></returns>
        </member>
        <member name="T:Robust.Shared.Configuration.ConfigurationManager.ConfigVar">
            <summary>
                Holds the data for a single configuration variable.
            </summary>
        </member>
        <member name="M:Robust.Shared.Configuration.ConfigurationManager.ConfigVar.#ctor(System.String,System.Object,Robust.Shared.Configuration.CVar)">
            <summary>
                Constructs a CVar.
            </summary>
            <param name="name">The name of the CVar. This needs to contain only printable characters.
            Underscores '_' are reserved. Everything before the last underscore is a table identifier,
            everything after is the CVar name in the TOML document.</param>
            <param name="defaultValue">The default value of this CVar.</param>
            <param name="flags">Optional flags to modify the behavior of this CVar.</param>
        </member>
        <member name="P:Robust.Shared.Configuration.ConfigurationManager.ConfigVar.Type">
            <summary>
                The type of the cvar's value. This may be null until the cvar is registered.
            </summary>
        </member>
        <member name="P:Robust.Shared.Configuration.ConfigurationManager.ConfigVar.Name">
            <summary>
                The name of the CVar.
            </summary>
        </member>
        <member name="P:Robust.Shared.Configuration.ConfigurationManager.ConfigVar.DefaultValue">
            <summary>
                The default value of this CVar.
            </summary>
        </member>
        <member name="P:Robust.Shared.Configuration.ConfigurationManager.ConfigVar.Flags">
            <summary>
                Optional flags to modify the behavior of this CVar.
            </summary>
        </member>
        <member name="P:Robust.Shared.Configuration.ConfigurationManager.ConfigVar.Value">
            <summary>
                The current value of this CVar.
            </summary>
        </member>
        <member name="P:Robust.Shared.Configuration.ConfigurationManager.ConfigVar.Registered">
            <summary>
                Has this CVar been registered in code?
            </summary>
        </member>
        <member name="F:Robust.Shared.Configuration.ConfigurationManager.ConfigVar.ConfigModified">
            <summary>
                Was the CVar present in the config file?
                If so we need to always re-save it even if it's not ARCHIVE.
            </summary>
        </member>
        <member name="T:Robust.Shared.Configuration.ConfigurationManager.ValueChangedInvoke">
            <summary>
            All data we need to invoke a deferred ValueChanged handler outside of a write lock.
            </summary>
        </member>
        <member name="T:Robust.Shared.Configuration.CVar">
            <summary>
            Extra flags for changing the behavior of a config var.
            </summary>
        </member>
        <member name="F:Robust.Shared.Configuration.CVar.NONE">
            <summary>
            No special flags.
            </summary>
        </member>
        <member name="F:Robust.Shared.Configuration.CVar.CHEAT">
            <summary>
            Debug vars that are considered 'cheating' to change.
            </summary>
        </member>
        <member name="F:Robust.Shared.Configuration.CVar.SERVER">
            <summary>
            Only the server can change this variable.
            </summary>
        </member>
        <member name="F:Robust.Shared.Configuration.CVar.NOT_CONNECTED">
            <summary>
            This can only be changed when not connected to a server.
            </summary>
        </member>
        <member name="F:Robust.Shared.Configuration.CVar.REPLICATED">
            <summary>
            Changing this var syncs between clients and server.
            </summary>
        </member>
        <member name="F:Robust.Shared.Configuration.CVar.ARCHIVE">
            <summary>
            Non-default values are saved to the configuration file.
            </summary>
        </member>
        <member name="F:Robust.Shared.Configuration.CVar.NOTIFY">
            <summary>
            Changing this var on the server notifies all clients, does nothing client-side.
            </summary>
        </member>
        <member name="F:Robust.Shared.Configuration.CVar.SERVERONLY">
            <summary>
                Ignore registration of this cvar on the client.
            </summary>
            <remarks>
                This is intended to aid shared code.
            </remarks>
        </member>
        <member name="F:Robust.Shared.Configuration.CVar.CLIENTONLY">
            <summary>
                Ignore registration of this cvar on the server.
            </summary>
            <remarks>
                This is intended to aid shared code.
            </remarks>
        </member>
        <member name="F:Robust.Shared.Configuration.CVar.CONFIDENTIAL">
            <summary>
            CVar contains sensitive data that should not be accidentally leaked.
            </summary>
            <remarks>
            This currently hides the content of the cvar in the "cvar" command completions.
            </remarks>
        </member>
        <member name="F:Robust.Shared.Configuration.CVar.CLIENT">
            <summary>
            Only the client can change this variable.
            </summary>
        </member>
        <member name="F:Robust.Shared.Configuration.EnvironmentVariables.ConfigVarEnvironmentVariable">
            <summary>
            The environment variable for configuring CVar overrides. The value
            of the variable should be passed as key-value equalities separated by
            semicolons.
            </summary>
        </member>
        <member name="M:Robust.Shared.Configuration.EnvironmentVariables.GetEnvironmentCVars">
            <summary>
            Get the CVar overrides defined in the relevant environment variable.
            </summary>
        </member>
        <member name="T:Robust.Shared.Configuration.CVarChangeInfo">
            <summary>
            Additional information about a CVar change.
            </summary>
        </member>
        <member name="F:Robust.Shared.Configuration.CVarChangeInfo.Name">
            <summary>
            The name of the cvar that was changed.
            </summary>
        </member>
        <member name="F:Robust.Shared.Configuration.CVarChangeInfo.TickChanged">
            <summary>
            The tick this CVar changed at.
            </summary>
            <remarks>
            Nominally this should always be the current tick,
            however due to poor network conditions it is possible for CVars to get applied late.
            In this case, this is effectively "this is the tick it was SUPPOSED to have been applied at".
            </remarks>
        </member>
        <member name="F:Robust.Shared.Configuration.CVarChangeInfo.NewValue">
            <summary>
            The new value.
            </summary>
        </member>
        <member name="F:Robust.Shared.Configuration.CVarChangeInfo.OldValue">
            <summary>
            The previous value.
            </summary>
        </member>
        <member name="T:Robust.Shared.Configuration.IConfigurationManager">
            <summary>
            Stores and manages global configuration variables.
            </summary>
            <remarks>
            <para>
            Accessing (getting/setting) main CVars is thread safe.
            Note that value-changed callbacks are ran synchronously from the thread using <see cref="M:Robust.Shared.Configuration.IConfigurationManager.SetCVar(System.String,System.Object,System.Boolean)"/>,
            so it is not recommended to modify CVars from other threads.
            </para>
            </remarks>
        </member>
        <member name="M:Robust.Shared.Configuration.IConfigurationManager.SaveToFile">
            <summary>
            Saves the configuration file to disk.
            </summary>
        </member>
        <member name="M:Robust.Shared.Configuration.IConfigurationManager.SaveToTomlStream(System.IO.Stream,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Serializes a list of cvars to a toml.
            </summary>
        </member>
        <member name="M:Robust.Shared.Configuration.IConfigurationManager.LoadDefaultsFromTomlStream(System.IO.Stream)">
            <summary>
            Load a TOML config file and use the CVar values specified as an <see cref="M:Robust.Shared.Configuration.IConfigurationManager.OverrideDefault(System.String,System.Object)"/>.
            </summary>
            <remarks>
            All CVars in the TOML file must be registered when this function is called.
            </remarks>
            <returns>A set of all CVars touched.</returns>
        </member>
        <member name="M:Robust.Shared.Configuration.IConfigurationManager.RegisterCVar``1(System.String,``0,Robust.Shared.Configuration.CVar,System.Action{``0})">
            <summary>
            Register a CVar with the system. This must be done before the CVar is accessed.
            </summary>
            <param name="name">The name of the CVar. This needs to contain only printable characters.
            Periods '.' are reserved. Everything before the last period is a nested table identifier,
            everything after is the CVar name in the TOML document.</param>
            <param name="defaultValue">The default Value of the CVar.</param>
            <param name="flags">Optional flags to change behavior of the CVar.</param>
            <param name="onValueChanged">Invoked whenever the CVar value changes.</param>
        </member>
        <member name="M:Robust.Shared.Configuration.IConfigurationManager.IsCVarRegistered(System.String)">
            <summary>
            Is the named CVar already registered?
            </summary>
            <param name="name">The name of the CVar.</param>
            <returns></returns>
        </member>
        <member name="M:Robust.Shared.Configuration.IConfigurationManager.GetCVarFlags(System.String)">
            <summary>
            Get the CVar flags of a registered cvar.
            </summary>
        </member>
        <member name="M:Robust.Shared.Configuration.IConfigurationManager.GetRegisteredCVars">
            <summary>
            Gets a list of all registered cvars
            </summary>
            <returns></returns>
        </member>
        <member name="M:Robust.Shared.Configuration.IConfigurationManager.SetCVar(System.String,System.Object,System.Boolean)">
            <summary>
            Sets a CVars value.
            </summary>
            <param name="name">The name of the CVar.</param>
            <param name="value">The value to set.</param>
            <param name="force">If true, this will set the cvar even if it should not be settable (e.g., server
            authoritative cvars being set by clients).</param>
        </member>
        <member name="M:Robust.Shared.Configuration.IConfigurationManager.OverrideDefault(System.String,System.Object)">
            <summary>
            Change the default value for a CVar.
            This means the CVar value is changed *only* if it has not been changed by config file or <c>OverrideConVars</c>.
            </summary>
            <param name="name">The name of the CVar to change the default for.</param>
            <param name="value">The new default value of the CVar.</param>
        </member>
        <member name="M:Robust.Shared.Configuration.IConfigurationManager.OverrideDefault``1(Robust.Shared.Configuration.CVarDef{``0},``0)">
            <summary>
            Change the default value for a CVar.
            This means the CVar value is changed *only* if it has not been changed by config file or <c>OverrideConVars</c>.
            </summary>
            <param name="def">The definition of the CVar to change the default for.</param>
            <param name="value">The new default value of the CVar.</param>
        </member>
        <member name="M:Robust.Shared.Configuration.IConfigurationManager.GetCVar(System.String)">
            <summary>
            Get the value of a CVar.
            </summary>
            <param name="name">The name of the CVar.</param>
            <returns></returns>
        </member>
        <member name="M:Robust.Shared.Configuration.IConfigurationManager.GetCVar``1(System.String)">
            <summary>
            Get the value of a CVar.
            </summary>
            <typeparam name="T">The Type of the CVar value.</typeparam>
            <param name="name">The name of the CVar.</param>
            <returns></returns>
        </member>
        <member name="M:Robust.Shared.Configuration.IConfigurationManager.GetCVarType(System.String)">
            <summary>
                Gets the type of a value stored in a CVar.
            </summary>
            <param name="name">The name of the CVar</param>
        </member>
        <member name="M:Robust.Shared.Configuration.IConfigurationManager.OnValueChanged``1(Robust.Shared.Configuration.CVarDef{``0},System.Action{``0},System.Boolean)">
            <summary>
            Listen for an event for if the config value changes.
            </summary>
            <remarks>
            This is an O(n) operation.
            </remarks>
            <param name="cVar">The CVar to listen for.</param>
            <param name="onValueChanged">The delegate to run when the value was changed.</param>
            <param name="invokeImmediately">
            Whether to run the callback immediately in this method. Can help reduce boilerplate
            </param>
            <typeparam name="T">The type of value contained in this CVar.</typeparam>
            <seealso cref="M:Robust.Shared.Configuration.IConfigurationManager.UnsubValueChanged``1(Robust.Shared.Configuration.CVarDef{``0},System.Action{``0})"/>
        </member>
        <member name="M:Robust.Shared.Configuration.IConfigurationManager.OnValueChanged``1(System.String,System.Action{``0},System.Boolean)">
            <summary>
            Listen for an event for if the config value changes.
            </summary>
            <remarks>
            This is an O(n) operation.
            </remarks>
            <param name="name">The name of the CVar to listen for.</param>
            <param name="onValueChanged">The delegate to run when the value was changed.</param>
            <param name="invokeImmediately">
            Whether to run the callback immediately in this method. Can help reduce boilerplate
            </param>
            <typeparam name="T">The type of value contained in this CVar.</typeparam>
            <seealso cref="M:Robust.Shared.Configuration.IConfigurationManager.UnsubValueChanged``1(System.String,System.Action{``0})"/>
        </member>
        <member name="M:Robust.Shared.Configuration.IConfigurationManager.UnsubValueChanged``1(Robust.Shared.Configuration.CVarDef{``0},System.Action{``0})">
            <summary>
            Unsubscribe an event previously registered with <see cref="M:Robust.Shared.Configuration.IConfigurationManager.OnValueChanged``1(Robust.Shared.Configuration.CVarDef{``0},System.Action{``0},System.Boolean)"/>.
            </summary>
            <remarks>
            This is an O(n) operation.
            </remarks>
            <param name="cVar">The CVar to unsubscribe from.</param>
            <param name="onValueChanged">The delegate to unsubscribe.</param>
            <typeparam name="T">The type of value contained in this CVar.</typeparam>
        </member>
        <member name="M:Robust.Shared.Configuration.IConfigurationManager.UnsubValueChanged``1(System.String,System.Action{``0})">
            <summary>
            Unsubscribe an event previously registered with <see cref="M:Robust.Shared.Configuration.IConfigurationManager.OnValueChanged``1(System.String,System.Action{``0},System.Boolean)"/>.
            </summary>
            <remarks>
            This is an O(n) operation.
            </remarks>
            <param name="name">The name of the CVar to unsubscribe from.</param>
            <param name="onValueChanged">The delegate to unsubscribe.</param>
            <typeparam name="T">The type of value contained in this CVar.</typeparam>
        </member>
        <member name="M:Robust.Shared.Configuration.IConfigurationManager.OnValueChanged``1(Robust.Shared.Configuration.CVarDef{``0},Robust.Shared.Configuration.CVarChanged{``0},System.Boolean)">
            <summary>
            Listen for an event for if the config value changes.
            </summary>
            <remarks>
            This is an O(n) operation.
            </remarks>
            <param name="cVar">The CVar to listen for.</param>
            <param name="onValueChanged">The delegate to run when the value was changed.</param>
            <param name="invokeImmediately">
            Whether to run the callback immediately in this method. Can help reduce boilerplate
            </param>
            <typeparam name="T">The type of value contained in this CVar.</typeparam>
            <seealso cref="M:Robust.Shared.Configuration.IConfigurationManager.UnsubValueChanged``1(Robust.Shared.Configuration.CVarDef{``0},System.Action{``0})"/>
        </member>
        <member name="M:Robust.Shared.Configuration.IConfigurationManager.OnValueChanged``1(System.String,Robust.Shared.Configuration.CVarChanged{``0},System.Boolean)">
            <summary>
            Listen for an event for if the config value changes.
            </summary>
            <remarks>
            This is an O(n) operation.
            </remarks>
            <param name="name">The name of the CVar to listen for.</param>
            <param name="onValueChanged">The delegate to run when the value was changed.</param>
            <param name="invokeImmediately">
            Whether to run the callback immediately in this method. Can help reduce boilerplate
            </param>
            <typeparam name="T">The type of value contained in this CVar.</typeparam>
            <seealso cref="M:Robust.Shared.Configuration.IConfigurationManager.UnsubValueChanged``1(System.String,System.Action{``0})"/>
        </member>
        <member name="M:Robust.Shared.Configuration.IConfigurationManager.UnsubValueChanged``1(Robust.Shared.Configuration.CVarDef{``0},Robust.Shared.Configuration.CVarChanged{``0})">
            <summary>
            Unsubscribe an event previously registered with <see cref="M:Robust.Shared.Configuration.IConfigurationManager.OnValueChanged``1(Robust.Shared.Configuration.CVarDef{``0},System.Action{``0},System.Boolean)"/>.
            </summary>
            <remarks>
            This is an O(n) operation.
            </remarks>
            <param name="cVar">The CVar to unsubscribe from.</param>
            <param name="onValueChanged">The delegate to unsubscribe.</param>
            <typeparam name="T">The type of value contained in this CVar.</typeparam>
        </member>
        <member name="M:Robust.Shared.Configuration.IConfigurationManager.UnsubValueChanged``1(System.String,Robust.Shared.Configuration.CVarChanged{``0})">
            <summary>
            Unsubscribe an event previously registered with <see cref="M:Robust.Shared.Configuration.IConfigurationManager.OnValueChanged``1(System.String,System.Action{``0},System.Boolean)"/>.
            </summary>
            <remarks>
            This is an O(n) operation.
            </remarks>
            <param name="name">The name of the CVar to unsubscribe from.</param>
            <param name="onValueChanged">The delegate to unsubscribe.</param>
            <typeparam name="T">The type of value contained in this CVar.</typeparam>
        </member>
        <member name="M:Robust.Shared.Configuration.IConfigurationManagerInternal.LoadFromFile(System.String)">
            <summary>
            Sets up the ConfigurationManager and loads a TOML configuration file.
            </summary>
            <param name="configFile">the full name of the config file.</param>
        </member>
        <member name="M:Robust.Shared.Configuration.IConfigurationManagerInternal.SetSaveFile(System.String)">
            <summary>
                Specifies the location where the config file should be saved, without trying to load from it.
            </summary>
        </member>
        <member name="M:Robust.Shared.Configuration.IConfigurationManagerInternal.CheckUnusedCVars">
            <summary>
            Check the list of CVars to make sure there's no unused CVars set, which might indicate a typo or such.
            </summary>
        </member>
        <member name="T:Robust.Shared.Configuration.INetConfigurationManager">
            <summary>
            A networked configuration manager that controls the replication of
            console variables between client and server.
            </summary>
        </member>
        <member name="M:Robust.Shared.Configuration.INetConfigurationManager.SetupNetworking">
            <summary>
            Sets up the networking for the config manager.
            </summary>
        </member>
        <member name="M:Robust.Shared.Configuration.INetConfigurationManager.GetReplicatedVars(System.Boolean)">
            <summary>
            Gets the list of networked cvars that need to be sent to when connecting to server or client.
            </summary>
            <param name="all">If true, includes all replicated cvars. I.e., clients would include cvars that were
            received from the server, instead of only the ones that need to be sent to the server.</param>
            <returns></returns>
        </member>
        <member name="M:Robust.Shared.Configuration.INetConfigurationManager.TickProcessMessages">
            <summary>
            Called every tick to process any incoming network messages.
            </summary>
        </member>
        <member name="M:Robust.Shared.Configuration.INetConfigurationManager.FlushMessages">
            <summary>
            Flushes any NwCVar messages in the receive buffer.
            </summary>
        </member>
        <member name="M:Robust.Shared.Configuration.INetConfigurationManager.GetClientCVar``1(Robust.Shared.Network.INetChannel,System.String)">
            <summary>
            Get a replicated client CVar for a specific client. When used client-side, this simply returns the local cvar.
            </summary>
            <typeparam name="T">CVar type.</typeparam>
            <param name="channel">channel of the connected client.</param>
            <param name="name">Name of the CVar.</param>
            <returns>Replicated CVar of the client.</returns>
        </member>
        <member name="M:Robust.Shared.Configuration.INetConfigurationManager.GetClientCVar``1(Robust.Shared.Network.INetChannel,Robust.Shared.Configuration.CVarDef{``0})">
            <summary>
            Get a replicated client CVar for a specific client.
            </summary>
            <typeparam name="T">CVar type.</typeparam>
            <param name="channel">channel of the connected client.</param>
            <param name="definition">The CVar.</param>
            <returns>Replicated CVar of the client.</returns>
        </member>
        <member name="T:Robust.Shared.Configuration.NetConfigurationManager">
            <inheritdoc cref="T:Robust.Shared.Configuration.INetConfigurationManager"/>
        </member>
        <member name="M:Robust.Shared.Configuration.NetConfigurationManager.SetupNetworking">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Configuration.NetConfigurationManager.TickProcessMessages">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Configuration.NetConfigurationManager.FlushMessages">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Configuration.NetConfigurationManager.SyncConnectingClient(Robust.Shared.Network.INetChannel)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Configuration.NetConfigurationManager.GetClientCVar``1(Robust.Shared.Network.INetChannel,System.String)">
            <inheritdoc />
        </member>
        <member name="T:Robust.Shared.Console.CompletionHelper">
            <summary>
            Helpers for creating various completion results.
            </summary>
        </member>
        <member name="P:Robust.Shared.Console.CompletionHelper.Booleans">
            <summary>
                Returns the booleans False and True as completion options.
            </summary>
        </member>
        <member name="M:Robust.Shared.Console.CompletionHelper.AudioFilePath(System.String,Robust.Shared.Prototypes.IPrototypeManager,Robust.Shared.ContentPack.IResourceManager)">
            <summary>
            Special-cased file handler for audio that accounts for serverside completion.
            </summary>
        </member>
        <member name="M:Robust.Shared.Console.CompletionHelper.PrototypeIDs``1(System.Boolean,Robust.Shared.Prototypes.IPrototypeManager)">
            <summary>
                Returns a completion list for all prototype IDs of the given type.
            </summary>
            <remarks>
                Don't use this for prototypes types that likely have a large number of entries, like <see cref="T:Robust.Shared.Prototypes.EntityPrototype"/>.
            </remarks>
        </member>
        <member name="M:Robust.Shared.Console.CompletionHelper.SessionNames(System.Boolean,Robust.Shared.Player.ISharedPlayerManager)">
            <summary>
                Returns a list of connected session names.
            </summary>
        </member>
        <member name="M:Robust.Shared.Console.CompletionHelper.NetEntities(System.String,Robust.Shared.GameObjects.IEntityManager,System.Int32)">
            <summary>
            Return all existing entities as possible completions. You should generally avoid using this unless you need to.
            </summary>
        </member>
        <member name="T:Robust.Shared.Console.CompletionResult">
            <summary>
            Contains the result of a command completion.
            </summary>
        </member>
        <member name="M:Robust.Shared.Console.CompletionResult.#ctor(Robust.Shared.Console.CompletionOption[],System.String)">
            <summary>
            Contains the result of a command completion.
            </summary>
        </member>
        <member name="P:Robust.Shared.Console.CompletionResult.Options">
            <summary>
            The possible full arguments to complete with. These are from the start of the entire argument.
            </summary>
        </member>
        <member name="P:Robust.Shared.Console.CompletionResult.Hint">
            <summary>
            Type hint string for the current argument being typed.
            </summary>
        </member>
        <member name="T:Robust.Shared.Console.CompletionOption">
            <summary>
            Possible option to tab-complete in a <see cref="T:Robust.Shared.Console.CompletionResult"/>.
            </summary>
        </member>
        <member name="M:Robust.Shared.Console.CompletionOption.#ctor(System.String,System.String,Robust.Shared.Console.CompletionOptionFlags)">
            <summary>
            Possible option to tab-complete in a <see cref="T:Robust.Shared.Console.CompletionResult"/>.
            </summary>
        </member>
        <member name="P:Robust.Shared.Console.CompletionOption.Value">
            <summary>
            The value that will be filled in if completed.
            </summary>
        </member>
        <member name="P:Robust.Shared.Console.CompletionOption.Hint">
            <summary>
            Additional hint value that is shown to users, but not included in the completed value.
            </summary>
        </member>
        <member name="P:Robust.Shared.Console.CompletionOption.Flags">
            <summary>
            Flags that control how this completion is used.
            </summary>
        </member>
        <member name="T:Robust.Shared.Console.CompletionOptionFlags">
            <summary>
            Flag options for <see cref="T:Robust.Shared.Console.CompletionOption"/>.
            </summary>
        </member>
        <member name="F:Robust.Shared.Console.CompletionOptionFlags.PartialCompletion">
            <summary>
            The completion is "partial", it does complete the whole argument.
            Therefore, tab completing it should keep the cursor on the current argument
            (instead of adding a space to go to the next one).
            </summary>
        </member>
        <member name="T:Robust.Shared.Console.ConsoleHost">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Console.ConsoleHost.IsServer">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Console.ConsoleHost.LocalShell">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Console.ConsoleHost.AvailableCommands">
            <inheritdoc />
        </member>
        <member name="E:Robust.Shared.Console.ConsoleHost.ClearText">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Console.ConsoleHost.LoadConsoleCommands">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Console.ConsoleHost.UnregisterCommand(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Console.ConsoleHost.ClearLocalConsole">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Console.ConsoleHost.GetSessionShell(Robust.Shared.Player.ICommonSession)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Console.ConsoleHost.ExecuteCommand(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Console.ConsoleHost.AppendCommand(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Console.ConsoleHost.InsertCommand(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Console.ConsoleHost.CommandBufferExecute">
            <inheritdoc />
        </member>
        <member name="T:Robust.Shared.Console.ConsoleHost.RegisteredCommand">
            <summary>
            A console command that was registered inline through <see cref="T:Robust.Shared.Console.IConsoleHost"/>.
            </summary>
        </member>
        <member name="P:Robust.Shared.Console.ConsoleHost.RegisteredCommand.Command">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Console.ConsoleHost.RegisteredCommand.Description">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Console.ConsoleHost.RegisteredCommand.Help">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Console.ConsoleHost.RegisteredCommand.RequireServerOrSingleplayer">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Console.ConsoleHost.RegisteredCommand.#ctor(System.String,System.String,System.String,Robust.Shared.Console.ConCommandCallback,System.Boolean)">
            <summary>
            Constructs a new instance of <see cref="T:Robust.Shared.Console.ConsoleHost.RegisteredCommand"/>.
            </summary>
            <param name="command">Name of the command.</param>
            <param name="description">Short description of the command.</param>
            <param name="help">Extended description for the command.</param>
            <param name="callback">Callback function that is ran when the command is executed.</param>
            <param name="completionCallback">Callback function to get console completions.</param>
        </member>
        <member name="M:Robust.Shared.Console.ConsoleHost.RegisteredCommand.#ctor(System.String,System.String,System.String,Robust.Shared.Console.ConCommandCallback,Robust.Shared.Console.ConCommandCompletionCallback,System.Boolean)">
            <summary>
            Constructs a new instance of <see cref="T:Robust.Shared.Console.ConsoleHost.RegisteredCommand"/>.
            </summary>
            <param name="command">Name of the command.</param>
            <param name="description">Short description of the command.</param>
            <param name="help">Extended description for the command.</param>
            <param name="callback">Callback function that is ran when the command is executed.</param>
            <param name="completionCallback">Callback function to get console completions.</param>
        </member>
        <member name="M:Robust.Shared.Console.ConsoleHost.RegisteredCommand.#ctor(System.String,System.String,System.String,Robust.Shared.Console.ConCommandCallback,Robust.Shared.Console.ConCommandCompletionAsyncCallback,System.Boolean)">
            <summary>
            Constructs a new instance of <see cref="T:Robust.Shared.Console.ConsoleHost.RegisteredCommand"/>.
            </summary>
            <param name="command">Name of the command.</param>
            <param name="description">Short description of the command.</param>
            <param name="help">Extended description for the command.</param>
            <param name="callback">Callback function that is ran when the command is executed.</param>
            <param name="completionCallback">Asynchronous callback function to get console completions.</param>
        </member>
        <member name="M:Robust.Shared.Console.ConsoleHost.RegisteredCommand.Execute(Robust.Shared.Console.IConsoleShell,System.String,System.String[])">
            <inheritdoc />
        </member>
        <member name="T:Robust.Shared.Console.ConsoleShell">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Console.ConsoleShell.#ctor(Robust.Shared.Console.IConsoleHost,Robust.Shared.Player.ICommonSession,System.Boolean)">
            <summary>
            Constructs a new instance of <see cref="T:Robust.Shared.Console.ConsoleShell"/>.
            </summary>
            <param name="host">Console Host that owns this shell.</param>
            <param name="session">Player Session that this shell represents. May be null if this is a local server-side shell.</param>
            <param name="isLocal">Whether this is a local or remote shell.</param>
        </member>
        <member name="P:Robust.Shared.Console.ConsoleShell.ConsoleHost">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Console.ConsoleShell.IsServer">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Console.ConsoleShell.Player">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Console.ConsoleShell.IsLocal">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Console.ConsoleShell.ExecuteCommand(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Console.ConsoleShell.RemoteExecuteCommand(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Console.ConsoleShell.WriteLine(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Console.ConsoleShell.WriteError(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Console.ConsoleShell.Clear">
            <inheritdoc />
        </member>
        <member name="T:Robust.Shared.Console.EntityConsoleHost">
            <summary>
            Manages registration for "entity" console commands.
            </summary>
            <remarks>
            See <see cref="T:Robust.Shared.Console.LocalizedEntityCommands"/> for details on what "entity" console commands are.
            </remarks>
        </member>
        <member name="P:Robust.Shared.Console.EntityConsoleHost.DiscoverCommands">
            <summary>
            If disabled, don't automatically discover commands via reflection.
            </summary>
            <remarks>
            This gets disabled in certain unit tests.
            </remarks>
        </member>
        <member name="T:Robust.Shared.Console.IConsoleCommand">
            <summary>
            Basic interface to handle console commands. Any class implementing this will be
            registered with the console system through reflection.
            </summary>
        </member>
        <member name="P:Robust.Shared.Console.IConsoleCommand.Command">
            <summary>
            Name of the command.
            </summary>
            <value>
            A string as identifier for this command.
            </value>
        </member>
        <member name="P:Robust.Shared.Console.IConsoleCommand.Description">
            <summary>
            Short description of the command.
            </summary>
            <value>
            String printed as short summary in the "help" command.
            </value>
        </member>
        <member name="P:Robust.Shared.Console.IConsoleCommand.Help">
            <summary>
            Extended description for the command.
            </summary>
            <value>
            String printed as summary when "help Command" is used.
            </value>
        </member>
        <member name="P:Robust.Shared.Console.IConsoleCommand.RequireServerOrSingleplayer">
            <summary>
            If true, this command will be unavailable to clients while they are connected to a server. Has no effect on servers.
            </summary>
        </member>
        <member name="M:Robust.Shared.Console.IConsoleCommand.Execute(Robust.Shared.Console.IConsoleShell,System.String,System.String[])">
            <summary>
            Executes the client command.
            </summary>
            <param name="shell">The console that executed this command.</param>
            <param name="argStr">Unparsed text of the complete command with arguments.</param>
            <param name="args">An array of all the parsed arguments.</param>
        </member>
        <member name="M:Robust.Shared.Console.IConsoleCommand.GetCompletion(Robust.Shared.Console.IConsoleShell,System.String[])">
            <summary>
            Fetches completion results for a typing a command.
            </summary>
            <remarks>
            <para>
            Refrain from doing simple <c>.StartsWith(</c> filtering based on the currently typing command.
            The client already does this filtering on its own,
            so doing it manually would reduce responsiveness thanks to network lag.
            It may however be desirable to do larger-scale filtering.
            For example when typing out a resource path you could manually filter level-by-level as it's being typed.
            </para>
            <para>
            Only arguments to the left of the cursor are passed.
            If the user puts their cursor in the middle of a line and starts typing, anything to the right is ignored.
            </para>
            </remarks>
            <param name="shell">The console that is typing this command.</param>
            <param name="args">The set of commands currently being typed.
            If the last parameter is an empty string, it basically represents that the user hit space after the previous term and should already get completion results,
            even if they haven't started typing the new argument yet.</param>
            <returns>The possible completion results presented to the user.</returns>
            <seealso cref="M:Robust.Shared.Console.IConsoleCommand.GetCompletionAsync(Robust.Shared.Console.IConsoleShell,System.String[],System.String,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Robust.Shared.Console.IConsoleCommand.GetCompletionAsync(Robust.Shared.Console.IConsoleShell,System.String[],System.String,System.Threading.CancellationToken)">
            <summary>
            Fetches completion results for typing a command, async variant. See <see cref="M:Robust.Shared.Console.IConsoleCommand.GetCompletion(Robust.Shared.Console.IConsoleShell,System.String[])"/> for details.
            </summary>
            <remarks>
            If this method is implemented, <see cref="M:Robust.Shared.Console.IConsoleCommand.GetCompletion(Robust.Shared.Console.IConsoleShell,System.String[])"/> will not be automatically called.
            </remarks>
        </member>
        <member name="T:Robust.Shared.Console.IEntityConsoleCommand">
            <summary>
            Special marker interface used to indicate "entity" commands.
            See <see cref="T:Robust.Shared.Console.LocalizedEntityCommands"/> for an overview.
            </summary>
            <seealso cref="T:Robust.Shared.Console.EntityConsoleHost"/>
        </member>
        <member name="T:Robust.Shared.Console.ConCommandCallback">
            <summary>
            A delegate that is called when the command is executed inside a shell.
            </summary>
            <param name="shell">The console shell that executed this command.</param>
            <param name="argStr">Unparsed text of the complete command with arguments.</param>
            <param name="args">An array of all the parsed arguments.</param>
        </member>
        <member name="T:Robust.Shared.Console.ConCommandCompletionCallback">
            <summary>
            Called to fetch completions for a console command. See <see cref="M:Robust.Shared.Console.IConsoleCommand.GetCompletion(Robust.Shared.Console.IConsoleShell,System.String[])"/> for details.
            </summary>
        </member>
        <member name="T:Robust.Shared.Console.ConCommandCompletionAsyncCallback">
            <summary>
            Called to fetch completions for a console command (async). See <see cref="M:Robust.Shared.Console.IConsoleCommand.GetCompletionAsync(Robust.Shared.Console.IConsoleShell,System.String[],System.String,System.Threading.CancellationToken)"/> for details.
            </summary>
        </member>
        <member name="T:Robust.Shared.Console.IConsoleHost">
            <summary>
            The console host exists as a singleton subsystem that provides all of the features of the console API.
            It will register console commands, spawn console shells and execute command strings.
            </summary>
        </member>
        <member name="P:Robust.Shared.Console.IConsoleHost.IsClient">
            <summary>
            Is the shell running on the client?
            </summary>
        </member>
        <member name="P:Robust.Shared.Console.IConsoleHost.IsServer">
            <summary>
            Is the shell running on the server?
            </summary>
        </member>
        <member name="P:Robust.Shared.Console.IConsoleHost.LocalShell">
            <summary>
            The local shell of the peer that is always available.
            </summary>
        </member>
        <member name="P:Robust.Shared.Console.IConsoleHost.AvailableCommands">
            <summary>
            A map of (commandName -> ICommand) of every registered command in the shell.
            </summary>
        </member>
        <member name="E:Robust.Shared.Console.IConsoleHost.AnyCommandExecuted">
            <summary>
            Invoked before any console command is executed.
            </summary>
        </member>
        <member name="M:Robust.Shared.Console.IConsoleHost.LoadConsoleCommands">
            <summary>
            Scans all loaded assemblies for console commands and registers them. This will NOT sync with connected clients, and
            should only be used during server initialization.
            </summary>
        </member>
        <member name="M:Robust.Shared.Console.IConsoleHost.RegisterCommand(System.String,System.String,System.String,Robust.Shared.Console.ConCommandCallback,System.Boolean)">
            <summary>
            Registers a console command into the console system. This is an alternative to
            creating an <see cref="T:Robust.Shared.Console.IConsoleCommand"/> class.
            </summary>
            <param name="command">A string as identifier for this command.</param>
            <param name="description">Short one sentence description of the command.</param>
            <param name="help">Command format string.</param>
            <param name="callback">
            Callback to invoke when this command is executed.
            </param>
        </member>
        <member name="M:Robust.Shared.Console.IConsoleHost.RegisterCommand(System.String,System.String,System.String,Robust.Shared.Console.ConCommandCallback,Robust.Shared.Console.ConCommandCompletionCallback,System.Boolean)">
            <summary>
            Registers a console command into the console system. This is an alternative to
            creating an <see cref="T:Robust.Shared.Console.IConsoleCommand"/> class.
            </summary>
            <param name="command">A string as identifier for this command.</param>
            <param name="description">Short one sentence description of the command.</param>
            <param name="help">Command format string.</param>
            <param name="callback">
            Callback to invoke when this command is executed.
            </param>
            <param name="completionCallback">
            Callback to fetch completions with.
            </param>
        </member>
        <member name="M:Robust.Shared.Console.IConsoleHost.RegisterCommand(System.String,System.String,System.String,Robust.Shared.Console.ConCommandCallback,Robust.Shared.Console.ConCommandCompletionAsyncCallback,System.Boolean)">
            <summary>
            Registers a console command into the console system. This is an alternative to
            creating an <see cref="T:Robust.Shared.Console.IConsoleCommand"/> class.
            </summary>
            <param name="command">A string as identifier for this command.</param>
            <param name="description">Short one sentence description of the command.</param>
            <param name="help">Command format string.</param>
            <param name="callback">
            Callback to invoke when this command is executed.
            </param>
            <param name="completionCallback">
            Callback to fetch completions with (async variant).
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Robust.Shared.Console.IConsoleHost.RegisterCommand(System.String,Robust.Shared.Console.ConCommandCallback,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:Robust.Shared.Console.IConsoleHost.RegisterCommand(System.String,Robust.Shared.Console.ConCommandCallback,Robust.Shared.Console.ConCommandCompletionCallback,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:Robust.Shared.Console.IConsoleHost.RegisterCommand(System.String,Robust.Shared.Console.ConCommandCallback,Robust.Shared.Console.ConCommandCompletionAsyncCallback,System.Boolean)" -->
        <member name="M:Robust.Shared.Console.IConsoleHost.RegisterCommand(Robust.Shared.Console.IConsoleCommand)">
            <summary>
            Register an existing console command instance directly.
            </summary>
            <remarks>
            For this to be useful, the command has to be somehow excluded from automatic registration,
            such as by using the <see cref="T:Robust.Shared.Reflection.ReflectAttribute"/>.
            </remarks>
            <param name="command">The command to register.</param>
            <seealso cref="M:Robust.Shared.Console.IConsoleHost.BeginRegistrationRegion"/>
        </member>
        <member name="M:Robust.Shared.Console.IConsoleHost.BeginRegistrationRegion">
            <summary>
            Begin a region for registering many console commands in one go.
            The region can be ended with <see cref="M:Robust.Shared.Console.IConsoleHost.EndRegistrationRegion"/>.
            </summary>
            <remarks>
            Commands registered inside this region temporarily suppress some updating
            logic that would cause significant wasted work. This logic runs when the region is ended instead.
            </remarks>
        </member>
        <member name="M:Robust.Shared.Console.IConsoleHost.EndRegistrationRegion">
            <summary>
            End a registration region started with <see cref="M:Robust.Shared.Console.IConsoleHost.BeginRegistrationRegion"/>.
            </summary>
        </member>
        <member name="M:Robust.Shared.Console.IConsoleHost.UnregisterCommand(System.String)">
            <summary>
            Unregisters a console command that has been registered previously with <see cref="!:RegisterCommand(string,string,string,Robust.Shared.Console.ConCommandCallback)"/>.
            If the specified command was registered automatically or isn't registered at all, the method will throw.
            </summary>
            <param name="command">The string identifier for the command.</param>
        </member>
        <member name="M:Robust.Shared.Console.IConsoleHost.GetSessionShell(Robust.Shared.Player.ICommonSession)">
            <summary>
            Returns the console shell for a given active session.
            </summary>
            <remarks>
            On the client this will always return the local shell, on the server this will return the shell of the active
            session.
            </remarks>
            <param name="session">Session to get the shell of.</param>
            <returns>Shell of the specified session.</returns>
        </member>
        <member name="M:Robust.Shared.Console.IConsoleHost.ExecuteCommand(System.String)">
            <summary>
            Execute a command string immediately on the local shell, bypassing the command buffer completely.
            </summary>
            <param name="command">Command string to execute.</param>
        </member>
        <member name="M:Robust.Shared.Console.IConsoleHost.AppendCommand(System.String)">
            <summary>
            Appends a command into the end of the command buffer on the local shell.
            </summary>
            <remarks>
             This command will be ran *sometime* in the future, depending on how many waits are in the buffer.
            </remarks>
            <param name="command">Command string to execute.</param>
        </member>
        <member name="M:Robust.Shared.Console.IConsoleHost.InsertCommand(System.String)">
            <summary>
            Inserts a command into the front of the command buffer on the local shell.
            </summary>
            <remarks>
             This command will preempt the next command executed in the command buffer.
            </remarks>
            <param name="command">Command string to execute.</param>
        </member>
        <member name="M:Robust.Shared.Console.IConsoleHost.CommandBufferExecute">
            <summary>
            Processes any contents of the command buffer on the local shell. This needs to be called regularly (once a tick),
            inside the simulation. Pausing the server should prevent the buffer from being processed.
            </summary>
        </member>
        <member name="M:Robust.Shared.Console.IConsoleHost.ExecuteCommand(Robust.Shared.Player.ICommonSession,System.String)">
            <summary>
            Executes a command string on this specific session shell. If the command does not exist, the command will be forwarded
            to the
            remote shell.
            </summary>
            <param name="session">Session of the client to execute the command.</param>
            <param name="command">command line string to execute.</param>
        </member>
        <member name="M:Robust.Shared.Console.IConsoleHost.RemoteExecuteCommand(Robust.Shared.Player.ICommonSession,System.String)">
            <summary>
            Executes the command string on the remote peer. This is mainly used to forward commands from the client to the server.
            If there is no remote peer (this is a local shell), this function does nothing.
            </summary>
            <param name="session">Session of the remote peer to execute the command on.</param>
            <param name="command">Command line string to execute at the remote endpoint.</param>
        </member>
        <member name="M:Robust.Shared.Console.IConsoleHost.WriteLine(Robust.Shared.Player.ICommonSession,System.String)">
            <summary>
            Sends a text string to the remote session.
            </summary>
            <param name="session">
            Remote session to send the text message to. If this is null, the text is sent to the local
            console.
            </param>
            <param name="text">Text message to send.</param>
        </member>
        <member name="M:Robust.Shared.Console.IConsoleHost.WriteError(Robust.Shared.Player.ICommonSession,System.String)">
            <summary>
            Sends a foreground colored text string to the remote session.
            </summary>
            <param name="session">
            Remote session to send the text message to. If this is null, the text is sent to the local
            console.
            </param>
            <param name="text">Text message to send.</param>
        </member>
        <member name="M:Robust.Shared.Console.IConsoleHost.ClearLocalConsole">
            <summary>
            Removes all text from the local console.
            </summary>
        </member>
        <member name="M:Robust.Shared.Console.IConsoleHostInternal.IsCmdServer(Robust.Shared.Console.IConsoleCommand)">
            <summary>
            Is this command executed on the server?
            Always true when ran from server, true for server-proxy commands on the client.
            </summary>
        </member>
        <member name="T:Robust.Shared.Console.IConsoleShell">
            <summary>
            The console shell that executes commands. Each shell executes commands in the context of a player
            session, or without a session in a local context.
            </summary>
        </member>
        <member name="P:Robust.Shared.Console.IConsoleShell.ConsoleHost">
            <summary>
            The console host that owns this shell.
            </summary>
        </member>
        <member name="P:Robust.Shared.Console.IConsoleShell.IsClient">
            <summary>
            Is the shell running on the client?
            </summary>
        </member>
        <member name="P:Robust.Shared.Console.IConsoleShell.IsLocal">
            <summary>
            Is the shell running in a local context (no remote peer session)?.
            </summary>
        </member>
        <member name="P:Robust.Shared.Console.IConsoleShell.IsServer">
            <summary>
            Is the shell running on the server?
            </summary>
        </member>
        <member name="P:Robust.Shared.Console.IConsoleShell.Player">
            <summary>
            The remote peer that owns this shell, or the local player if this is a client-side local shell (<see cref="P:Robust.Shared.Console.IConsoleShell.IsLocal" /> is true and <see cref="P:Robust.Shared.Console.IConsoleShell.IsClient"/> is true).
            </summary>
        </member>
        <member name="M:Robust.Shared.Console.IConsoleShell.ExecuteCommand(System.String)">
            <summary>
            Executes a command string on this specific session shell. If the command does not exist, the command will be forwarded
            to the
            remote shell.
            </summary>
            <param name="command">command line string to execute.</param>
        </member>
        <member name="M:Robust.Shared.Console.IConsoleShell.RemoteExecuteCommand(System.String)">
            <summary>
            Executes the command string on the remote peer. This is mainly used to forward commands from the client to the server.
            If there is no remote peer (this is a local shell), this function does nothing.
            </summary>
            <param name="command">Command line string to execute at the remote endpoint.</param>
        </member>
        <member name="M:Robust.Shared.Console.IConsoleShell.WriteLine(System.String)">
            <summary>
            Writes a line to the output of the console.
            </summary>
            <param name="text">Line of text to write.</param>
        </member>
        <member name="M:Robust.Shared.Console.IConsoleShell.WriteError(System.String)">
            <summary>
            Write an error line to the console window.
            </summary>
            <param name="text">Line of text to write.</param>
        </member>
        <member name="M:Robust.Shared.Console.IConsoleShell.Clear">
            <summary>
            Clears the entire console of text.
            </summary>
        </member>
        <member name="P:Robust.Shared.Console.LocalizedCommands.Command">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Console.LocalizedCommands.Description">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Console.LocalizedCommands.Help">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Console.LocalizedCommands.RequireServerOrSingleplayer">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Console.LocalizedCommands.Execute(Robust.Shared.Console.IConsoleShell,System.String,System.String[])">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Console.LocalizedCommands.GetCompletion(Robust.Shared.Console.IConsoleShell,System.String[])">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Console.LocalizedCommands.GetCompletionAsync(Robust.Shared.Console.IConsoleShell,System.String[],System.String,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="T:Robust.Shared.Console.LocalizedEntityCommands">
            <summary>
            Base class for localized console commands that run in "entity space".
            </summary>
            <remarks>
            <para>
            This type of command is registered only while the entity system is active.
            On the client this means that the commands are only available while connected to a server or in single player.
            </para>
            <para>
            These commands are allowed to take dependencies on entity systems, reducing boilerplate for many usages.
            </para>
            </remarks>
        </member>
        <member name="T:Robust.Shared.Containers.BaseContainer">
            <summary>
            Base container class that all container inherit from.
            </summary>
        </member>
        <member name="P:Robust.Shared.Containers.BaseContainer.ContainedEntities">
            <summary>
            Readonly collection of all the entities contained within this specific container
            </summary>
        </member>
        <member name="P:Robust.Shared.Containers.BaseContainer.Count">
            <summary>
            Number of contained entities.
            </summary>
        </member>
        <member name="F:Robust.Shared.Containers.BaseContainer.ID">
            <summary>
            The ID of this container.
            </summary>
        </member>
        <member name="P:Robust.Shared.Containers.BaseContainer.OccludesLight">
            <summary>
            Prevents light from escaping the container, from ex. a flashlight.
            </summary>
        </member>
        <member name="P:Robust.Shared.Containers.BaseContainer.Owner">
            <summary>
            The entity that owns this container.
            </summary>
        </member>
        <member name="P:Robust.Shared.Containers.BaseContainer.ShowContents">
            <summary>
            Should the contents of this container be shown? False for closed containers like lockers, true for
            things like glass display cases.
            </summary>
        </member>
        <member name="M:Robust.Shared.Containers.BaseContainer.Contains(Robust.Shared.GameObjects.EntityUid)">
            <summary>
            Checks if the entity is contained in this container.
            This is not recursive, so containers of children are not checked.
            </summary>
            <param name="contained">The entity to check.</param>
            <returns>True if the entity is immediately contained in this container, false otherwise.</returns>
        </member>
        <member name="M:Robust.Shared.Containers.BaseContainer.CanInsert(Robust.Shared.GameObjects.EntityUid,System.Boolean,Robust.Shared.GameObjects.IEntityManager)">
            <summary>
            Whether the given entity can be inserted into this container.
            </summary>
            <param name="assumeEmpty">Whether to assume that the container is currently empty.</param>
        </member>
        <member name="M:Robust.Shared.Containers.BaseContainer.InternalInsert(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.IEntityManager)">
            <summary>
            Implement to store the reference in whatever form you want
            </summary>
            <param name="toInsert"></param>
            <param name="entMan"></param>
        </member>
        <member name="M:Robust.Shared.Containers.BaseContainer.InternalRemove(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.IEntityManager)">
            <summary>
            Implement to remove the reference you used to store the entity
            </summary>
            <param name="toRemove"></param>
            <param name="entMan"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Robust.Shared.Containers.BaseContainer.InternalShutdown(Robust.Shared.GameObjects.IEntityManager,Robust.Shared.Containers.SharedContainerSystem,System.Boolean)" -->
        <member name="M:Robust.Shared.Containers.BaseContainer.InternalCopy(Robust.Shared.Containers.BaseContainer@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Containers.BaseContainer.Copy(Robust.Shared.Containers.BaseContainer@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Containers.BaseContainer.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Containers.BaseContainer.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Shared.Containers.Container">
            <summary>
            Default implementation for containers,
            cannot be inherited. If additional logic is needed,
            this logic should go on the systems that are holding this container.
            For example, inventory containers should be modified only through an inventory component.
            </summary>
        </member>
        <member name="F:Robust.Shared.Containers.Container._containerList">
            <summary>
            The generic container class uses a list of entities
            </summary>
        </member>
        <member name="P:Robust.Shared.Containers.Container.ContainedEntities">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Containers.Container.InternalInsert(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.IEntityManager)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Containers.Container.InternalRemove(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.IEntityManager)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Containers.Container.Contains(Robust.Shared.GameObjects.EntityUid)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Containers.Container.InternalShutdown(Robust.Shared.GameObjects.IEntityManager,Robust.Shared.Containers.SharedContainerSystem,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Containers.Container.InternalCopy(Robust.Shared.Containers.Container@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Containers.Container.Copy(Robust.Shared.Containers.Container@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Containers.Container.Copy(Robust.Shared.Containers.BaseContainer@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Containers.Container.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Containers.Container.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Shared.Containers.ContainerManagerComponent">
            <summary>
            Holds data about a set of entity containers on this entity.
            </summary>
        </member>
        <member name="M:Robust.Shared.Containers.ContainerManagerComponent.InternalCopy(Robust.Shared.Containers.ContainerManagerComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Containers.ContainerManagerComponent.Copy(Robust.Shared.Containers.ContainerManagerComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Containers.ContainerManagerComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Containers.ContainerManagerComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Containers.ContainerManagerComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Containers.ContainerManagerComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Containers.ContainerManagerComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="P:Robust.Shared.Containers.ContainerSlot.ContainedEntities">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Containers.ContainerSlot.Contains(Robust.Shared.GameObjects.EntityUid)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Containers.ContainerSlot.InternalInsert(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.IEntityManager)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Containers.ContainerSlot.InternalRemove(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.IEntityManager)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Containers.ContainerSlot.InternalShutdown(Robust.Shared.GameObjects.IEntityManager,Robust.Shared.Containers.SharedContainerSystem,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Containers.ContainerSlot.InternalCopy(Robust.Shared.Containers.ContainerSlot@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Containers.ContainerSlot.Copy(Robust.Shared.Containers.ContainerSlot@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Containers.ContainerSlot.Copy(Robust.Shared.Containers.BaseContainer@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Containers.ContainerSlot.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Containers.ContainerSlot.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="P:Robust.Shared.Containers.ContainerIsInsertingAttemptEvent.AssumeEmpty">
            <summary>
            If true, this check should assume that the container is currently empty.
            I.e., could the entity be inserted if the container doesn't contain anything else?
            </summary>
        </member>
        <member name="P:Robust.Shared.Containers.ContainerGettingInsertedAttemptEvent.AssumeEmpty">
            <summary>
            If true, this check should assume that the container is currently empty.
            I.e., could the entity be inserted if the container doesn't contain anything else?
            </summary>
        </member>
        <member name="T:Robust.Shared.Containers.ContainerModifiedMessage">
            <summary>
            Raised when the contents of a container have been modified.
            </summary>
        </member>
        <member name="P:Robust.Shared.Containers.ContainerModifiedMessage.Container">
            <summary>
            The container being acted upon.
            </summary>
        </member>
        <member name="P:Robust.Shared.Containers.ContainerModifiedMessage.Entity">
            <summary>
            The entity that was removed or inserted from/into the container.
            </summary>
        </member>
        <member name="T:Robust.Shared.Containers.EntGotInsertedIntoContainerMessage">
            <summary>
            Directed at the entity that was inserted successfully.
            </summary>
        </member>
        <member name="T:Robust.Shared.Containers.EntInsertedIntoContainerMessage">
            <summary>
            Raised when an entity is inserted into a container. This is raised AFTER the entity has been re-parented. I.e., the current parent is the container.
            </summary>
        </member>
        <member name="T:Robust.Shared.Containers.EntRemovedFromContainerMessage">
            <summary>
            Raised when an entity is removed from a container. Directed at the container. This gets called BEFORE the entity gets re-parented. I.e., the current parent is the container.
            </summary>
        </member>
        <member name="T:Robust.Shared.Containers.EntGotRemovedFromContainerMessage">
            <summary>
            Raised when an entity is removed from a container. Directed at the entity. This gets called BEFORE the entity gets re-parented. I.e., the current parent is the container.
            </summary>
        </member>
        <member name="M:Robust.Shared.Containers.SharedContainerSystem.Initialize">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Containers.SharedContainerSystem.IsEntityInContainer(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
                Checks whether the given entity is inside of a container. This will only check if this entity's direct
                parent is containing it. To recursively if the entity, or any parent, is inside a container, use <see
                cref="M:Robust.Shared.Containers.SharedContainerSystem.IsEntityOrParentInContainer(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent,Robust.Shared.GameObjects.TransformComponent)"/>
            </summary>
            <returns>If the entity is inside of a container.</returns>
        </member>
        <member name="M:Robust.Shared.Containers.SharedContainerSystem.IsEntityOrParentInContainer(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent,Robust.Shared.GameObjects.TransformComponent)">
            <summary>
                Recursively check if the entity or any parent is inside of a container.
            </summary>
            <returns>If the entity is inside of a container.</returns>
        </member>
        <member name="M:Robust.Shared.Containers.SharedContainerSystem.TryFindComponentOnEntityContainerOrParent``1(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.EntityQuery{``0},``0@,Robust.Shared.GameObjects.MetaDataComponent,Robust.Shared.GameObjects.TransformComponent)">
            <summary>
                Finds the first instance of a component on the recursive parented containers that hold an entity
            </summary>
        </member>
        <member name="M:Robust.Shared.Containers.SharedContainerSystem.TryFindComponentsOnEntityContainerOrParent``1(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.EntityQuery{``0},System.Collections.Generic.List{``0},Robust.Shared.GameObjects.MetaDataComponent,Robust.Shared.GameObjects.TransformComponent)">
            <summary>
                Finds all instances of a component on the recursive parented containers that hold an entity
            </summary>
        </member>
        <member name="M:Robust.Shared.Containers.SharedContainerSystem.IsInSameOrNoContainer(Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.TransformComponent,Robust.Shared.GameObjects.MetaDataComponent},Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.TransformComponent,Robust.Shared.GameObjects.MetaDataComponent})">
            <summary>
                Returns true if the two entities are not contained, or are contained in the same container.
            </summary>
        </member>
        <member name="M:Robust.Shared.Containers.SharedContainerSystem.IsInSameOrParentContainer(Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.TransformComponent,Robust.Shared.GameObjects.MetaDataComponent},Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.TransformComponent,Robust.Shared.GameObjects.MetaDataComponent})">
            <summary>
                Returns true if the two entities are not contained, or are contained in the same container, or if one
                entity contains the other (i.e., is the parent).
            </summary>
        </member>
        <member name="M:Robust.Shared.Containers.SharedContainerSystem.IsInSameOrParentContainer(Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.TransformComponent,Robust.Shared.GameObjects.MetaDataComponent},Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.TransformComponent,Robust.Shared.GameObjects.MetaDataComponent},Robust.Shared.Containers.BaseContainer@,Robust.Shared.Containers.BaseContainer@)">
            <inheritdoc cref="!:IsInSameOrParentContainer(Robust.Shared.GameObjects.Entity&lt;Robust.Shared.GameObjects.TransformComponent?&gt;,Robust.Shared.GameObjects.Entity&lt;Robust.Shared.GameObjects.TransformComponent?&gt;)"/>
        </member>
        <member name="M:Robust.Shared.Containers.SharedContainerSystem.IsInSameOrTransparentContainer(Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.TransformComponent,Robust.Shared.GameObjects.MetaDataComponent},Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.TransformComponent,Robust.Shared.GameObjects.MetaDataComponent},Robust.Shared.Containers.BaseContainer,Robust.Shared.Containers.BaseContainer,System.Boolean)">
            <summary>
                Check whether a given entity can see another entity despite whatever containers they may be in.
            </summary>
            <remarks>
                This is effectively a variant of <see cref="M:Robust.Shared.Containers.SharedContainerSystem.IsInSameOrParentContainer(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.EntityUid)"/> that also checks whether the
                containers are transparent. Additionally, an entity can "see" the entity that contains it, but unless
                otherwise specified the containing entity cannot see into itself. For example, a human in a locker can
                see the locker and other items in that locker, but the human cannot see their own organs.  Note that
                this means that the two entity arguments are NOT interchangeable.
            </remarks>
        </member>
        <member name="M:Robust.Shared.Containers.SharedContainerSystem.TryGetOuterContainer(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.TransformComponent,Robust.Shared.Containers.BaseContainer@)">
            <summary>
            Gets the top-most container in the hierarchy for this entity, if it exists.
            </summary>
        </member>
        <member name="M:Robust.Shared.Containers.SharedContainerSystem.TryRemoveFromContainer(Robust.Shared.GameObjects.EntityUid,System.Boolean,System.Boolean@)">
            <summary>
            Attempts to remove an entity from its container, if any.
            </summary>
            <param name="entity">Entity that might be inside a container.</param>
            <param name="force">Whether to forcibly remove the entity from the container.</param>
            <param name="wasInContainer">Whether the entity was actually inside a container or not.</param>
            <returns>If the entity could be removed. Also returns false if it wasn't inside a container.</returns>
        </member>
        <member name="M:Robust.Shared.Containers.SharedContainerSystem.TryRemoveFromContainer(Robust.Shared.GameObjects.EntityUid,System.Boolean)">
            <summary>
            Attempts to remove an entity from its container, if any.
            </summary>
            <param name="entity">Entity that might be inside a container.</param>
            <param name="force">Whether to forcibly remove the entity from the container.</param>
            <returns>If the entity could be removed. Also returns false if it wasn't inside a container.</returns>
        </member>
        <member name="M:Robust.Shared.Containers.SharedContainerSystem.EmptyContainer(Robust.Shared.Containers.BaseContainer,System.Boolean,System.Nullable{Robust.Shared.Map.EntityCoordinates},System.Boolean)">
            <summary>
            Attempts to remove all entities in a container. Returns removed entities.
            </summary>
        </member>
        <member name="M:Robust.Shared.Containers.SharedContainerSystem.CleanContainer(Robust.Shared.Containers.BaseContainer)">
            <summary>
            Attempts to remove and delete all entities in a container.
            </summary>
        </member>
        <member name="M:Robust.Shared.Containers.SharedContainerSystem.Insert(Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.TransformComponent,Robust.Shared.GameObjects.MetaDataComponent,Robust.Shared.Physics.Components.PhysicsComponent},Robust.Shared.Containers.BaseContainer,Robust.Shared.GameObjects.TransformComponent,System.Boolean)">
            <summary>
            Attempts to insert the entity into this container.
            </summary>
            <remarks>
            If the insertion is successful, the inserted entity will end up parented to the
            container entity, and the inserted entity's local position will be set to the zero vector.
            </remarks>
            <param name="toInsert">The entity to insert.</param>
            <param name="container">The container to insert into.</param>
            <param name="containerXform">The container's transform component.</param>
            <param name="force">Whether to bypass normal insertion checks.</param>
            <returns>False if the entity could not be inserted.</returns>
            <exception cref="T:System.InvalidOperationException">
            Thrown if this container is a child of the entity,
            which would cause infinite loops.
            </exception>
        </member>
        <member name="M:Robust.Shared.Containers.SharedContainerSystem.InsertOrDrop(Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.TransformComponent,Robust.Shared.GameObjects.MetaDataComponent,Robust.Shared.Physics.Components.PhysicsComponent},Robust.Shared.Containers.BaseContainer,Robust.Shared.GameObjects.TransformComponent)">
            <summary>
            Attempts to insert an entity into a container. If it fails, it will instead drop the entity next to the
            container entity.
            </summary>
            <returns>Whether or not the entity was successfully inserted</returns>
        </member>
        <member name="M:Robust.Shared.Containers.SharedContainerSystem.CanInsert(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Containers.BaseContainer,System.Boolean,Robust.Shared.GameObjects.TransformComponent)">
            <summary>
            Checks if the entity can be inserted into the given container.
            </summary>
            <param name="assumeEmpty">If true, this will check whether the entity could be inserted if the container were
            empty.</param>
        </member>
        <member name="M:Robust.Shared.Containers.SharedContainerSystem.Remove(Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.TransformComponent,Robust.Shared.GameObjects.MetaDataComponent},Robust.Shared.Containers.BaseContainer,System.Boolean,System.Boolean,System.Nullable{Robust.Shared.Map.EntityCoordinates},System.Nullable{Robust.Shared.Maths.Angle})">
            <summary>
            Attempts to remove the entity from this container.
            </summary>
            <remarks>
            If the insertion is successful, the inserted entity will end up parented to the
            container entity, and the inserted entity's local position will be set to the zero vector.
            </remarks>
            <param name="toRemove">The entity to remove.</param>
            <param name="container">The container to remove from.</param>
            <param name="reparent">If false, this operation will not rigger a move or parent change event. Ignored if
            destination is not null</param>
            <param name="force">If true, this will not perform can-remove checks.</param>
            <param name="destination">Where to place the entity after removing. Avoids unnecessary broadphase updates.
            If not specified, and reparent option is true, then the entity will either be inserted into a parent
            container, the grid, or the map.</param>
            <param name="localRotation">Optional final local rotation after removal. Avoids redundant move events.</param>
        </member>
        <member name="M:Robust.Shared.Containers.SharedContainerSystem.CanRemove(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Containers.BaseContainer)">
            <summary>
            Checks if the entity can be removed from this container.
            </summary>
            <returns>True if the entity can be removed, false otherwise.</returns>
        </member>
        <member name="M:Robust.Shared.ContentPack.AppDomainExt.GetAssemblyByName(System.AppDomain,System.String)">
            <summary>
                Gets an assembly by name from the given AppDomain.
            </summary>
            <param name="domain"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="T:Robust.Shared.ContentPack.AssemblyTypeChecker">
            <summary>
                Manages the type white/black list of types and namespaces, and verifies assemblies against them.
            </summary>
        </member>
        <member name="P:Robust.Shared.ContentPack.AssemblyTypeChecker.DisableTypeCheck">
            <summary>
                Completely disables type checking, allowing everything.
            </summary>
        </member>
        <member name="M:Robust.Shared.ContentPack.AssemblyTypeChecker.CheckAssembly(System.IO.Stream)">
            <summary>
                Check the assembly for any illegal types. Any types not on the white list
                will cause the assembly to be rejected.
            </summary>
            <param name="assembly">Assembly to load.</param>
            <returns></returns>
        </member>
        <member name="M:Robust.Shared.ContentPack.AssemblyTypeChecker.CheckAssembly(System.IO.Stream,Robust.Shared.ContentPack.AssemblyTypeChecker.Resolver)">
            <summary>
                Check the assembly for any illegal types. Any types not on the white list
                will cause the assembly to be rejected.
            </summary>
            <param name="assembly">Assembly to load.</param>
            <returns></returns>
        </member>
        <member name="M:Robust.Shared.ContentPack.AssemblyTypeChecker.ParseTypeReference(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.TypeReferenceHandle)">
            <exception href="UnsupportedMetadataException">
                Thrown if the metadata does something funny we don't "support" like type forwarding.
            </exception>
        </member>
        <member name="M:Robust.Shared.ContentPack.AssemblyTypeChecker.MType.WhitelistToString">
            <summary>
            Outputs this type in a format re-parseable for the sandbox config whitelist.
            </summary>
        </member>
        <member name="F:Robust.Shared.ContentPack.BaseModLoader.Mods">
            <summary>
                Loaded assemblies.
            </summary>
        </member>
        <member name="T:Robust.Shared.ContentPack.BaseModLoader.ModInfo">
            <summary>
                Holds info about a loaded assembly.
            </summary>
        </member>
        <member name="T:Robust.Shared.ContentPack.ContentAccessAllowedAttribute">
            <summary>
            Mark this type as content safe, which means <see cref="M:Robust.Shared.ContentPack.ModLoaderExt.IsContentTypeAccessAllowed(Robust.Shared.ContentPack.IModLoader,System.Type)"/> will pass for it.
            This means it can be spawned dynamically with <see cref="T:Robust.Shared.IoC.IDynamicTypeFactory"/>.
            </summary>
        </member>
        <member name="T:Robust.Shared.ContentPack.ResourceManager">
            <summary>
                Virtual file system for all disk resources.
            </summary>
        </member>
        <member name="T:Robust.Shared.ContentPack.ResourceManager.DirLoader">
            <summary>
                Holds info about a directory that is mounted in the VFS.
            </summary>
        </member>
        <member name="M:Robust.Shared.ContentPack.ResourceManager.DirLoader.#ctor(System.IO.DirectoryInfo,Robust.Shared.Log.ISawmill,System.Boolean)">
            <summary>
                Constructor.
            </summary>
            <param name="directory">Directory to mount.</param>
            <param name="sawmill"></param>
            <param name="checkCasing"></param>
        </member>
        <member name="M:Robust.Shared.ContentPack.ResourceManager.DirLoader.Mount">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.ContentPack.ResourceManager.DirLoader.TryGetFile(Robust.Shared.Utility.ResPath,System.IO.Stream@)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.ContentPack.ResourceManager.DirLoader.FindFiles(Robust.Shared.Utility.ResPath)">
            <inheritdoc />
        </member>
        <member name="T:Robust.Shared.ContentPack.ResourceManager.PackLoader">
            <summary>
                Loads a zipped content pack into the VFS.
            </summary>
        </member>
        <member name="M:Robust.Shared.ContentPack.ResourceManager.PackLoader.#ctor(System.IO.FileInfo,Robust.Shared.Log.ISawmill)">
            <summary>
                Constructor.
            </summary>
            <param name="pack">The zip file to mount in the VFS.</param>
            <param name="sawmill">Sawmill to use for logging.</param>
        </member>
        <member name="M:Robust.Shared.ContentPack.ResourceManager.PackLoader.Mount">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.ContentPack.ResourceManager.PackLoader.TryGetFile(Robust.Shared.Utility.ResPath,System.IO.Stream@)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.ContentPack.ResourceManager.PackLoader.FindFiles(Robust.Shared.Utility.ResPath)">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.ContentPack.ResourceManager.UserData">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.ContentPack.ResourceManager.Initialize(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.ContentPack.ResourceManager.MountDefaultContentPack">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.ContentPack.ResourceManager.MountContentPack(System.String,System.Nullable{Robust.Shared.Utility.ResPath})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.ContentPack.ResourceManager.MountContentDirectory(System.String,System.Nullable{Robust.Shared.Utility.ResPath})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.ContentPack.ResourceManager.ContentFileRead(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.ContentPack.ResourceManager.ContentFileRead(Robust.Shared.Utility.ResPath)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.ContentPack.ResourceManager.TryContentFileRead(System.String,System.IO.Stream@)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.ContentPack.ResourceManager.TryContentFileRead(System.Nullable{Robust.Shared.Utility.ResPath},System.IO.Stream@)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.ContentPack.ResourceManager.WrapStream(System.IO.Stream)">
            <summary>
            Apply <see cref="F:Robust.Shared.ContentPack.ResourceManager._streamSeekMode"/> to the provided stream.
            </summary>
        </member>
        <member name="M:Robust.Shared.ContentPack.ResourceManager.ContentFileExists(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.ContentPack.ResourceManager.ContentFileExists(Robust.Shared.Utility.ResPath)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.ContentPack.ResourceManager.ContentFindFiles(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.ContentPack.ResourceManager.ContentFindFiles(System.Nullable{Robust.Shared.Utility.ResPath})">
            <inheritdoc />
        </member>
        <member name="T:Robust.Shared.ContentPack.GameClient">
            <summary>
                Entry point for the Content client dll.
            </summary>
        </member>
        <member name="T:Robust.Shared.ContentPack.GameServer">
            <summary>
                Entry point for the Content server dll.
            </summary>
        </member>
        <member name="T:Robust.Shared.ContentPack.GameShared">
            <summary>
                Common entry point for Content assemblies.
            </summary>
        </member>
        <member name="T:Robust.Shared.ContentPack.IContentRoot">
            <summary>
                Common interface for mounting various things in the VFS.
            </summary>
        </member>
        <member name="M:Robust.Shared.ContentPack.IContentRoot.Mount">
            <summary>
                Initializes the content root.
                Throws an exception if the content root failed to mount.
            </summary>
        </member>
        <member name="M:Robust.Shared.ContentPack.IContentRoot.TryGetFile(Robust.Shared.Utility.ResPath,System.IO.Stream@)">
            <summary>
                Gets a file from the content root using the relative path.
            </summary>
            <param name="relPath">Relative path from the root directory.</param>
            <param name="stream"></param>
            <returns>A stream of the file loaded into memory.</returns>
        </member>
        <member name="M:Robust.Shared.ContentPack.IContentRoot.FileExists(Robust.Shared.Utility.ResPath)">
            <summary>
                Returns true if the given file exists.
            </summary>
        </member>
        <member name="M:Robust.Shared.ContentPack.IContentRoot.FindFiles(Robust.Shared.Utility.ResPath)">
            <summary>
                Recursively finds all files in a directory and all sub directories.
            </summary>
            <param name="path">Directory to search inside of.</param>
            <returns>Enumeration of all relative file paths of the files found.</returns>
        </member>
        <member name="M:Robust.Shared.ContentPack.IContentRoot.GetRelativeFilePaths">
            <summary>
                Recursively returns relative paths to resource files.
            </summary>
            <returns>Enumeration of all relative file paths.</returns>
        </member>
        <member name="T:Robust.Shared.ContentPack.IModLoader">
            <summary>
                The mod loader is in charge of loading content assemblies and managing them.
            </summary>
        </member>
        <member name="P:Robust.Shared.ContentPack.IModLoader.LoadedModules">
            <summary>
                All directly loaded content assemblies.
            </summary>
        </member>
        <member name="M:Robust.Shared.ContentPack.IModLoader.SetModuleBaseCallbacks(Robust.Shared.ContentPack.ModuleTestingCallbacks)">
            <summary>
                Adds a testing callbacks that will be passed to <see cref="M:Robust.Shared.ContentPack.GameShared.SetTestingCallbacks(System.Collections.Generic.List{Robust.Shared.ContentPack.ModuleTestingCallbacks})"/>.
            </summary>
        </member>
        <member name="M:Robust.Shared.ContentPack.IModLoaderInternal.TryLoadModulesFrom(Robust.Shared.Utility.ResPath,System.String)">
            <summary>
                Loads all content assemblies from the specified resource directory and filename prefix.
            </summary>
            <param name="mountPath">The directory in which to look for assemblies.</param>
            <param name="filterPrefix">The prefix files need to have to be considered. e.g. <c>Content.</c></param>
            <returns>True if all modules loaded successfully. False if there were load errors.</returns>
        </member>
        <member name="M:Robust.Shared.ContentPack.IModLoaderInternal.TryLoadModules(System.Collections.Generic.IEnumerable{Robust.Shared.Utility.ResPath})">
            <summary>
                Loads all content assemblies given
            </summary>
            <param name="paths">The list of paths to content assemblies that must be loaded.</param>
            <returns>True if all modules loaded successfully. False if there were load errors.</returns>
        </member>
        <member name="M:Robust.Shared.ContentPack.IModLoaderInternal.LoadGameAssembly(System.IO.Stream,System.IO.Stream,System.Boolean)">
            <summary>
                Loads an assembly into the current AppDomain.
            </summary>
            <param name="assembly">Byte array of the assembly.</param>
            <param name="symbols">Optional byte array of the debug symbols.</param>
            <param name="skipVerify">Whether to skip checking the loaded assembly for sandboxing.</param>
        </member>
        <member name="M:Robust.Shared.ContentPack.IModLoaderInternal.LoadGameAssembly(System.String,System.Boolean)">
            <summary>
                Loads an assembly into the current AppDomain.
            </summary>
        </member>
        <member name="M:Robust.Shared.ContentPack.IModLoaderInternal.BroadcastRunLevel(Robust.Shared.ContentPack.ModRunLevel)">
            <summary>
                Broadcasts a run level change to all loaded entry point.
            </summary>
            <param name="level">New level</param>
        </member>
        <member name="M:Robust.Shared.ContentPack.IModLoaderInternal.TryLoadAssembly(System.String)">
            <summary>
                Tries to load an assembly from a resource manager into the current appdomain.
            </summary>
            <param name="assemblyName">File name of the assembly inside of the ./Assemblies folder in the resource manager.</param>
            <returns>If the assembly was successfully located and loaded.</returns>
        </member>
        <member name="T:Robust.Shared.ContentPack.IResourceManager">
            <summary>
                Virtual file system for all disk resources.
            </summary>
        </member>
        <member name="P:Robust.Shared.ContentPack.IResourceManager.UserData">
            <summary>
                Provides access to the writable user data folder.
            </summary>
        </member>
        <member name="M:Robust.Shared.ContentPack.IResourceManager.AddRoot(Robust.Shared.Utility.ResPath,Robust.Shared.ContentPack.IContentRoot)">
            <summary>
                Provides a way to mount a <see cref="T:Robust.Shared.ContentPack.IContentRoot"/> implementation to the VFS.
            </summary>
            <param name="prefix"></param>
            <param name="loader"></param>
        </member>
        <member name="M:Robust.Shared.ContentPack.IResourceManager.ContentFileRead(Robust.Shared.Utility.ResPath)">
            <summary>
                Read a file from the mounted content roots.
            </summary>
            <param name="path">The path to the file in the VFS. Must be rooted.</param>
            <returns>The memory stream of the file.</returns>
            <exception cref="T:System.IO.FileNotFoundException">Thrown if <paramref name="path"/> does not exist in the VFS.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="path"/> is not rooted.</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="path"/> is null.</exception>
            <seealso cref="M:Robust.Shared.ContentPack.ResourceManagerExt.ContentFileReadOrNull(Robust.Shared.ContentPack.IResourceManager,Robust.Shared.Utility.ResPath)"/>
        </member>
        <member name="M:Robust.Shared.ContentPack.IResourceManager.ContentFileRead(System.String)">
            <summary>
                Read a file from the mounted content roots.
            </summary>
            <param name="path">The path to the file in the VFS. Must be rooted.</param>
            <returns>The memory stream of the file.</returns>
            <exception cref="T:System.IO.FileNotFoundException">Thrown if <paramref name="path"/> does not exist in the VFS.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="path"/> is not rooted.</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="path"/> is null.</exception>
        </member>
        <member name="M:Robust.Shared.ContentPack.IResourceManager.ContentFileExists(Robust.Shared.Utility.ResPath)">
            <summary>
                Check if a file exists in any of the mounted content roots.
            </summary>
            <param name="path">The path of the file to check.</param>
            <returns>True if the file exists, false otherwise.</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="path"/> is not rooted.</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="path"/> is null.</exception>
        </member>
        <member name="M:Robust.Shared.ContentPack.IResourceManager.ContentFileExists(System.String)">
            <summary>
                Check if a file exists in any of the mounted content roots.
            </summary>
            <param name="path">The path of the file to check.</param>
            <returns>True if the file exists, false otherwise.</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="path"/> is not rooted.</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="path"/> is null.</exception>
        </member>
        <member name="M:Robust.Shared.ContentPack.IResourceManager.TryContentFileRead(System.Nullable{Robust.Shared.Utility.ResPath},System.IO.Stream@)">
            <summary>
                Try to read a file from the mounted content roots.
            </summary>
            <param name="path">The path of the file to try to read.</param>
            <param name="fileStream">The memory stream of the file's contents. Null if the file could not be loaded.</param>
            <returns>True if the file could be loaded, false otherwise.</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="path"/> is not rooted.</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="path"/> is null.</exception>
            <seealso cref="M:Robust.Shared.ContentPack.ResourceManagerExt.ContentFileReadOrNull(Robust.Shared.ContentPack.IResourceManager,Robust.Shared.Utility.ResPath)"/>
        </member>
        <member name="M:Robust.Shared.ContentPack.IResourceManager.TryContentFileRead(System.String,System.IO.Stream@)">
            <summary>
                Try to read a file from the mounted content roots.
            </summary>
            <param name="path">The path of the file to try to read.</param>
            <param name="fileStream">The memory stream of the file's contents. Null if the file could not be loaded.</param>
            <returns>True if the file could be loaded, false otherwise.</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="path"/> is not rooted.</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="path"/> is null.</exception>
        </member>
        <member name="M:Robust.Shared.ContentPack.IResourceManager.ContentFindFiles(System.Nullable{Robust.Shared.Utility.ResPath})">
            <summary>
                Recursively finds all files in a directory and all sub directories.
            </summary>
            <remarks>
                If the directory does not exist, an empty enumerable is returned.
            </remarks>
            <param name="path">Directory to search inside of.</param>
            <returns>Enumeration of all absolute file paths of the files found.</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="path"/> is not rooted.</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="path"/> is null.</exception>
        </member>
        <member name="M:Robust.Shared.ContentPack.IResourceManager.ContentFindFiles(System.String)">
            <summary>
                Recursively finds all files in a directory and all sub directories.
            </summary>
            <remarks>
                If the directory does not exist, an empty enumerable is returned.
            </remarks>
            <param name="path">Directory to search inside of.</param>
            <returns>Enumeration of all absolute file paths of the files found.</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="path"/> is not rooted.</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="path"/> is null.</exception>
        </member>
        <member name="M:Robust.Shared.ContentPack.IResourceManager.ContentGetDirectoryEntries(Robust.Shared.Utility.ResPath)">
            <summary>
            Gets entries in a content directory.
            </summary>
            <remarks>
            This is not a performant API; the VFS does not work natively with these kinds of directory entries.
            This is intended for development tools such as console command completions,
            not for general-purpose resource management.
            </remarks>
            <param name="path"></param>
            <returns>A sequence of entry names. If the entry name ends in a slash, it's a directory.</returns>
        </member>
        <member name="M:Robust.Shared.ContentPack.IResourceManager.GetContentRoots">
            <summary>
                Returns a list of paths to all top-level content directories
            </summary>
            <returns></returns>
        </member>
        <member name="M:Robust.Shared.ContentPack.IResourceManager.ContentFileReadAllText(System.String)">
            <summary>
                Read a file from the mounted content paths to a string.
            </summary>
            <param name="path">Path of the file to read.</param>
        </member>
        <member name="M:Robust.Shared.ContentPack.IResourceManager.ContentFileReadAllText(Robust.Shared.Utility.ResPath)">
            <summary>
                Read a file from the mounted content paths to a string.
            </summary>
            <param name="path">Path of the file to read.</param>
        </member>
        <member name="M:Robust.Shared.ContentPack.IResourceManager.ContentFileReadAllText(Robust.Shared.Utility.ResPath,System.Text.Encoding)">
            <summary>
                Read a file from the mounted content paths to a string.
            </summary>
            <param name="path">Path of the file to read.</param>
            <param name="encoding">Text encoding to use when reading.</param>
        </member>
        <member name="M:Robust.Shared.ContentPack.IResourceManagerInternal.Initialize(System.String)">
            <summary>
                Sets the manager up so that the base game can run.
            </summary>
            <param name="userData">
            The directory to use for user data.
            If null, a virtual temporary file system is used instead.
            </param>
        </member>
        <member name="M:Robust.Shared.ContentPack.IResourceManagerInternal.MountStreamAt(System.IO.MemoryStream,Robust.Shared.Utility.ResPath)">
            <summary>
                Mounts a single stream as a content file. Useful for unit testing.
            </summary>
            <param name="stream">The stream to mount.</param>
            <param name="path">The path that the file will be mounted at.</param>
        </member>
        <member name="M:Robust.Shared.ContentPack.IResourceManagerInternal.MountDefaultContentPack">
            <summary>
                Loads the default content pack from the configuration file into the VFS.
            </summary>
        </member>
        <member name="M:Robust.Shared.ContentPack.IResourceManagerInternal.MountContentPack(System.String,System.Nullable{Robust.Shared.Utility.ResPath})">
            <summary>
                Loads a content pack from disk into the VFS. The path is relative to
                the executable location on disk.
            </summary>
            <param name="pack">The path of the pack to load on disk.</param>
            <param name="prefix">The resource path to which all files in the pack will be relative to in the VFS.</param>
            <exception cref="T:System.IO.FileNotFoundException">Thrown if <paramref name="pack"/> does not exist on disk.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="prefix"/> is not rooted.</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="pack"/> is null.</exception>
        </member>
        <member name="M:Robust.Shared.ContentPack.IResourceManagerInternal.MountContentDirectory(System.String,System.Nullable{Robust.Shared.Utility.ResPath})">
            <summary>
                Adds a directory to search inside of to the VFS. The directory is relative to
                the executable location on disk.
            </summary>
            <param name="path">The path of the directory to add to the VFS on disk.</param>
            <param name="prefix">The resource path to which all files in the directory will be relative to in the VFS.</param>
            <exception cref="T:System.IO.DirectoryNotFoundException">Thrown if <paramref name="path"/> does not exist on disk.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="prefix"/> passed is not rooted.</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="path"/> is null.</exception>
        </member>
        <member name="M:Robust.Shared.ContentPack.IResourceManagerInternal.TryGetDiskFilePath(Robust.Shared.Utility.ResPath,System.String@)">
            <summary>
                Attempts to get an on-disk path absolute file path for the specified resource path.
            </summary>
            <remarks>
            <para>
                This only works if the resource is mounted as a direct directory,
                so this obviously fails if the resource is mounted in another way such as a zip file.
            </para>
            <para>
                This can be used for optimizations such as assembly loading, where an on-disk path is better.
            </para>
            </remarks>
        </member>
        <member name="T:Robust.Shared.ContentPack.IWritableDirProvider">
            <summary>
            Provides an API for file and directory manipulation inside of a rooted folder.
            </summary>
        </member>
        <member name="P:Robust.Shared.ContentPack.IWritableDirProvider.RootDir">
            <summary>
            The root path of this provider.
            Can be null if it's a virtual provider.
            </summary>
        </member>
        <member name="M:Robust.Shared.ContentPack.IWritableDirProvider.CreateDir(Robust.Shared.Utility.ResPath)">
            <summary>
            Creates a directory. If the directory exists, does nothing.
            </summary>
            <param name="path">Path of directory to create.</param>
        </member>
        <member name="M:Robust.Shared.ContentPack.IWritableDirProvider.Delete(Robust.Shared.Utility.ResPath)">
            <summary>
            Deletes a file or directory. If the file or directory
            does not exist, does nothing.
            </summary>
            <param name="path">Path of object to delete.</param>
        </member>
        <member name="M:Robust.Shared.ContentPack.IWritableDirProvider.Exists(Robust.Shared.Utility.ResPath)">
            <summary>
            Tests if a file or directory exists.
            </summary>
            <param name="path">Path to test.</param>
            <returns>If the object exists.</returns>
        </member>
        <member name="M:Robust.Shared.ContentPack.IWritableDirProvider.Find(System.String,System.Boolean)">
            <summary>
            Finds all files and directories that match the expression. This will include empty directories.
            </summary>
            <param name="pattern"></param>
            <param name="recursive"></param>
            <returns>A tuple that contains collections of files, directories that matched the expression.</returns>
        </member>
        <member name="M:Robust.Shared.ContentPack.IWritableDirProvider.IsDir(Robust.Shared.Utility.ResPath)">
            <summary>
            Tests if a path is a directory.
            </summary>
            <param name="path">Path to test.</param>
            <returns>True if it is a directory, false if it is a file.</returns>
        </member>
        <member name="M:Robust.Shared.ContentPack.IWritableDirProvider.Open(Robust.Shared.Utility.ResPath,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
            <summary>
            Attempts to open a file.
            </summary>
            <param name="path">Path of file to open.</param>
            <param name="fileMode">Options on how to open the file.</param>
            <param name="access">Specifies the operations that can be performed on the file.</param>
            <param name="share">Specifies the access other threads have to the file.</param>
            <returns>A valid file stream.</returns>
            <exception cref="T:System.IO.FileNotFoundException">
                Thrown if the file does not exist.
            </exception>
        </member>
        <member name="M:Robust.Shared.ContentPack.IWritableDirProvider.Open(Robust.Shared.Utility.ResPath,System.IO.FileMode)">
            <summary>
            Attempts to open a file.
            </summary>
            <param name="path">Path of file to open.</param>
            <param name="fileMode">Options on how to open the file.</param>
            <returns>A valid file stream.</returns>
            <exception cref="T:System.IO.FileNotFoundException">
                Thrown if the file does not exist.
            </exception>
        </member>
        <member name="M:Robust.Shared.ContentPack.IWritableDirProvider.OpenSubdirectory(Robust.Shared.Utility.ResPath)">
            <summary>
            Returns a new <see cref="T:Robust.Shared.ContentPack.IWritableDirProvider"/> that points to a subdirectory.
            </summary>
            <param name="path">Path of directory to open.</param>
        </member>
        <member name="M:Robust.Shared.ContentPack.IWritableDirProvider.Rename(Robust.Shared.Utility.ResPath,Robust.Shared.Utility.ResPath)">
            <summary>
            Attempts to rename a file.
            </summary>
            <param name="oldPath">Path of the file to rename.</param>
            <param name="newPath">New name of the file.</param>
            <returns></returns>
        </member>
        <member name="M:Robust.Shared.ContentPack.IWritableDirProvider.OpenOsWindow(Robust.Shared.Utility.ResPath)">
            <summary>
            Opens up an external file window for some subdirectory. For example, this could be used to create a button
            that opens up the screenshot directory using the operating system's file explorer.
            </summary>
        </member>
        <member name="T:Robust.Shared.ContentPack.MemoryContentRoot">
            <summary>
                A content root stored in memory, backed by a dictionary.
            </summary>
        </member>
        <member name="M:Robust.Shared.ContentPack.MemoryContentRoot.AddOrUpdateFile(Robust.Shared.Utility.ResPath,System.Byte[])">
            <summary>
                Adds a file to the content root, or updates it if that path already exists.
            </summary>
            <param name="relPath">The relative path of the file.</param>
            <param name="data">The data byte array to store in the content root. Stored as is, without being copied or cloned.</param>
        </member>
        <member name="M:Robust.Shared.ContentPack.MemoryContentRoot.RemoveFile(Robust.Shared.Utility.ResPath)">
            <summary>
                Remove a file from this content root.
            </summary>
            <param name="relPath">The relative path to the file.</param>
            <returns></returns>
        </member>
        <member name="M:Robust.Shared.ContentPack.MemoryContentRoot.Clear">
            <summary>
                Removes ALL files from this content root.
            </summary>
        </member>
        <member name="M:Robust.Shared.ContentPack.MemoryContentRoot.TryGetFile(Robust.Shared.Utility.ResPath,System.IO.Stream@)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.ContentPack.MemoryContentRoot.FindFiles(Robust.Shared.Utility.ResPath)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.ContentPack.MemoryContentRoot.GetRelativeFilePaths">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.ContentPack.MemoryContentRoot.GetAllFiles">
            <summary>
                Enumerates all files and their resource paths on this content root.
            </summary>
            <remarks>Do not modify or keep around the returned byte array, it's meant to be read-only.</remarks>
        </member>
        <member name="M:Robust.Shared.ContentPack.MemoryContentRoot.Mount">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.ContentPack.MemoryContentRoot.Dispose">
            <inheritdoc />
        </member>
        <member name="T:Robust.Shared.ContentPack.ModLoader">
            <summary>
                Class for managing the loading of assemblies into the engine.
            </summary>
        </member>
        <member name="T:Robust.Shared.ContentPack.ModRunLevel">
            <summary>
                Run levels of the Content entry point.
            </summary>
        </member>
        <member name="T:Robust.Shared.ContentPack.ModuleTestingCallbacks">
            <summary>
                Can be passed to the content entry points via <see cref="M:Robust.Shared.ContentPack.IModLoader.SetModuleBaseCallbacks(Robust.Shared.ContentPack.ModuleTestingCallbacks)"/> and
                <see cref="M:Robust.Shared.ContentPack.GameShared.SetTestingCallbacks(System.Collections.Generic.List{Robust.Shared.ContentPack.ModuleTestingCallbacks})"/>
                to aid in integration testing.
            </summary>
        </member>
        <member name="T:Robust.Shared.ContentPack.ModUpdateLevel">
            <summary>
                Levels at which point the content assemblies are getting updates.
            </summary>
        </member>
        <member name="F:Robust.Shared.ContentPack.ModUpdateLevel.PreEngine">
            <summary>
                This update is called before the main state manager on process frames.
            </summary>
        </member>
        <member name="F:Robust.Shared.ContentPack.ModUpdateLevel.FramePreEngine">
            <summary>
                This update is called before the main state manager on render frames, thus only applies to the client.
            </summary>
        </member>
        <member name="F:Robust.Shared.ContentPack.ModUpdateLevel.PostEngine">
            <summary>
                This update is called after the main state manager on process frames.
            </summary>
        </member>
        <member name="F:Robust.Shared.ContentPack.ModUpdateLevel.FramePostEngine">
            <summary>
                This update is called after the main state manager on render frames, thus only applies to the client.
            </summary>
        </member>
        <member name="F:Robust.Shared.ContentPack.ModUpdateLevel.InputPostEngine">
            <summary>
                Ran after processing network packets and pending asynchronous tasks.
            </summary>
        </member>
        <member name="T:Robust.Shared.ContentPack.PathHelpers">
            <summary>
                Utility functions
            </summary>
        </member>
        <member name="M:Robust.Shared.ContentPack.PathHelpers.GetExecutableDirectory">
            <summary>
                Get the full directory path that the executable is located in.
            </summary>
        </member>
        <member name="M:Robust.Shared.ContentPack.PathHelpers.ExecutableRelativeFile(System.String)">
            <summary>
                Turns a relative path from the executable directory into a full path.
            </summary>
        </member>
        <member name="M:Robust.Shared.ContentPack.PathHelpers.GetFiles(System.String)">
            <summary>
                Recursively gets all files in a directory and all sub directories.
            </summary>
            <param name="path">Directory to start in.</param>
            <returns>Enumerable of all file paths in that directory and sub directories.</returns>
        </member>
        <member name="M:Robust.Shared.ContentPack.ResourceManagerExt.ContentFileReadOrNull(Robust.Shared.ContentPack.IResourceManager,Robust.Shared.Utility.ResPath)">
            <summary>
                Read a file from the mounted content roots, if it exists.
            </summary>
            <param name="res">The resource manager.</param>
            <param name="path">The path to the file in the VFS. Must be rooted.</param>
            <returns>The memory stream of the file, or null if the file does not exist.</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="path"/> is not rooted.</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="path"/> is null.</exception>
            <seealso cref="M:Robust.Shared.ContentPack.IResourceManager.ContentFileRead(Robust.Shared.Utility.ResPath)"/>
            <seealso cref="!:IResourceManager.TryContentFileRead(ResPath, out Stream)"/>
        </member>
        <member name="T:Robust.Shared.ContentPack.SkipIfSandboxedAttribute">
            <summary>
            If defined on an assembly, causes Robust to skip trying to load this assembly if running on sandboxed mode.
            </summary>
            <remarks>
            If you have some sandbox-unsafe code you want to optionally enable for your project,
            you can put the code in a leaf project,
            tag the assembly with this attribute,
            and then detect at runtime whether the assembly was loaded to enable these features.
            </remarks>
        </member>
        <member name="T:Robust.Shared.ContentPack.StreamSeekMode">
            <summary>
            Seekability force mode for ResourceManager.
            </summary>
        </member>
        <member name="F:Robust.Shared.ContentPack.StreamSeekMode.None">
            <summary>
            Do not do anything special. Streams will be seekable if the VFS can provide it (e.g. not compressed).
            </summary>
        </member>
        <member name="F:Robust.Shared.ContentPack.StreamSeekMode.ForceSeekable">
            <summary>
            All streams will be forced as seekable by buffering them in memory if necessary.
            </summary>
        </member>
        <member name="F:Robust.Shared.ContentPack.StreamSeekMode.ForceNonSeekable">
            <summary>
            Force streams to be non-seekable by wrapping them in another stream instances.
            </summary>
        </member>
        <member name="T:Robust.Shared.ContentPack.VirtualWritableDirProvider">
            <summary>
                Writable dir provider that uses an in-memory virtual file system, not the real OS file system.
            </summary>
        </member>
        <member name="P:Robust.Shared.ContentPack.VirtualWritableDirProvider.RootDir">
            <inheritdoc />
        </member>
        <member name="T:Robust.Shared.ContentPack.WritableDirProvider">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.ContentPack.WritableDirProvider.RootDir">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.ContentPack.WritableDirProvider.#ctor(System.IO.DirectoryInfo)">
            <summary>
            Constructs an instance of <see cref="T:Robust.Shared.ContentPack.WritableDirProvider"/>.
            </summary>
            <param name="rootDir">Root file system directory to allow writing.</param>
        </member>
        <member name="M:Robust.Shared.ContentPack.WritableDirProvider.CreateDir(Robust.Shared.Utility.ResPath)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.ContentPack.WritableDirProvider.Delete(Robust.Shared.Utility.ResPath)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.ContentPack.WritableDirProvider.Exists(Robust.Shared.Utility.ResPath)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.ContentPack.WritableDirProvider.Find(System.String,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.ContentPack.WritableDirProvider.IsDir(Robust.Shared.Utility.ResPath)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.ContentPack.WritableDirProvider.Open(Robust.Shared.Utility.ResPath,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.ContentPack.WritableDirProvider.Rename(Robust.Shared.Utility.ResPath,Robust.Shared.Utility.ResPath)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.ContentPack.WritableDirProviderExt.OpenRead(Robust.Shared.ContentPack.IWritableDirProvider,Robust.Shared.Utility.ResPath)">
            <summary>
                Opens a file for reading.
            </summary>
            <param name="provider">The writable directory provider</param>
            <param name="path">The path of the file to open.</param>
            <returns>A valid file stream.</returns>
            <exception cref="T:System.IO.FileNotFoundException">
                Thrown if the file does not exist.
            </exception>
        </member>
        <member name="M:Robust.Shared.ContentPack.WritableDirProviderExt.OpenText(Robust.Shared.ContentPack.IWritableDirProvider,Robust.Shared.Utility.ResPath)">
            <summary>
                Opens a file for reading.
            </summary>
            <param name="provider">The writable directory provider</param>
            <param name="path">The path of the file to open.</param>
            <returns>A valid stream reader.</returns>
            <exception cref="T:System.IO.FileNotFoundException">
                Thrown if the file does not exist.
            </exception>
        </member>
        <member name="M:Robust.Shared.ContentPack.WritableDirProviderExt.OpenWrite(Robust.Shared.ContentPack.IWritableDirProvider,Robust.Shared.Utility.ResPath)">
            <summary>
                Opens a file for writing. If the file already exists, it will be overwritten.
            </summary>
            <param name="provider">The writable directory provider</param>
            <param name="path">The path of the file to open.</param>
            <returns>A valid file stream.</returns>
        </member>
        <member name="M:Robust.Shared.ContentPack.WritableDirProviderExt.OpenWriteText(Robust.Shared.ContentPack.IWritableDirProvider,Robust.Shared.Utility.ResPath)">
            <summary>
                Opens a file for writing. If the file already exists, it will be overwritten.
            </summary>
            <param name="provider">The writable directory provider</param>
            <param name="path">The path of the file to open.</param>
            <returns>A valid file stream writer.</returns>
        </member>
        <member name="M:Robust.Shared.ContentPack.WritableDirProviderExt.AppendAllText(Robust.Shared.ContentPack.IWritableDirProvider,Robust.Shared.Utility.ResPath,System.ReadOnlySpan{System.Char})">
            <summary>
            Appends a string to the end of a file. If the file does not
            exist, creates it.
            </summary>
            <param name="provider">The writable directory provider</param>
            <param name="path">Path of file to append to.</param>
            <param name="content">String to append.</param>
        </member>
        <member name="M:Robust.Shared.ContentPack.WritableDirProviderExt.ReadAllText(Robust.Shared.ContentPack.IWritableDirProvider,Robust.Shared.Utility.ResPath)">
            <summary>
            Reads the entire contents of a file to a string.
            </summary>
            <param name="provider"></param>
            <param name="path">File to read.</param>
            <returns>String of the file contents</returns>
        </member>
        <member name="M:Robust.Shared.ContentPack.WritableDirProviderExt.TryReadAllText(Robust.Shared.ContentPack.IWritableDirProvider,Robust.Shared.Utility.ResPath,System.String@)">
            <summary>
            Reads the entire contents of a path to a string.
            </summary>
            <param name="provider">The writable directory to look for the path in.</param>
            <param name="path">The path to read the contents from.</param>
            <param name="text">The content read from the path, or null if the path did not exist.</param>
            <returns>true if path was successfully read; otherwise, false.</returns>
        </member>
        <member name="M:Robust.Shared.ContentPack.WritableDirProviderExt.ReadAllBytes(Robust.Shared.ContentPack.IWritableDirProvider,Robust.Shared.Utility.ResPath)">
            <summary>
            Reads the entire contents of a path to a byte array.
            </summary>
            <param name="provider">The writable directory to look for the path in.</param>
            <param name="path">The path to read the contents from.</param>
            <returns>The contents of the path as a byte array.</returns>
        </member>
        <member name="M:Robust.Shared.ContentPack.WritableDirProviderExt.WriteAllText(Robust.Shared.ContentPack.IWritableDirProvider,Robust.Shared.Utility.ResPath,System.ReadOnlySpan{System.Char})">
            <summary>
            Writes the content string to a file. If the file exists, its existing contents will
            be replaced.
            </summary>
            <param name="provider">The writable directory provider</param>
            <param name="path">Path of the file to write to.</param>
            <param name="content">String contents of the file.</param>
        </member>
        <member name="M:Robust.Shared.ContentPack.WritableDirProviderExt.WriteAllBytes(Robust.Shared.ContentPack.IWritableDirProvider,Robust.Shared.Utility.ResPath,System.ReadOnlySpan{System.Byte})">
            <summary>
            Writes the sequence of bytes to a file. If the file exists, its existing contents will
            be replaced.
            </summary>
            <param name="provider">The writable directory provider</param>
            <param name="path">Path of the file to write to.</param>
            <param name="content">Bytes to write to the file.</param>
        </member>
        <member name="T:Robust.Shared.CPUJob.JobQueues.Job`1">
            <summary>
                CPU-intensive job that can be suspended and resumed on the main thread
            </summary>
            <remarks>
                Implementations should overload <see cref="M:Robust.Shared.CPUJob.JobQueues.Job`1.Process"/>.
                Inside <see cref="M:Robust.Shared.CPUJob.JobQueues.Job`1.Process"/>, implementations should only await on <see cref="M:Robust.Shared.CPUJob.JobQueues.Job`1.SuspendNow"/>,
                <see cref="M:Robust.Shared.CPUJob.JobQueues.Job`1.SuspendIfOutOfTime"/>, or <see cref="M:Robust.Shared.CPUJob.JobQueues.Job`1.WaitAsyncTask(System.Threading.Tasks.Task)"/>.
            </remarks>
            <typeparam name="T">The type of result this job generates</typeparam>
        </member>
        <member name="P:Robust.Shared.CPUJob.JobQueues.Job`1.AsTask">
            <summary>
                Represents the status of this job as a regular task.
            </summary>
        </member>
        <member name="M:Robust.Shared.CPUJob.JobQueues.Job`1.SuspendNow">
            <summary>
                Suspends the current task immediately, yielding to other running jobs.
            </summary>
            <remarks>
                This does not stop the job queue from un-suspending the current task immediately again,
                if there is still time left over.
            </remarks>
        </member>
        <member name="M:Robust.Shared.CPUJob.JobQueues.Job`1.WaitAsyncTask``1(System.Threading.Tasks.Task{``0})">
            <summary>
                Wrapper to await on an external task.
            </summary>
        </member>
        <member name="M:Robust.Shared.CPUJob.JobQueues.Job`1.WaitAsyncTask(System.Threading.Tasks.Task)">
            <summary>
                Wrapper to safely await on an external task.
            </summary>
        </member>
        <member name="F:Robust.Shared.CPUJob.JobQueues.JobStatus.Pending">
            <summary>
                Job has been created and has not been ran yet.
            </summary>
        </member>
        <member name="F:Robust.Shared.CPUJob.JobQueues.JobStatus.Running">
            <summary>
                Job is currently (yes, right now!) executing.
            </summary>
        </member>
        <member name="F:Robust.Shared.CPUJob.JobQueues.JobStatus.Paused">
            <summary>
                Job is paused due to CPU limits.
            </summary>
        </member>
        <member name="F:Robust.Shared.CPUJob.JobQueues.JobStatus.Waiting">
            <summary>
                Job is paused because of waiting on external task.
            </summary>
        </member>
        <member name="F:Robust.Shared.CPUJob.JobQueues.JobStatus.Finished">
            <summary>
                Job is done.
            </summary>
        </member>
        <member name="P:Robust.Shared.CPUJob.JobQueues.Queues.JobQueue.MaxTime">
            <summary>
            How long the job's allowed to run for before suspending
            </summary>
        </member>
        <member name="T:Robust.Shared.CVarDefaultOverrides">
            <summary>
            Contains some preset CVar overrides applied in the engine to aid development.
            </summary>
        </member>
        <member name="T:Robust.Shared.CVars">
            <seealso cref="T:Robust.Shared.CVarDefaultOverrides"/>
        </member>
        <member name="F:Robust.Shared.CVars.NetMaxConnections">
            <summary>
            Hard max-cap of concurrent connections for the main game networking.
            </summary>
            <remarks>
            This cannot be bypassed in any way, since it is used by Lidgren internally.
            </remarks>
        </member>
        <member name="F:Robust.Shared.CVars.NetPort">
            <summary>
            UDP port to bind to for main game networking.
            Each address specified in <c>net.bindto</c> is bound with this port.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.NetSendBufferSize">
            <summary>
            Send buffer size on the UDP sockets used for main game networking.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.NetReceiveBufferSize">
            <summary>
            Receive buffer size on the UDP sockets used for main game networking.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.NetPoolSize">
            <summary>
            Size of the pool for Lidgren's array buffers to send messages.
            Set to 0 to disable pooling; max is 8192.
            </summary>
            <remarks>
            Higher just means more potentially wasted space and slower pool retrieval.
            </remarks>
        </member>
        <member name="F:Robust.Shared.CVars.NetMtu">
            <summary>
            Maximum UDP payload size to send by default, for IPv4.
            </summary>
            <seealso cref="F:Robust.Shared.CVars.NetMtuExpand"/>
            <seealso cref="F:Robust.Shared.CVars.NetMtuIpv6"/>
        </member>
        <member name="F:Robust.Shared.CVars.NetMtuIpv6">
            <summary>
            Maximum UDP payload size to send by default, for IPv6.
            </summary>
            <seealso cref="F:Robust.Shared.CVars.NetMtu"/>
            <seealso cref="F:Robust.Shared.CVars.NetMtuExpand"/>
        </member>
        <member name="F:Robust.Shared.CVars.NetMtuExpand">
            <summary>
            If set, automatically try to detect MTU above <see cref="F:Robust.Shared.CVars.NetMtu"/>.
            </summary>
            <seealso cref="F:Robust.Shared.CVars.NetMtu"/>
            <seealso cref="F:Robust.Shared.CVars.NetMtuIpv6"/>
            <seealso cref="F:Robust.Shared.CVars.NetMtuExpandFrequency"/>
            <seealso cref="F:Robust.Shared.CVars.NetMtuExpandFailAttempts"/>
        </member>
        <member name="F:Robust.Shared.CVars.NetMtuExpandFrequency">
            <summary>
            Interval between MTU expansion attempts, in seconds.
            </summary>
            <remarks>
            This property is named incorrectly: it is actually an interval, not a frequency.
            The name is chosen to match Lidgren's <see cref="P:Lidgren.Network.NetPeerConfiguration.ExpandMTUFrequency"/>.
            </remarks>
            <seealso cref="F:Robust.Shared.CVars.NetMtuExpand"/>
        </member>
        <member name="F:Robust.Shared.CVars.NetMtuExpandFailAttempts">
            <summary>
            How many times an MTU expansion attempt can fail before settling on a final MTU value.
            </summary>
            <seealso cref="F:Robust.Shared.CVars.NetMtuExpand"/>
        </member>
        <member name="F:Robust.Shared.CVars.NetVerbose">
            <summary>
            Whether to enable verbose debug logging in Lidgren.
            </summary>
            <seealso cref="F:Robust.Shared.CVars.NetMtuExpand"/>
        </member>
        <member name="F:Robust.Shared.CVars.NetBindTo">
            <summary>
            Comma-separated list of IP addresses to bind to for the main game networking port.
            The port bound is the value of <c>net.port</c> always.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.NetDualStack">
            <summary>
            Whether to bind IPv6 sockets in dual-stack mode (for main game networking).
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.NetInterp">
            <summary>
            Whether to interpolate between server game states for render frames on the client.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.NetBufferSize">
            <summary>
            The target number of game states to keep buffered up to smooth out network inconsistency.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.NetMaxBufferSize">
            <summary>
            The maximum size of the game state buffer. If this is exceeded the client will request a full game state.
            Values less than <see cref="!:GameStateProcessor.MinimumMaxBufferSize"/> will be ignored.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.NetLogging">
            <summary>
            Enable verbose game state/networking logging.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.NetPredict">
            <summary>
            Whether prediction is enabled on the client.
            </summary>
            <remarks>
            If off, simulation input commands will not fire and most entity methods will not run update.
            </remarks>
        </member>
        <member name="F:Robust.Shared.CVars.NetPredictTickBias">
            <summary>
            Extra amount of ticks to run-ahead for prediction on the client.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.NetPredictLagBias">
            <summary>
            Extra amount of seconds to run-ahead for prediction on the client.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.NetPVS">
            <summary>
            Whether to cull entities sent to clients from the server.
            If this is on, only entities immediately close to a client will be sent.
            Otherwise, all entities will be sent to all clients.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.NetPvsEntityGrowth">
            <summary>
            Size increments for the automatic growth of Pvs' entity data storage. 0 will increase it by factors of 2
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.NetPvsEntityInitial">
            <summary>
            Initial size of PVS' entity data storage.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.NetPvsEntityMax">
            <summary>
            Maximum ever size of PVS' entity data storage.
            </summary>
            <remarks>
            <para>
            Arbitrarily set to a default of 16 million entities.
            Increasing this parameter does not increase real memory usage, only virtual.
            </para>
            </remarks>
        </member>
        <member name="F:Robust.Shared.CVars.NetPvsAsync">
            <summary>
            If false, this will run more parts of PVS synchronously. This will generally slow it down, can be useful
            for collecting tick timing metrics.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.NetMaxUpdateRange">
            <summary>
            View size to take for PVS calculations, as the size of the sides of a square centered on the view points of
            clients. See also <see cref="F:Robust.Shared.CVars.NetPvsPriorityRange"/>.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.NetPvsPriorityRange">
            <summary>
            A variant of <see cref="F:Robust.Shared.CVars.NetMaxUpdateRange"/> that is used to limit the view-distance of entities with the
            <see cref="F:Robust.Shared.GameObjects.MetaDataFlags.PvsPriority"/> flag set. This can be used to extend the range at which certain
            entities become visible.
            </summary>
            <remarks>
            This is useful for entities like lights and occluders to try and prevent noticeable pop-in as players
            move around. Note that this has no effect if it is less than <see cref="F:Robust.Shared.CVars.NetMaxUpdateRange"/>, and that this
            only works for entities that are directly parented to a grid or map.
            </remarks>
        </member>
        <member name="F:Robust.Shared.CVars.NetForceAckThreshold">
            <summary>
            Maximum allowed delay between the current tick and a client's last acknowledged tick before we send the
            next game state reliably and simply force update the acked tick,
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.NetPVSEntityBudget">
            <summary>
            This limits the number of new entities that can be sent to a client in a single game state. This exists to
            avoid stuttering on the client when it has to spawn a bunch of entities in a single tick. If ever entity
            spawning isn't hot garbage, this can be increased.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.NetPVSEntityEnterBudget">
            <summary>
            This limits the number of entities that can re-enter a client's view in a single game state. This exists to
            avoid stuttering on the client when it has to update the transform of a bunch (700+) of entities in a single
            tick. Ideally this would just be handled client-side somehow.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.NetPVSEntityExitBudget">
            <summary>
            The amount of pvs-exiting entities that a client will process in a single tick.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.NetPvsCompressLevel">
            <summary>
            ZSTD compression level to use when compressing game states. Used by both networking and replays.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.NetLogLateMsg">
            <summary>
            Log late input messages from clients.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.NetTickrate">
            <summary>
            Ticks per second on the server.
            This influences both how frequently game code processes, and how frequently updates are sent to clients.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.NetTimeStartOffset">
            <summary>
            Offset CurTime at server start by this amount (in seconds).
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.ConnectionTimeout">
            <summary>
            How many seconds after the last message from the server before we consider it timed out.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.ResendHandshakeInterval">
            <summary>
            When doing the connection handshake, how long to wait before initial connection attempt packets.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.MaximumHandshakeAttempts">
            <summary>
            When doing the connection handshake, how many times to try sending initial connection attempt packets.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.NetEncrypt">
            <summary>
            If true, encrypt connections when possible.
            </summary>
            <remarks>
            Encryption is currently only possible when the client has authenticated with the auth server.
            </remarks>
        </member>
        <member name="F:Robust.Shared.CVars.NetUPnP">
            <summary>
            If true, use UPnP to automatically forward ports on startup if possible.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.NetLidgrenAppIdentifier">
            <summary>
            App identifier used by Lidgren. This must match between client and server for them to be able to connect.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.NetFakeLoss">
            <summary>
            Add random fake network loss to all outgoing UDP network packets, as a ratio of how many packets to drop.
            0 = no packet loss, 1 = all packets dropped
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.NetFakeLagMin">
            <summary>
            Add fake extra delay to all outgoing UDP network packets, in seconds.
            </summary>
            <seealso cref="F:Robust.Shared.CVars.NetFakeLagRand"/>
        </member>
        <member name="F:Robust.Shared.CVars.NetFakeLagRand">
            <summary>
            Add fake extra random delay to all outgoing UDP network packets, in seconds.
            The actual delay added for each packet is random between 0 and the specified value.
            </summary>
            <seealso cref="F:Robust.Shared.CVars.NetFakeLagMin"/>
        </member>
        <member name="F:Robust.Shared.CVars.NetFakeDuplicates">
            <summary>
            Add random fake duplicates to all outgoing UDP network packets, as a ratio of how many packets to duplicate.
            0 = no packets duplicated, 1 = all packets duplicated.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.NetHappyEyeballsDelay">
            <summary>
            When using Happy Eyeballs to try both IPv6 over IPv4, the delay that IPv4 gets to get less priority.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.NetLidgrenLogWarning">
            <summary>
            Controls whether the networking library will log warning messages.
            </summary>
            <remarks>
            Disabling this should make the networking layer more resilient against some DDoS attacks.
            </remarks>
        </member>
        <member name="F:Robust.Shared.CVars.NetLidgrenLogError">
            <summary>
            Controls whether the networking library will log error messages.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.NetEncryptionThread">
            <summary>
            If true, run network message encryption on another thread.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.NetEncryptionThreadChannelSize">
            <summary>
            Outstanding buffer size used by <see cref="F:Robust.Shared.CVars.NetEncryptionThread"/>.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.SysWinTickPeriod">
            SUS
            <summary>
            If not zero on Windows, the server will sent the tick period for its own process via <c>TimeBeginPeriod</c>.
            This increases polling and sleep precision of the network and main thread,
            but may negatively affect battery life or such.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.SysProfileOpt">
            <summary>
            On non-FULL_RELEASE builds, use ProfileOptimization/tiered JIT to speed up game startup.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.SysGameThreadStackSize">
            <summary>
                Controls stack size of the game logic thread, in bytes.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.SysGameThreadPriority">
            <summary>
                Controls thread priority of the game logic thread.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.SysGCCollectStart">
            <summary>
            Whether to run a <see cref="M:System.GC.Collect"/> operation after the engine is finished initializing.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.SysPreciseSleep">
            <summary>
            Use precise sleeping methods in the game loop.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.MetricsEnabled">
            <summary>
            Whether to enable a prometheus metrics server.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.MetricsHost">
            <summary>
            The IP address to host the metrics server on.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.MetricsPort">
            <summary>
            The port to host the metrics server on.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.MetricsUpdateInterval">
            <summary>
            Sets a fixed interval (seconds) for internal collection of certain metrics,
            when not using the Prometheus metrics server.
            </summary>
            <remarks>
            <para>
            Most metrics are internally implemented directly via the prometheus-net library.
            These metrics can only be scraped by the Prometheus metrics server (<see cref="F:Robust.Shared.CVars.MetricsEnabled"/>).
            However, newer metrics are implemented with the <c>System.Diagnostics.Metrics</c> library in the .NET runtime.
            These metrics can be scraped through more means, such as <c>dotnet counters</c>.
            </para>
            <para>
            While many metrics are simple counters that can "just" be reported,
            some metrics require more advanced internal work and need some code to be ran internally
            before their values are made current. When collecting metrics via a
            method other than the Prometheus metrics server, these metrics pose a problem,
            as there is no way for the game to update them before collection properly.
            </para>
            <para>
            This CVar acts as a fallback: if set to a value other than 0 (disabled),
            these metrics will be internally updated at the interval provided.
            </para>
            <para>
            This does not need to be enabled if metrics are collected exclusively via the Prometheus metrics server.
            </para>
            </remarks>
        </member>
        <member name="F:Robust.Shared.CVars.MetricsRuntime">
            <summary>
            Enable detailed runtime metrics. Empty to disable.
            </summary>
            <remarks>
            Runtime metrics are provided by https://github.com/djluck/prometheus-net.DotNetRuntime.
            Granularity of metrics can be further configured with related CVars.
            </remarks>
        </member>
        <member name="F:Robust.Shared.CVars.MetricsRuntimeGc">
            <summary>
            Mode for runtime GC metrics. Empty to disable.
            </summary>
            <remarks>
            See the documentation for prometheus-net.DotNetRuntime for values and their metrics:
            https://github.com/djluck/prometheus-net.DotNetRuntime/blob/master/docs/metrics-exposed-5.0.md
            </remarks>
        </member>
        <member name="F:Robust.Shared.CVars.MetricsRuntimeGcHistogram">
            <summary>
            Histogram buckets for GC and pause times. Comma-separated list of floats, in milliseconds.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.MetricsRuntimeContention">
            <summary>
            Mode for runtime lock contention metrics. Empty to disable.
            </summary>
            <remarks>
            See the documentation for prometheus-net.DotNetRuntime for values and their metrics:
            https://github.com/djluck/prometheus-net.DotNetRuntime/blob/master/docs/metrics-exposed-5.0.md
            </remarks>
        </member>
        <member name="F:Robust.Shared.CVars.MetricsRuntimeContentionSampleRate">
            <summary>
            Sample lock contention every N events. Higher numbers increase accuracy but also memory use.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.MetricsRuntimeThreadPool">
            <summary>
            Mode for runtime thread pool metrics. Empty to disable.
            </summary>
            <remarks>
            See the documentation for prometheus-net.DotNetRuntime for values and their metrics:
            https://github.com/djluck/prometheus-net.DotNetRuntime/blob/master/docs/metrics-exposed-5.0.md
            </remarks>
        </member>
        <member name="F:Robust.Shared.CVars.MetricsRuntimeThreadPoolQueueHistogram">
            <summary>
            Histogram buckets for thread pool queue length.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.MetricsRuntimeJit">
            <summary>
            Mode for runtime JIT metrics. Empty to disable.
            </summary>
            <remarks>
            See the documentation for prometheus-net.DotNetRuntime for values and their metrics:
            https://github.com/djluck/prometheus-net.DotNetRuntime/blob/master/docs/metrics-exposed-5.0.md
            </remarks>
        </member>
        <member name="F:Robust.Shared.CVars.MetricsRuntimeJitSampleRate">
            <summary>
            Sample JIT every N events. Higher numbers increase accuracy but also memory use.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.MetricsRuntimeException">
            <summary>
            Mode for runtime exception metrics. Empty to disable.
            </summary>
            <remarks>
            See the documentation for prometheus-net.DotNetRuntime for values and their metrics:
            https://github.com/djluck/prometheus-net.DotNetRuntime/blob/master/docs/metrics-exposed-5.0.md
            </remarks>
        </member>
        <member name="F:Robust.Shared.CVars.MetricsRuntimeSocket">
            <summary>
            Mode for runtime TCP socket metrics. Empty to disable.
            </summary>
            <remarks>
            See the documentation for prometheus-net.DotNetRuntime for values and their metrics:
            https://github.com/djluck/prometheus-net.DotNetRuntime/blob/master/docs/metrics-exposed-5.0.md
            </remarks>
        </member>
        <member name="F:Robust.Shared.CVars.StatusEnabled">
            <summary>
            Whether to enable the HTTP status API server.
            </summary>
            <remarks>
            This is necessary for people to be able to connect via the launcher.
            </remarks>
        </member>
        <member name="F:Robust.Shared.CVars.StatusBind">
            <summary>
            Prefix address to bind the HTTP status API server to.
            This is in the form of addr:port, with * serving as a wildcard "all".
            If empty (the default), this is automatically generated to match the UDP ports.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.StatusMaxConnections">
            <summary>
            Max amount of concurrent connections to the HTTP status server.
            Note that this is for actively processing requests, not kept-alive/pooled connections.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.StatusConnectAddress">
            <summary>
            UDP address that should be advertised and the launcher will use to connect to.
            If not set, the launcher will automatically infer this based on the address it already has.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.BuildEngineVersion">
            <summary>
            Engine version that launcher needs to connect to this server.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.BuildForkId">
            <summary>
            Fork ID, as a hint to the launcher to manage local files.
            This can be anything, it does not need a strict format.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.BuildVersion">
            <summary>
            Version string, as a hint to the launcher to manage local files.
            This can be anything, it does not need a strict format.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.BuildDownloadUrl">
            <summary>
            Content pack the launcher should download to connect to this server.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.BuildManifestUrl">
            <summary>
            URL of the content manifest the launcher should download to connect to this server.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.BuildManifestDownloadUrl">
            <summary>
            URL at which the launcher can download the manifest game files.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.BuildHash">
            <summary>
            SHA-256 hash of the content pack hosted at <c>build.download_url</c>
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.BuildManifestHash">
            <summary>
            SHA-256 hash of the manifest hosted at <c>build.manifest_url</c>
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.WatchdogToken">
            <summary>
            API token set by the watchdog to communicate to the server.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.WatchdogKey">
            <summary>
            Watchdog server identifier for this server.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.WatchdogBaseUrl">
            <summary>
            Base URL of the watchdog on the local machine.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.GameMaxPlayers">
            <summary>
            Hard max-cap of concurrent connections for the main game networking.
            </summary>
            <remarks>
            This cannot be bypassed in any way, since it is used by Lidgren internally.
            </remarks>
        </member>
        <member name="F:Robust.Shared.CVars.GameHostName">
            <summary>
            Name of the game server. This shows up in the launcher and potentially parts of the UI.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.GameDesc">
            <summary>
            Description of the game server in the launcher.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.GameDeleteEmptyGrids">
            <summary>
            If a grid is shrunk to include no more tiles should it be deleted.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.GameAutoPauseEmpty">
            <summary>
            Automatically pause simulation if there are no players connected to the game server.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.LogEnabled">
            <summary>
            Write server log to disk.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.LogPath">
            <summary>
            Path to put log files in if log writing is enabled.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.LogFormat">
            <summary>
            Format for individual log files, based on current date and time replacement.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.LogLevel">
            <summary>
            Minimum log level for all server logging.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.LogRuntimeLog">
            <summary>
            Log a separate exception log for all exceptions that occur.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.MaxLightRadius">
            <summary>
            This is the maximum the viewport is enlarged to check for any intersecting render-trees for lights.
            This should be set to your maximum light radius.
            </summary>
            <remarks>
            If this value is too small it just means there may be pop-in where a light is located on a render-tree
            outside of our viewport.
            </remarks>
        </member>
        <member name="F:Robust.Shared.CVars.MaxLightCount">
            <summary>
            Maximum number of lights that the client will draw.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.MaxOccluderCount">
            <summary>
            Maximum number of occluders that the client will draw. Values below 1024 have no effect.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.LightResolutionScale">
            <summary>
            Scale used to modify the horizontal and vertical resolution of lighting framebuffers,
            relative to the viewport framebuffer size.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.MaxShadowcastingLights">
            <summary>
            Maximum amount of shadow-casting lights that can be rendered in a single viewport at once.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.LightSoftShadows">
            <summary>
            Whether to give shadows a soft edge when rendering.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.LightBlur">
            <summary>
            Apply a gaussian blur to the final lighting framebuffer to smoothen it out a little.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.LightBlurFactor">
            <summary>
            Factor by which to blur the lighting framebuffer under <c>light.blur</c>.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.LookupEnlargementRange">
            <summary>
            Like MaxLightRadius this is how far we enlarge lookups to find intersecting components.
            This should be set to your maximum entity size.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.LokiEnabled">
            <summary>
            Whether to send the server log to Grafana Loki.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.LokiName">
            <summary>
            The name of the current server, set as the value of the "Server" label in Loki.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.LokiAddress">
            <summary>
            The address of the Loki server to send to.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.LokiUsername">
            <summary>
            If set, a HTTP Basic auth username to use when talking to Loki.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.LokiPassword">
            <summary>
            If set, a HTTP Basic auth password to use when talking to Loki.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.AuthMode">
            <summary>
            Mode with which to handle authentication on the server.
            See the documentation of the <see cref="T:Robust.Shared.Network.AuthMode"/> enum for values.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.AuthAllowLocal">
            <summary>
            Allow unauthenticated localhost connections, even if the auth mode is set to required.
            These connections have a "localhost@" prefix as username.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.AuthServer">
            <summary>
            Authentication server address.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Robust.Shared.CVars.RenderSpriteDirectionBias" -->
        <member name="F:Robust.Shared.CVars.DoubleClickDelay">
            <summary>
            Milliseconds to wait to consider double-click delays.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.DoubleClickRange">
            <summary>
            Range in pixels for double-clicks
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.DisplayVSync">
            <summary>
            Enable VSync for rendering.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.DisplayWindowMode">
            <summary>
            Window mode for the main game window. 0 = windowed, 1 = fullscreen.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.DisplayWidth">
            <summary>
            Initial width of the game window when running on windowed mode.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.DisplayHeight">
            <summary>
            Initial height of the game window when running on windowed mode.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.DisplayUIScale">
            <summary>
            UI scale for all UI controls. If zero, this value is automatically calculated from the OS.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.DisplayRenderer">
            <summary>
            Which renderer to use to render the game.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.DisplayCompat">
            <summary>
            Whether to use compatibility mode.
            </summary>
            <remarks>
            This can change certain behaviors like GL version selection to try to avoid driver crashes/bugs.
            </remarks>
        </member>
        <member name="F:Robust.Shared.CVars.DisplayOpenGLVersion">
            <summary>
            Which OpenGL version to use for the OpenGL renderer.
            Values correspond to the (private) RendererOpenGLVersion enum in Clyde.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.DisplayAngle">
            <summary>
            On Windows, use ANGLE as OpenGL implementation.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.DisplayAngleCustomSwapChain">
            <summary>
            Use a custom DXGI swap chain when using ANGLE.
            Should improve performance and fixes main window sRGB handling with ANGLE.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.DisplayAngleForceEs2">
            <summary>
            Force ANGLE to create a GLES2 context (not a compatible GLES3 context).
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.DisplayAngleForce10_0">
            <summary>
            Force ANGLE to create a context from a D3D11 FL 10_0 device.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.DisplayAngleDxgi1">
            <summary>
            Force usage of DXGI 1.1 when using custom swap chain setup.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.DisplayAdapter">
            <summary>
            Try to use the display adapter with this name, if the current renderer supports selecting it.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.DisplayGpuPreference">
            <summary>
            What type of GPU to prefer when creating a graphics context, for things such as hybrid GPU laptops.
            </summary>
            <remarks>
            This setting is not always respect depending on platform and rendering API used.
            Values are:
            0 = unspecified (DXGI_GPU_PREFERENCE_UNSPECIFIED)
            1 = minimum power (DXGI_GPU_PREFERENCE_MINIMUM_POWER)
            2 = high performance (DXGI_GPU_PREFERENCE_HIGH_PERFORMANCE)
            </remarks>
        </member>
        <member name="F:Robust.Shared.CVars.DisplayEgl">
            <summary>
            Use EGL to create GL context instead of GLFW, if possible.
            </summary>
            <remarks>
            This only tries to use EGL if on a platform like X11 or Windows (w/ ANGLE) where it is possible.
            </remarks>
        </member>
        <member name="F:Robust.Shared.CVars.DisplayAngleEs3On10_0">
            <summary>
            Enable allowES3OnFL10_0 on ANGLE.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.DisplayFontDpi">
            <summary>
            Base DPI to render fonts at. This can be further scaled based on <c>display.uiScale</c>.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.DisplayOGLOverrideVersion">
            <summary>
            Override detected OpenGL version, for testing.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.DisplayOGLCheckErrors">
            <summary>
            Run <c>glCheckError()</c> after (almost) every GL call.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.DisplayForceSyncWindows">
            <summary>
                Forces synchronization of multi-window rendering with <c>glFinish</c> when GL fence sync is unavailable.
            </summary>
            <remarks>
                If this is disabled multi-window rendering on GLES2 might run better, dunno.
                It technically causes UB thanks to the OpenGL spec with cross-context sync. Hope that won't happen.
                Let's be real the OpenGL specification is basically just a suggestion to drivers anyways so who cares.
            </remarks>
        </member>
        <member name="F:Robust.Shared.CVars.DisplayThreadWindowBlit">
            <summary>
            Use a separate thread for multi-window blitting.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.DisplayInputBufferSize">
            <summary>
            Buffer size of input command channel from windowing thread to main game thread.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.DisplayWin32Experience">
            <summary>
            Insert stupid performance hitches into the windowing thread, to test how the game thread handles it.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.DisplayWindowIconSet">
            <summary>
            The window icon set to use. Overriden by <c>GameControllerOptions</c> on startup.
            </summary>
            <remarks>
            Dynamically changing this does nothing.
            </remarks>
        </member>
        <member name="F:Robust.Shared.CVars.DisplaySplashLogo">
            <summary>
            The splash logo to use. Overriden by <c>GameControllerOptions</c> on startup.
            </summary>
            <remarks>
            Dynamically changing this does nothing.
            </remarks>
        </member>
        <member name="F:Robust.Shared.CVars.DisplayUSQWERTYHotkeys">
            <summary>
            Use US QWERTY hotkeys for reported key names.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.DisplayWin11ImmersiveDarkMode">
            <summary>
            If true and on Windows 11 Build 22000,
            specify <c>DWMWA_USE_IMMERSIVE_DARK_MODE</c> to have dark mode window titles if the system is set to dark mode.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.DisplayThreadWindowApi">
            <summary>
            If true, run the windowing system in another thread from the game thread.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.AudioDefaultConcurrent">
            <summary>
            Default limit for concurrently playing an audio file.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.AudioDevice">
            <summary>
            Audio device to try to output audio to by default.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.AudioMasterVolume">
            <summary>
            Master volume for audio output.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.AudioRaycastLength">
            <summary>
            Maximum raycast distance for audio occlusion.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.AudioTickRate">
            <summary>
            Tickrate for audio calculations.
            OpenAL recommends 30TPS. This is to avoid running raycasts every frame especially for high-refresh rate monitors.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.PlayerName">
            <summary>
            Player name to send from user, if not overriden by a myriad of factors.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.BroadphaseExpand">
            <summary>
            How much to expand broadphase checking for. This is useful for cross-grid collisions.
            Performance impact if additional broadphases are being checked.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.TargetMinimumTickrate">
            <summary>
            The target minimum ticks per second on the server.
            This is used for substepping and will help with clipping/physics issues and such.
            Ideally 50-60 is the minimum.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.GenerateGridFixtures">
            <summary>
            I'ma be real with you: the only reason this exists is to get tests working.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.GridSplitting">
            <summary>
            Can grids split if not connected by cardinals
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.GridFixtureEnlargement">
            <summary>
            How much to enlarge grids when determining their fixture bounds.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.VelocityThreshold">
            <summary>
            A velocity threshold for elastic collisions. Any collision with a relative linear
            velocity below this threshold will be treated as inelastic.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.Baumgarte">
            <summary>
                How much overlap is resolved per tick.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.MaxLinVelocity">
            <summary>
            Maximum linear velocity per second.
            Make sure that MaxLinVelocity / <see cref="F:Robust.Shared.CVars.NetTickrate"/> is around 0.5 or higher so that moving objects don't go through walls.
            MaxLinVelocity is compared to the dot product of linearVelocity * frameTime.
            </summary>
            <remarks>
            Default is 35 m/s. Around half a tile per tick at 60 ticks per second.
            </remarks>
        </member>
        <member name="F:Robust.Shared.CVars.MaxAngVelocity">
            <summary>
            Maximum angular velocity in full rotations per second.
            MaxAngVelocity is compared to the squared rotation.
            </summary>
            <remarks>
            Default is 15 rotations per second. Approximately a quarter rotation per tick at 60 ticks per second.
            </remarks>
        </member>
        <member name="F:Robust.Shared.CVars.InterfaceTheme">
            <summary>
            Change the UITheme
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.InterfaceAudio">
            <summary>
            Should UI have audio at all.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.ResAutoScaleUpperX">
             <summary>
            Minimum resolution to start clamping autoscale to 1
             </summary>
        </member>
        <member name="F:Robust.Shared.CVars.ResAutoScaleUpperY">
             <summary>
            Minimum resolution to start clamping autoscale to 1
             </summary>
        </member>
        <member name="F:Robust.Shared.CVars.ResAutoScaleLowX">
             <summary>
            Maximum resolution to start clamping autos scale to autoscale minimum
             </summary>
        </member>
        <member name="F:Robust.Shared.CVars.ResAutoScaleLowY">
             <summary>
            Maximum resolution to start clamping autos scale to autoscale minimum
             </summary>
        </member>
        <member name="F:Robust.Shared.CVars.ResAutoScaleMin">
            <summary>
            The minimum ui scale value that autoscale will scale to
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.ResAutoScaleEnabled">
             <summary>
            Enable the UI autoscale system on this control, this will scale down the UI for lower resolutions
             </summary>
        </member>
        <member name="F:Robust.Shared.CVars.DiscordEnabled">
            <summary>
            Enable Discord rich presence integration.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.ResCheckPathCasing">
            <summary>
            Verify that resource path capitalization is correct, even on case-insensitive file systems such as Windows.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.ResTexturePreloadingEnabled">
            <summary>
            Preload all textures at client startup to avoid hitches at runtime.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.ResRSIAtlasSize">
            <summary>
            Upper limit on the size of the RSI atlas texture. A lower limit might waste less vram, but start to defeat
            the purpose of using an atlas if it gets too small.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.ResTexturePreloadCache">
            <summary>
            Cache texture preload data to speed things up even further.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.ResStreamSeekMode">
            <summary>
            Override seekability of resource streams returned by ResourceManager.
            See <see cref="T:Robust.Shared.ContentPack.StreamSeekMode"/> for int values.
            </summary>
            <remarks>
            This is intended to be a debugging tool primarily.
            Non-default seek modes WILL result in worse performance.
            </remarks>
        </member>
        <member name="F:Robust.Shared.CVars.ResPrototypeReloadWatch">
            <summary>
            Whether to watch prototype files for prototype reload on the client. Only applies to development builds.
            </summary>
            <remarks>
            The client sends a reload signal to the server on refocus, if you're wondering why this is client-only.
            </remarks>
        </member>
        <member name="F:Robust.Shared.CVars.ResCheckBadFileExtensions">
            <summary>
            If true, do a warning check at startup for probably-erroneous file extensions like <c>.yaml</c> in resources.
            </summary>
            <remarks>
            This check is always skipped on <c>FULL_RELEASE</c>.
            </remarks>
        </member>
        <member name="F:Robust.Shared.CVars.DebugTargetFps">
            <summary>
                Target framerate for things like the frame graph.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.MidiParallelism">
            <summary>
            Controls amount of CPU cores and (by extension) polyphony for Fluidsynth.
            </summary>
            <remarks>
            You probably don't want to set this to be multithreaded, the way Fluidsynth's multithreading works is
            probably worse-than-nothing for Robust's usage.
            </remarks>
        </member>
        <member name="F:Robust.Shared.CVars.HubAdvertise">
            <summary>
            Whether to advertise this server to the public server hub.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.HubTags">
            <summary>
            Comma-separated list of tags to advertise via the status server (and therefore, to the hub).
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.HubUrls">
            <summary>
            Comma-separated list of URLs of hub servers to advertise to.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.HubServerUrl">
            <summary>
            URL of this server to advertise.
            This is automatically inferred by the hub server based on IP address if left empty,
            but if you want to specify a domain or use <c>ss14://</c> you should specify this manually.
            You also have to set this if you change status.bind.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.HubIpifyUrl">
            <summary>
            URL to use to automatically try to detect IPv4 address.
            This is only used if hub.server_url is unset.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.HubAdvertiseInterval">
            <summary>
            How long to wait between advertise pings to the hub server.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.AczStreamCompress">
            <summary>
            Whether to use stream compression instead of per-file compression when transmitting ACZ data.
            Enabling stream compression significantly reduces bandwidth usage of downloads,
            but increases server and launcher CPU load. It also makes final files stored on the client compressed less.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.AczStreamCompressLevel">
            <summary>
            ZSTD Compression level to use when doing ACZ stream compressed.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.AczBlobCompress">
            <summary>
            Whether to do compression on individual files for ACZ downloads.
            Automatically forced off if stream compression is enabled.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.AczBlobCompressLevel">
            <summary>
            ZSTD Compression level to use for individual file compression.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.AczBlobCompressSaveThreshold">
            <summary>
            Amount of bytes that need to be saved by compression for the compression to be "worth it".
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.AczManifestCompress">
            <summary>
            Whether to ZSTD compress the ACZ manifest.
            If this is enabled (the default) then non-compressed manifest requests will be decompressed live.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.AczManifestCompressLevel">
            <summary>
            Compression level for ACZ manifest compression.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.ConCompletionDelay">
            <summary>
            Add artificial delay (in seconds) to console completion fetching, even for local commands.
            </summary>
            <remarks>
            Intended for debugging the console completion system.
            </remarks>
        </member>
        <member name="F:Robust.Shared.CVars.ConCompletionCount">
            <summary>
            The amount of completions to show in console completion drop downs.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.ConCompletionMargin">
            <summary>
            The minimum margin of options to keep on either side of the completion cursor, when scrolling through.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.ConMaxEntries">
            <summary>
            Maximum amount of entries stored by the debug console.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.ThreadParallelCount">
            <summary>
            The nominal parallel processing count to use for parallelized operations.
            The default of 0 automatically selects the system's processor count.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.ProfEnabled">
            <summary>
            Enabled the profiling system.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.ProfBufferSize">
            <summary>
            Event log buffer size for the profiling system.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.ProfIndexSize">
            <summary>
            Index log buffer size for the profiling system.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.ReplayDirectory">
            <summary>
            A relative path pointing to a folder within the server data directory where all replays will be stored.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.ReplayMaxCompressedSize">
            <summary>
            Maximum compressed size of a replay recording (in kilobytes) before recording automatically stops.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.ReplayMaxUncompressedSize">
            <summary>
            Maximum uncompressed size of a replay recording (in kilobytes) before recording automatically stops.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.ReplayTickBatchSize">
            <summary>
            Uncompressed size of individual files created by the replay (in kilobytes), where each file contains data
            for one or more ticks. Actual files may be slightly larger, this is just a threshold for the file to get
            written. After compressing, the files are generally ~30% of their uncompressed size.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.ReplayWriteChannelSize">
            <summary>
            The max amount of pending write commands while recording replays.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.ReplayServerRecordingEnabled">
            <summary>
            Whether or not server-side replay recording is enabled.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.ReplayClientRecordingEnabled">
            <summary>
            Whether or not client-side replay recording is enabled.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.ReplayMaxScrubTime">
            <summary>
            How many milliseconds we will spend moving forward from the nearest checkpoint or current position.
            We will spend this time when scrubbing the timeline per game tick. This limits CPU usage / locking up and
            improves responsiveness
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.ReplaySkipThreshold">
            <summary>
            Determines the threshold before visual events (muzzle flashes, chat pop-ups, etc) are suppressed when
            jumping forward in time. Jumps larger than this will simply skip directly to the target tick.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.CheckpointMinInterval">
            <summary>
            Minimum number of ticks before a new checkpoint tick is generated (overrides SpawnThreshold and StateThreshold)
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.CheckpointInterval">
            <summary>
            Maximum number of ticks before a new checkpoint tick is generated.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.CheckpointEntitySpawnThreshold">
            <summary>
            Maximum number of entities that can be spawned before a new checkpoint tick is generated.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.CheckpointEntityStateThreshold">
            <summary>
            Maximum number of entity states that can be applied before a new checkpoint tick is generated.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.ReplayDynamicalScrubbing">
            <summary>
            Whether or not to constantly apply game states while using something like a slider to scrub through replays.
            If false, this will only jump to a point in time when the scrubbing ends.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.ReplayMakeContentBundle">
            <summary>
            When recording replays, should we attempt to make a valid content bundle that can be directly executed by
            the launcher?
            </summary>
            <remarks>
            This requires the server's build information to be sufficiently filled out.
            </remarks>
        </member>
        <member name="F:Robust.Shared.CVars.ReplayIgnoreErrors">
            <summary>
            If true, this will cause the replay client to ignore some errors while loading a replay file.
            </summary>
            <remarks>
            This might make otherwise broken replays playable, but ignoring these errors is also very likely to
            cause unexpected and confusing errors elsewhere. By default this is disabled so that users report the
            original exception rather than sending people on a wild-goose chase to find a non-existent bug.
            </remarks>
        </member>
        <member name="F:Robust.Shared.CVars.CfgCheckUnused">
            <summary>
            If set, check for any unknown CVars once the game is initialized to try the spot any unknown ones.
            </summary>
            <remarks>
            CVars can be dynamically registered instead of just being statically known ahead of time,
            so the engine is not capable of immediately telling if a CVar is a typo or such.
            This check after game initialization assumes all CVars have been registered,
            and will complain if anything unknown is found (probably indicating a typo of some kind).
            </remarks>
        </member>
        <member name="F:Robust.Shared.CVars.ResourceUploadingEnabled">
            <summary>
            Controls whether new resources can be uploaded by admins.
            Does not prevent already uploaded resources from being sent.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.ResourceUploadingLimitMb">
            <summary>
            Controls the data size limit in megabytes for uploaded resources. If they're too big, they will be dropped.
            Set to zero or a negative value to disable limit.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.LaunchLauncher">
            <summary>
            Game was launched from the launcher.
            </summary>
            <remarks>
            The game should not try to automatically connect to a server, there's other variables for that.
            </remarks>
        </member>
        <member name="F:Robust.Shared.CVars.LaunchContentBundle">
            <summary>
            Game was launched from a content bundle.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.ToolshedNearbyLimit">
            <summary>
                The max range that can be passed to the nearby toolshed command.
                Any higher value will cause an exception.
            </summary>
        </member>
        <member name="F:Robust.Shared.CVars.ToolshedNearbyEntitiesLimit">
            <summary>
                The max amount of entities that can be passed to the nearby toolshed command.
                Any higher value will cause an exception.
            </summary>
        </member>
        <member name="M:Robust.Shared.Debugging.SharedDebugRayDrawingSystem.ReceiveLocalRayFromAnyThread(Robust.Shared.Debugging.SharedDebugRayDrawingSystem.DebugRayData)">
            <summary>
            Receives locally sourced ray debug information.
            This may be called on any thread.
            </summary>
        </member>
        <member name="M:Robust.Shared.Debugging.SharedDebugRayDrawingSystem.ReceiveLocalRayAtMainThread(Robust.Shared.Debugging.SharedDebugRayDrawingSystem.DebugRayData)">
            <summary>
            Receives locally sourced ray debug information.
            This is only called at the main thread.
            Note that on release builds (!DEBUG), this function is never called.
            </summary>
        </member>
        <member name="T:Robust.Shared.Enums.Gender">
            <summary>
                Represents a grammatical gender of an object.
            </summary>
        </member>
        <member name="F:Robust.Shared.Enums.Gender.Neuter">
            <summary>
                Object has no gender and a gender probably makes no sense. Think inanimate objects. It/it.
            </summary>
        </member>
        <member name="F:Robust.Shared.Enums.Gender.Epicene">
            <summary>
                Object is something you would consider as *capable of having a gender*, but *doesn't*.
                Think people without (visible/unambiguous) gender. They/them.
            </summary>
        </member>
        <member name="F:Robust.Shared.Enums.Gender.Female">
            <summary>
                Female gender. She/her
            </summary>
        </member>
        <member name="F:Robust.Shared.Enums.Gender.Male">
            <summary>
                Male gender. He/his
            </summary>
        </member>
        <member name="T:Robust.Shared.Enums.OverlaySpace">
            <summary>
                Determines in which canvas layers an overlay gets drawn.
            </summary>
        </member>
        <member name="F:Robust.Shared.Enums.OverlaySpace.None">
            <summary>
                Used for matching bit flags.
            </summary>
        </member>
        <member name="F:Robust.Shared.Enums.OverlaySpace.ScreenSpace">
            <summary>
                This overlay will be drawn in screen coordinates in the UI space above the world.
            </summary>
        </member>
        <member name="F:Robust.Shared.Enums.OverlaySpace.WorldSpace">
            <summary>
                This overlay will be drawn above entities, lighting, and FOV.
            </summary>
        </member>
        <member name="F:Robust.Shared.Enums.OverlaySpace.WorldSpaceBelowFOV">
            <summary>
                This overlay will be drawn beneath FOV and lighting, but above entities.
            </summary>
        </member>
        <member name="F:Robust.Shared.Enums.OverlaySpace.WorldSpaceEntities">
            <summary>
                This overlay will be along with entities, with the order depending on overlay's ZOrder and sprite's
                DrawDepth.
            </summary>
        </member>
        <member name="F:Robust.Shared.Enums.OverlaySpace.WorldSpaceGrids">
            <summary>
                Drawn after every grid.
            </summary>
        </member>
        <member name="F:Robust.Shared.Enums.OverlaySpace.WorldSpaceBelowEntities">
            <summary>
                This overlay will be drawn beneath entities, lighting, and FOV; above grids.
            </summary>
        </member>
        <member name="F:Robust.Shared.Enums.OverlaySpace.ScreenSpaceBelowWorld">
            <summary>
                This overlay will be drawn in screen coordinates behind the world.
            </summary>
        </member>
        <member name="F:Robust.Shared.Enums.OverlaySpace.WorldSpaceBelowWorld">
            <summary>
                Overlay will be rendered below grids, entities, and everything else. In world space.
            </summary>
        </member>
        <member name="P:Robust.Shared.Enums.PlacementInformation.EntityType">
            <summary>
            Entity prototype to be placed
            </summary>
        </member>
        <member name="P:Robust.Shared.Enums.PlacementInformation.IsTile">
            <summary>
            Indiciates if the entity prototype to be placed is in fact a tile
            </summary>
        </member>
        <member name="P:Robust.Shared.Enums.PlacementInformation.MobUid">
            <summary>
            ID of the mob that has permission to place the prototype
            </summary>
        </member>
        <member name="P:Robust.Shared.Enums.PlacementInformation.PlacementOption">
            <summary>
            Specifies the placement alignment
            </summary>
        </member>
        <member name="P:Robust.Shared.Enums.PlacementInformation.Range">
            <summary>
            Determines the max range at which the entity prototype can be placed
            </summary>
        </member>
        <member name="P:Robust.Shared.Enums.PlacementInformation.TileType">
            <summary>
            
            </summary>
        </member>
        <member name="P:Robust.Shared.Enums.PlacementInformation.Uses">
            <summary>
            Number of times the entity can be placed
            </summary>
        </member>
        <member name="P:Robust.Shared.Enums.PlacementInformation.UseEditorContext">
            <summary>
            Sets whether the input context should switch to 'editor' mode
            </summary>
        </member>
        <member name="T:Robust.Shared.Exceptions.IRuntimeLog">
            <summary>
                The runtime log is responsible for the logging of exceptions, to prevent the game crashing entirely.
            </summary>
            <remarks>
                The term "runtime" dates back to BYOND, in which an exception is called a "runtime error".
                As such, what we call exceptions is called a "runtime" in BYOND.
            </remarks>
        </member>
        <member name="T:Robust.Shared.Exceptions.TypeArgumentException">
            <summary>
            Thrown if a method is called with an invalid type argument.
            For example <see cref="M:Robust.Shared.IoC.IoCManager.Register``2(System.Boolean)"/> with an abstract <code>TImplementation</code>.
            </summary>
        </member>
        <member name="F:Robust.Shared.Exceptions.TypeArgumentException.TypeArgumentName">
            <summary>
            The name of the type argument that had invalid data.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.Component">
            <inheritdoc cref="T:Robust.Shared.GameObjects.IComponent"/>
        </member>
        <member name="P:Robust.Shared.GameObjects.Component.NetSyncEnabled">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.GameObjects.Component.Owner">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.GameObjects.Component.Initialized">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.GameObjects.Component.Running">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.GameObjects.Component.Deleted">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.GameObjects.Component.CreationTick">
            <summary>
                This is the tick the component was created.
            </summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.Component.LastModifiedTick">
            <summary>
                Marks the component as dirty so that the network will re-sync it with clients.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.Component.Dirty(Robust.Shared.GameObjects.IEntityManager)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.Component.InternalCopy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.Component.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.Component.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.Component.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.Component.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.Component.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Shared.GameObjects.ComponentLifeStage">
            <summary>
            The life stages of an ECS component.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.ComponentLifeStage.PreAdd">
            <summary>
            The component has just been allocated.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.ComponentLifeStage.Adding">
            <summary>
            Currently being added to an entity.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.ComponentLifeStage.Added">
            <summary>
            Has been added to an entity.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.ComponentLifeStage.Initializing">
            <summary>
            Currently being initialized.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.ComponentLifeStage.Initialized">
            <summary>
            Has been initialized.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.ComponentLifeStage.Starting">
            <summary>
            Currently being started up.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.ComponentLifeStage.Running">
            <summary>
            Has started up.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.ComponentLifeStage.Stopping">
            <summary>
            Currently shutting down.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.ComponentLifeStage.Stopped">
            <summary>
            Has been shut down.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.ComponentLifeStage.Removing">
            <summary>
            Currently being removed from its entity.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.ComponentLifeStage.Deleted">
            <summary>
            Removed from its entity, and is deleted.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.ComponentAdd">
            <summary>
            WARNING: Do not subscribe to this unless you know what you are doing!
            The component has been added to the entity. This is the first function
            to be called after the component has been allocated and (optionally) deserialized.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.ComponentInit">
            <summary>
            Raised when all of the entity's other components have been added and are available,
            But are not necessarily initialized yet. DO NOT depend on the values of other components to be correct.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.ComponentStartup">
            <summary>
            Starts up a component. This is called automatically after all components are Initialized and the entity is Initialized.
            This can be called multiple times during the component's life, and at any time.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.ComponentShutdown">
            <summary>
            Shuts down the component. The is called Automatically by OnRemove. This can be called multiple times during
            the component's life, and at any time.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.ComponentRemove">
            <summary>
            The component has been removed from the entity. This is the last function
            that is called before the component is freed.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.RegisterComponentAttribute">
            <summary>
                Marks a component as being automatically registered by <see cref="M:Robust.Shared.GameObjects.IComponentFactory.DoAutoRegistrations" />
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.ComponentProtoNameAttribute">
            <summary>
            Defines Name that this component is represented with in prototypes.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.ComponentProtoNameAttribute.#ctor(System.String)">
            <summary>
            Defines Name that this component is represented with in prototypes.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.UnsavedComponentAttribute">
            <summary>
            Marks a component as not being saved when saving maps/grids.
            </summary>
            <seealso cref="P:Robust.Shared.GameObjects.ComponentRegistration.Unsaved"/>
        </member>
        <member name="T:Robust.Shared.GameObjects.ComponentEventArgs">
            <summary>
            Arguments for an event related to a component.
            </summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.ComponentEventArgs.Component">
            <summary>
            Component that this event relates to.
            </summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.ComponentEventArgs.Owner">
            <summary>
            EntityUid of the entity this component belongs to.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.ComponentEventArgs.#ctor(Robust.Shared.GameObjects.IComponent,Robust.Shared.GameObjects.EntityUid)">
            <summary>
            Constructs a new instance of <see cref="T:Robust.Shared.GameObjects.ComponentEventArgs"/>.
            </summary>
            <param name="component">The relevant component</param>
            <param name="owner">EntityUid of the entity this component belongs to.</param>
        </member>
        <member name="F:Robust.Shared.GameObjects.ComponentFactory._names">
            <summary>
            Mapping of component name to type.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.ComponentFactory._lowerCaseNames">
            <summary>
            Mapping of lowercase component names to their registration.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.ComponentFactory._networkedComponents">
            <summary>
            Mapping of network ID to type.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.ComponentFactory._types">
            <summary>
            Mapping of concrete component types to their registration.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.ComponentFactory._ignoreMissingComponentPostfix">
            <summary>
            Any component name requested that ends with this postfix, and is missing
            will be treated as ignored, instead of throwing an error
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.ComponentFactory._ignored">
            <summary>
            Set of components that should be ignored. Probably just the list of components unique to the other project.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.ComponentFactory._typeToIdx">
            <summary>
            Slow-path for Type -> CompIdx mapping without generics.
            </summary>
        </member>
        <member name="E:Robust.Shared.GameObjects.ComponentFactory.ComponentsAdded">
            <inheritdoc />
        </member>
        <member name="E:Robust.Shared.GameObjects.ComponentFactory.ComponentIgnoreAdded">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.GameObjects.ComponentFactory.AllRegisteredTypes">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.GameObjects.ComponentFactory.NetworkedComponents">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.ComponentFactory.GetIndex(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.ComponentFactory.GetArrayIndex(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.ComponentFactory.RegisterClass``1(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.ComponentFactory.RegisterTypes(System.Type[])">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.ComponentFactory.GenerateNetIds">
            <inheritdoc />
        </member>
        <member name="T:Robust.Shared.GameObjects.ComponentRegistration">
            <summary>
            Represents a component registered into a <see cref="T:Robust.Shared.GameObjects.IComponentFactory" />.
            </summary>
            <seealso cref="T:Robust.Shared.GameObjects.IComponentFactory" />
            <seealso cref="T:Robust.Shared.GameObjects.IComponent" />
        </member>
        <member name="P:Robust.Shared.GameObjects.ComponentRegistration.Name">
            <summary>
            The name of the component.
            This is used as the <c>type</c> field in the component declarations if entity prototypes.
            </summary>
            <seealso cref="!:IComponent.Name" />
        </member>
        <member name="P:Robust.Shared.GameObjects.ComponentRegistration.Unsaved">
            <summary>
            If this is true, the component will not be saved when saving a map/grid.
            </summary>
            <seealso cref="T:Robust.Shared.GameObjects.UnsavedComponentAttribute"/>
        </member>
        <member name="P:Robust.Shared.GameObjects.ComponentRegistration.NetID">
            <summary>
            ID used to reference the component type across the network.
            If null, no network synchronization will be available for this component.
            </summary>
            <seealso cref="T:Robust.Shared.GameStates.NetworkedComponentAttribute" />
        </member>
        <member name="P:Robust.Shared.GameObjects.ComponentRegistration.Type">
            <summary>
            The type that will be instantiated if this component is created.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.IComponentState">
            <summary>
            Represents the state of a component for networking purposes.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.IComponentDeltaState`1">
            <summary>
            Interface for component states that only contain partial state data. The actual delta state class should be a
            separate class from the full component states.
            </summary>
            <typeparam name="TState">The full-state class associated with this partial state</typeparam>
        </member>
        <member name="M:Robust.Shared.GameObjects.IComponentDeltaState`1.ApplyToFullState(`0)">
            <summary>
            This function will apply the current delta state to the provided full state, modifying it in the process.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IComponentDeltaState`1.CreateNewFullState(`0)">
            <summary>
            This function should take in a full state and return a new full state with the current delta applied, WITHOUT
            modifying the original input state.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.AppearanceComponent">
            <summary>
                The appearance component allows game logic to be more detached from the actual visuals of an entity such as 2D
                sprites, 3D, particles, lights...
                It does this with a "data" system. Basically, code writes data to the component, and the component will use
                prototype-based configuration to change the actual visuals.
                The data works using a simple key/value system. It is recommended to use enum keys to prevent errors.
                Visualization works client side with derivatives of the <see cref="!:Robust.Client.GameObjects.VisualizerSystem">VisualizerSystem</see> class and corresponding components.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.AppearanceComponent.AppearanceDirty">
            <summary>
            Whether or not the appearance needs to be updated.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.AppearanceComponent.UpdateQueued">
            <summary>
            If true, this entity will have its appearance updated in the next frame update.
            </summary>
            <remarks>
            If an entity is outside of PVS range, this may be false while <see cref="F:Robust.Shared.GameObjects.AppearanceComponent.AppearanceDirty"/> is true.
            </remarks>
        </member>
        <member name="P:Robust.Shared.GameObjects.AppearanceComponent.AppearanceDataInit">
            <summary>
            Sets starting values for AppearanceData.
            </summary>
            <remarks>
            Should only be filled in via prototype .yaml; subsequent data must be set via SharedAppearanceSystem.SetData().
            </remarks>
        </member>
        <member name="M:Robust.Shared.GameObjects.AppearanceComponent.InternalCopy(Robust.Shared.GameObjects.AppearanceComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.AppearanceComponent.Copy(Robust.Shared.GameObjects.AppearanceComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.AppearanceComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.AppearanceComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.AppearanceComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.AppearanceComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.AppearanceComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.ScaleVisualsComponent.InternalCopy(Robust.Shared.GameObjects.ScaleVisualsComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.ScaleVisualsComponent.Copy(Robust.Shared.GameObjects.ScaleVisualsComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.ScaleVisualsComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.ScaleVisualsComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.ScaleVisualsComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.ScaleVisualsComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.ScaleVisualsComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Shared.GameObjects.CollideOnAnchorComponent">
            <summary>
            A component that toggles collision on an entity being toggled.
            </summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.CollideOnAnchorComponent.Enable">
            <summary>
            Whether we toggle collision on or off when anchoring (and vice versa when unanchoring).
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.CollideOnAnchorComponent.InternalCopy(Robust.Shared.GameObjects.CollideOnAnchorComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.CollideOnAnchorComponent.Copy(Robust.Shared.GameObjects.CollideOnAnchorComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.CollideOnAnchorComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.CollideOnAnchorComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.CollideOnAnchorComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.CollideOnAnchorComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.CollideOnAnchorComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Shared.GameObjects.CollisionWakeComponent">
            <summary>
                An optimisation component for stuff that should be set as collidable when it's awake and non-collidable when asleep.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.CollisionWakeComponent.InternalCopy(Robust.Shared.GameObjects.CollisionWakeComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.CollisionWakeComponent.Copy(Robust.Shared.GameObjects.CollisionWakeComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.CollisionWakeComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.CollisionWakeComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.CollisionWakeComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.CollisionWakeComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.CollisionWakeComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Shared.GameObjects.DebugExceptionOnAddComponent">
            <summary>
            Throws an exception in <see cref="!:OnAdd" />.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.DebugExceptionOnAddComponent.InternalCopy(Robust.Shared.GameObjects.DebugExceptionOnAddComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.DebugExceptionOnAddComponent.Copy(Robust.Shared.GameObjects.DebugExceptionOnAddComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.DebugExceptionOnAddComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.DebugExceptionOnAddComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.DebugExceptionOnAddComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.DebugExceptionOnAddComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.DebugExceptionOnAddComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Shared.GameObjects.DebugExceptionInitializeComponent">
            <summary>
            Throws an exception in <see cref="!:Initialize" />.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.DebugExceptionInitializeComponent.InternalCopy(Robust.Shared.GameObjects.DebugExceptionInitializeComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.DebugExceptionInitializeComponent.Copy(Robust.Shared.GameObjects.DebugExceptionInitializeComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.DebugExceptionInitializeComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.DebugExceptionInitializeComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.DebugExceptionInitializeComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.DebugExceptionInitializeComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.DebugExceptionInitializeComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Shared.GameObjects.DebugExceptionStartupComponent">
            <summary>
            Throws an exception in <see cref="!:Startup" />.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.DebugExceptionStartupComponent.InternalCopy(Robust.Shared.GameObjects.DebugExceptionStartupComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.DebugExceptionStartupComponent.Copy(Robust.Shared.GameObjects.DebugExceptionStartupComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.DebugExceptionStartupComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.DebugExceptionStartupComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.DebugExceptionStartupComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.DebugExceptionStartupComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.DebugExceptionStartupComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="F:Robust.Shared.GameObjects.EyeComponent.Target">
            <summary>
                If not null, this entity is used to update the eye's position instead of just using the component's owner.
            </summary>
            <remarks>
                This is useful for things like vehicles that effectively need to hijack the eye. This allows them to do
                that without messing with the main viewport's eye. This is important as there are some overlays that are
                only be drawn if that viewport's eye belongs to the currently controlled entity.
            </remarks>
        </member>
        <member name="F:Robust.Shared.GameObjects.EyeComponent.Offset">
            <summary>
            Eye offset, relative to the map, and not affected by <see cref="F:Robust.Shared.GameObjects.EyeComponent.Rotation"/>
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.EyeComponent.VisibilityMask">
            <summary>
                The visibility mask for this eye.
                The player will be able to get updates for entities whose layers match the mask.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.EyeComponent.PvsScale">
            <summary>
            Scaling factor for the PVS view range of this eye. This effectively allows the
            <see cref="F:Robust.Shared.CVars.NetMaxUpdateRange"/> and <see cref="F:Robust.Shared.CVars.NetPvsPriorityRange"/> cvars to be configured per
            eye.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EyeComponent.InternalCopy(Robust.Shared.GameObjects.EyeComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.EyeComponent.Copy(Robust.Shared.GameObjects.EyeComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.EyeComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.EyeComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.EyeComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.EyeComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.EyeComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Shared.GameObjects.VisibilityMaskLayer">
            <summary>
            Single layer used for Eye visibility. Controls what entities they are allowed to see.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.ViewSubscriberComponent.InternalCopy(Robust.Shared.GameObjects.ViewSubscriberComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.ViewSubscriberComponent.Copy(Robust.Shared.GameObjects.ViewSubscriberComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.ViewSubscriberComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.ViewSubscriberComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.ViewSubscriberComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.ViewSubscriberComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.ViewSubscriberComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.OccluderComponent.InternalCopy(Robust.Shared.GameObjects.OccluderComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.OccluderComponent.Copy(Robust.Shared.GameObjects.OccluderComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.OccluderComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.OccluderComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.OccluderComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.OccluderComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.OccluderComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Shared.GameObjects.OccluderTreeComponent">
            <summary>
            Stores the relevant occluder children of this entity.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.OccluderTreeComponent.InternalCopy(Robust.Shared.GameObjects.OccluderTreeComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.OccluderTreeComponent.Copy(Robust.Shared.GameObjects.OccluderTreeComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.OccluderTreeComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.OccluderTreeComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.OccluderTreeComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.OccluderTreeComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.OccluderTreeComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="F:Robust.Shared.GameObjects.SharedPointLightComponent.Offset">
            <summary>
            Offset from the center of the entity.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.SharedPointLightComponent.CastShadows">
            <summary>
                Whether this pointlight should cast shadows
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.SharedPointLightComponent.Radius">
            <summary>
            How far the light projects.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.SharedPointLightComponent.MaskAutoRotate">
            <summary>
                Determines if the light mask should automatically rotate with the entity. (like a flashlight)
            </summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.SharedPointLightComponent.Rotation">
            <summary>
                Local rotation of the light mask around the center origin
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.SharedPointLightComponent.MaskPath">
            <summary>
            The resource path to the mask texture the light will use.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedPointLightComponent.InternalCopy(Robust.Shared.GameObjects.SharedPointLightComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedPointLightComponent.Copy(Robust.Shared.GameObjects.SharedPointLightComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedPointLightComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedPointLightComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedPointLightComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedPointLightComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedPointLightComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Shared.GameObjects.AttemptPointLightToggleEvent">
            <summary>
            Raised directed on an entity when attempting to enable / disable it.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.AttemptPointLightToggleEvent.#ctor(System.Boolean)">
            <summary>
            Raised directed on an entity when attempting to enable / disable it.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.Components.Localization.GrammarComponent">
            <summary>
                Overrides grammar attributes specified in prototypes or localization files.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.Components.Localization.GrammarComponent.InternalCopy(Robust.Shared.GameObjects.Components.Localization.GrammarComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.Components.Localization.GrammarComponent.Copy(Robust.Shared.GameObjects.Components.Localization.GrammarComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.Components.Localization.GrammarComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.Components.Localization.GrammarComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.Components.Localization.GrammarComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.Components.Localization.GrammarComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.Components.Localization.GrammarComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Shared.GameObjects.MetaDataComponentState">
            <summary>
                Serialized state of a <see cref="T:Robust.Shared.GameObjects.MetaDataComponent"/>.
            </summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.MetaDataComponentState.Name">
            <summary>
                The in-game name of this entity.
            </summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.MetaDataComponentState.Description">
            <summary>
                The in-game description of this entity.
            </summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.MetaDataComponentState.PrototypeId">
            <summary>
                The prototype this entity was created from, if any.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.MetaDataComponentState.PauseTime">
            <summary>
                When this entity was paused.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.MetaDataComponentState.#ctor(System.String,System.String,System.String,System.Nullable{System.TimeSpan})">
            <summary>
                Constructs a new instance of <see cref="T:Robust.Shared.GameObjects.MetaDataComponentState"/>.
            </summary>
            <param name="name">The in-game name of this entity.</param>
            <param name="description">The in-game description of this entity.</param>
            <param name="prototypeId">The prototype this entity was created from, if any.</param>
            <param name="pauseTime">When this entity was paused.</param>
        </member>
        <member name="T:Robust.Shared.GameObjects.MetaDataComponent">
            <summary>
                Contains meta data about this entity that isn't component specific.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.MetaDataComponent.NetComponents">
            <summary>
            The components attached to the entity that are currently networked.
            </summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.MetaDataComponent.NetEntity">
            <summary>
            Network identifier for this entity.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.MetaDataComponent.PauseTime">
            <summary>
            When this entity was paused, if applicable. Note that this is the actual time, not the duration which gets
            returned by <see cref="M:Robust.Shared.GameObjects.MetaDataSystem.GetPauseTime(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)"/>.
            </summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.MetaDataComponent.LastStateApplied">
            <summary>
                This is the tick at which the client last applied state data received from the server.
            </summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.MetaDataComponent.LastComponentRemoved">
            <summary>
                This is the most recent tick at which a networked component was removed from this entity.
                Currently only reliable server-side, client side prediction may cause the value to be wrong.
            </summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.MetaDataComponent.EntityName">
            <summary>
                The in-game name of this entity.
            </summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.MetaDataComponent.EntityDescription">
            <summary>
                The in-game description of this entity.
            </summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.MetaDataComponent.EntityPrototype">
            <summary>
                The prototype this entity was created from, if any.
            </summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.MetaDataComponent.EntityLifeStage">
            <summary>
                The current lifetime stage of this entity. You can use this to check
                if the entity is initialized or being deleted.
            </summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.MetaDataComponent.VisibilityMask">
            <summary>
                The sum of our visibility layer and our parent's visibility layers.
            </summary>
            <remarks>
                Every entity will always have the first bit set to true.
            </remarks>
        </member>
        <member name="F:Robust.Shared.GameObjects.MetaDataComponent.LastPvsLocation">
            <summary>
            The PVS chunk that this entity is currently stored on.
            This should always be set properly if the entity is directly attached to a grid or map.
            If it is null, it implies that either:
            - The entity nested is somewhere in some chunk that has already been marked as dirty
            - The entity is in nullspace
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.MetaDataComponent.PvsData">
            <summary>
            Offset into internal PVS data.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.MetaDataComponent.InternalCopy(Robust.Shared.GameObjects.MetaDataComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.MetaDataComponent.Copy(Robust.Shared.GameObjects.MetaDataComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.MetaDataComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.MetaDataComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.MetaDataComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.MetaDataComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.MetaDataComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="F:Robust.Shared.GameObjects.MetaDataFlags.SessionSpecific">
            <summary>
            Whether the entity has any component that has state information specific to particular players.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.MetaDataFlags.InContainer">
            <summary>
            Whether the entity is currently inside of a container.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.MetaDataFlags.Detached">
            <summary>
            Used by clients to indicate that an entity has left their visible set.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.MetaDataFlags.Undetachable">
            <summary>
            Indicates this entity can never be handled by the client as PVS detached.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.MetaDataFlags.PvsPriority">
            <summary>
            If true, then this entity is considered a "high priority" entity and will be sent to players from further
            away. Useful for things like light sources and occluders. Only works if the entity is directly parented to
            a grid or map.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.PvsChunkLocation">
            <summary>
            Key struct for uniquely identifying a PVS chunk.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.PvsChunkLocation.#ctor(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Maths.Vector2i)">
            <summary>
            Key struct for uniquely identifying a PVS chunk.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.PvsIndex">
            <summary>
            An opaque index into the PVS data arrays on the server.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.PvsIndex.#ctor(System.Int32)">
            <summary>
            An opaque index into the PVS data arrays on the server.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.PvsIndex.Invalid">
            <summary>
            An invalid index. This is also used as a marker value in the free list.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.PrototypeLayerData.Shader">
            <summary>
            The shader prototype to use for this layer.
            </summary>
            <remarks>
            Null implies no shader is specified. An empty string will clear the current shader.
            </remarks>
        </member>
        <member name="F:Robust.Shared.GameObjects.PrototypeLayerData.CopyToShaderParameters">
            <summary>
            If set, indicates that this sprite layer should instead be used to copy into shader parameters on another layer.
            </summary>
            <remarks>
            <para>
            If set, this sprite layer is not rendered. Instead, the "result" of rendering it (exact sprite layer and such)
            are copied into the shader parameters of another object,
            specified by the <see cref="T:Robust.Shared.GameObjects.PrototypeCopyToShaderParameters"/>.
            </para>
            <para>
            The specified layer must have a shader set. When it does, the shader's
            </para>
            <para>
            Note that sprite layers are processed in-order, so to avoid 1-frame delays,
            the layer doing the copying should occur BEFORE the layer being copied into.
            </para>
            </remarks>
        </member>
        <member name="M:Robust.Shared.GameObjects.PrototypeLayerData.InternalCopy(Robust.Shared.GameObjects.PrototypeLayerData@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.PrototypeLayerData.Copy(Robust.Shared.GameObjects.PrototypeLayerData@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.PrototypeLayerData.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.PrototypeLayerData.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Shared.GameObjects.PrototypeCopyToShaderParameters">
            <summary>
            Stores parameters for <see cref="F:Robust.Shared.GameObjects.PrototypeLayerData.CopyToShaderParameters"/>.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.PrototypeCopyToShaderParameters.LayerKey">
            <summary>
            The map key of the layer that will have its shader modified.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.PrototypeCopyToShaderParameters.ParameterTexture">
            <summary>
            The name of the shader parameter that will receive the actual selected texture.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.PrototypeCopyToShaderParameters.ParameterUV">
            <summary>
            The name of the shader parameter that will receive UVs to select the sprite in <see cref="F:Robust.Shared.GameObjects.PrototypeCopyToShaderParameters.ParameterTexture"/>.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.PrototypeCopyToShaderParameters.InternalCopy(Robust.Shared.GameObjects.PrototypeCopyToShaderParameters@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.PrototypeCopyToShaderParameters.Copy(Robust.Shared.GameObjects.PrototypeCopyToShaderParameters@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.PrototypeCopyToShaderParameters.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.PrototypeCopyToShaderParameters.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Shared.GameObjects.SyncSpriteComponent">
            <summary>
            Synchronise the auto-animated layers of the sprite to real time;
            this is useful if you require multiple entities to have synchronised animations.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SyncSpriteComponent.InternalCopy(Robust.Shared.GameObjects.SyncSpriteComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.SyncSpriteComponent.Copy(Robust.Shared.GameObjects.SyncSpriteComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.SyncSpriteComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.SyncSpriteComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.SyncSpriteComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.SyncSpriteComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.SyncSpriteComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="P:Robust.Shared.GameObjects.TimerComponent.RemoveOnEmpty">
            <summary>
            Should this component be removed when no more timers are running?
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.TimerComponent.Delay(System.Int32,System.Threading.CancellationToken)">
            <summary>
                Creates a task that will complete after a given delay.
                The task is resumed on the main game logic thread.
            </summary>
            <param name="milliseconds">The length of time, in milliseconds, to delay for.</param>
            <param name="cancellationToken"></param>
            <returns>The task that can be awaited.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.TimerComponent.Delay(System.TimeSpan,System.Threading.CancellationToken)">
            <summary>
                Creates a task that will complete after a given delay.
                The task is resumed on the main game logic thread.
            </summary>
            <param name="duration">The length of time to delay for.</param>
            <param name="cancellationToken"></param>
            <returns>The task that can be awaited.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.TimerComponent.Spawn(System.Int32,System.Action,System.Threading.CancellationToken)">
            <summary>
                Schedule an action to be fired after a certain delay.
                The action will be resumed on the main game logic thread.
            </summary>
            <param name="milliseconds">The length of time, in milliseconds, to wait before firing the action.</param>
            <param name="onFired">The action to fire.</param>
            <param name="cancellationToken"></param>
        </member>
        <member name="M:Robust.Shared.GameObjects.TimerComponent.Spawn(System.TimeSpan,System.Action,System.Threading.CancellationToken)">
            <summary>
                Schedule an action to be fired after a certain delay.
                The action will be resumed on the main game logic thread.
            </summary>
            <param name="duration">The length of time, to wait before firing the action.</param>
            <param name="onFired">The action to fire.</param>
            <param name="cancellationToken"></param>
        </member>
        <member name="M:Robust.Shared.GameObjects.TimerComponent.SpawnRepeating(System.Int32,System.Action,System.Threading.CancellationToken)">
            <summary>
                Schedule an action that repeatedly fires after a delay specified in milliseconds.
            </summary>
            <param name="milliseconds">The length of time, in milliseconds, to delay before firing the repeated action.</param>
            <param name="onFired">The action to fire.</param>
            <param name="cancellationToken">The CancellationToken for stopping the Timer.</param>
        </member>
        <member name="M:Robust.Shared.GameObjects.TimerComponent.SpawnRepeating(System.TimeSpan,System.Action,System.Threading.CancellationToken)">
            <summary>
                Schedule an action that repeatedly fires after a delay.
            </summary>
            <param name="duration">The length of time to delay before firing the repeated action.</param>
            <param name="onFired">The action to fire.</param>
            <param name="cancellationToken">The CancellationToken for stopping the Timer.</param>
        </member>
        <member name="M:Robust.Shared.GameObjects.TimerComponent.InternalCopy(Robust.Shared.GameObjects.TimerComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.TimerComponent.Copy(Robust.Shared.GameObjects.TimerComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.TimerComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.TimerComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.TimerComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.TimerComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.TimerComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.TimerExtensions.DelayTask(Robust.Shared.GameObjects.EntityUid,System.Int32,System.Threading.CancellationToken)">
            <summary>
                Creates a task that will complete after a given delay.
                The task is resumed on the main game logic thread.
            </summary>
            <param name="entity">The entity to add the timer to.</param>
            <param name="milliseconds">The length of time, in milliseconds, to delay for.</param>
            <param name="cancellationToken"></param>
            <returns>The task that can be awaited.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.TimerExtensions.DelayTask(Robust.Shared.GameObjects.EntityUid,System.TimeSpan,System.Threading.CancellationToken)">
            <summary>
                Creates a task that will complete after a given delay.
                The task is resumed on the main game logic thread.
            </summary>
            <param name="entity">The entity to add the timer to.</param>
            <param name="duration">The length of time to delay for.</param>
            <param name="cancellationToken"></param>
            <returns>The task that can be awaited.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.TimerExtensions.SpawnTimer(Robust.Shared.GameObjects.EntityUid,System.Int32,System.Action,System.Threading.CancellationToken)">
            <summary>
                Schedule an action to be fired after a certain delay.
                The action will be resumed on the main game logic thread.
            </summary>
            <param name="entity">The entity to add the timer to.</param>
            <param name="milliseconds">The length of time, in milliseconds, to wait before firing the action.</param>
            <param name="onFired">The action to fire.</param>
            <param name="cancellationToken"></param>
        </member>
        <member name="M:Robust.Shared.GameObjects.TimerExtensions.SpawnTimer(Robust.Shared.GameObjects.EntityUid,System.TimeSpan,System.Action,System.Threading.CancellationToken)">
            <summary>
                Schedule an action to be fired after a certain delay.
                The action will be resumed on the main game logic thread.
            </summary>
            <param name="entity">The entity to add the timer to.</param>
            <param name="duration">The length of time, to wait before firing the action.</param>
            <param name="onFired">The action to fire.</param>
            <param name="cancellationToken"></param>
        </member>
        <member name="M:Robust.Shared.GameObjects.TimerExtensions.SpawnRepeatingTimer(Robust.Shared.GameObjects.EntityUid,System.Int32,System.Action,System.Threading.CancellationToken)">
            <summary>
                Schedule an action that repeatedly fires after a delay specified in milliseconds.
            </summary>
            <param name="entity">The entity to add the timer to.</param>
            <param name="milliseconds">The length of time, in milliseconds, to delay before firing the repeated action.</param>
            <param name="onFired">The action to fire.</param>
            <param name="cancellationToken">The CancellationToken for stopping the Timer.</param>
        </member>
        <member name="M:Robust.Shared.GameObjects.TimerExtensions.SpawnRepeatingTimer(Robust.Shared.GameObjects.EntityUid,System.TimeSpan,System.Action,System.Threading.CancellationToken)">
            <summary>
                Schedule an action that repeatedly fires after a delay.
            </summary>
            <param name="entity">The entity to add the timer to.</param>
            <param name="duration">The length of time to delay before firing the repeated action.</param>
            <param name="onFired">The action to fire.</param>
            <param name="cancellationToken">The CancellationToken for stopping the Timer.</param>
        </member>
        <member name="T:Robust.Shared.GameObjects.TransformComponent">
            <summary>
                Stores the position and orientation of the entity.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.TransformComponent.GridTraversal">
            <summary>
            Indicates this entity can traverse grids.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.TransformComponent.Broadphase">
            <summary>
                The broadphase that this entity is currently stored on, if any.
            </summary>
            <remarks>
                Maybe this should be moved to its own component eventually, but at least currently comps are not structs
                and this data is required whenever any entity moves, so this will just save a component lookup.
            </remarks>
        </member>
        <member name="P:Robust.Shared.GameObjects.TransformComponent.MapID">
            <summary>
                Returns the index of the map which this object is on
            </summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.TransformComponent.MapUid">
            <summary>
                The EntityUid of the map which this object is on, if any.
            </summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.TransformComponent.GridUid">
            <summary>
                The EntityUid of the grid which this object is on, if any.
            </summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.TransformComponent.NoLocalRotation">
            <summary>
                Disables or enables to ability to locally rotate the entity. When set it removes any local rotation.
            </summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.TransformComponent.LocalRotation">
            <summary>
                Current rotation offset of the entity.
            </summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.TransformComponent.WorldRotation">
            <summary>
                Current world rotation of the entity.
            </summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.TransformComponent.ParentUid">
            <summary>
            The UID of the parent entity that this entity is attached to.
            </summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.TransformComponent.WorldMatrix">
            <summary>
                Matrix for transforming points from local to world space.
            </summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.TransformComponent.InvWorldMatrix">
            <summary>
                Matrix for transforming points from world to local space.
            </summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.TransformComponent.WorldPosition">
            <summary>
                Current position offset of the entity relative to the world.
                Can de-parent from its parent if the parent is a grid.
            </summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.TransformComponent.Coordinates">
            <summary>
                Position offset of this entity relative to its parent.
            </summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.TransformComponent.MapPosition">
            <summary>
                Current position offset of the entity relative to the world.
                This is effectively a more complete version of <see cref="P:Robust.Shared.GameObjects.TransformComponent.WorldPosition"/>
            </summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.TransformComponent.LocalPosition">
            <summary>
                Local offset of this entity relative to its parent
                (<see cref="!:Parent"/> if it's not null, to <see cref="P:Robust.Shared.GameObjects.TransformComponent.GridUid"/> otherwise).
            </summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.TransformComponent.Anchored">
            <summary>
            Is this transform anchored to a grid tile?
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.TransformComponent.AttachToGridOrMap">
            <summary>
            Detaches this entity from its parent.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.TransformComponent.AttachParent(Robust.Shared.GameObjects.TransformComponent)">
            <summary>
            Sets another entity as the parent entity, maintaining world position.
            </summary>
            <param name="newParent"></param>
        </member>
        <member name="M:Robust.Shared.GameObjects.TransformComponent.GetWorldPositionRotation">
            <summary>
            Get the WorldPosition and WorldRotation of this entity faster than each individually.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.TransformComponent.GetWorldPositionRotation(Robust.Shared.GameObjects.EntityQuery{Robust.Shared.GameObjects.TransformComponent})">
            <see cref="M:Robust.Shared.GameObjects.TransformComponent.GetWorldPositionRotation"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.TransformComponent.GetWorldPositionRotationMatrix(Robust.Shared.GameObjects.EntityQuery{Robust.Shared.GameObjects.TransformComponent})">
            <summary>
            Get the WorldPosition, WorldRotation, and WorldMatrix of this entity faster than each individually.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.TransformComponent.GetWorldPositionRotationMatrix">
            <summary>
            Get the WorldPosition, WorldRotation, and WorldMatrix of this entity faster than each individually.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.TransformComponent.GetWorldPositionRotationInvMatrix">
            <summary>
            Get the WorldPosition, WorldRotation, and InvWorldMatrix of this entity faster than each individually.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.TransformComponent.GetWorldPositionRotationInvMatrix(Robust.Shared.GameObjects.EntityQuery{Robust.Shared.GameObjects.TransformComponent})">
            <summary>
            Get the WorldPosition, WorldRotation, and InvWorldMatrix of this entity faster than each individually.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.TransformComponent.GetWorldPositionRotationMatrixWithInv">
            <summary>
            Get the WorldPosition, WorldRotation, WorldMatrix, and InvWorldMatrix of this entity faster than each individually.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.TransformComponent.GetWorldPositionRotationMatrixWithInv(Robust.Shared.GameObjects.EntityQuery{Robust.Shared.GameObjects.TransformComponent})">
            <summary>
            Get the WorldPosition, WorldRotation, WorldMatrix, and InvWorldMatrix of this entity faster than each individually.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.TransformComponent.InternalCopy(Robust.Shared.GameObjects.TransformComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.TransformComponent.Copy(Robust.Shared.GameObjects.TransformComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.TransformComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.TransformComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.TransformComponent.InternalCopy(Robust.Shared.GameObjects.IComponentDebug@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.TransformComponent.Copy(Robust.Shared.GameObjects.IComponentDebug@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.TransformComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.TransformComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.TransformComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Shared.GameObjects.MoveEvent">
            <summary>
            Raised directed at an entity whenever is position or rotation changes relative to their parent, or if their
            parent changed. Note that this event does not get broadcast. If you need to receive information about ALL
            move events, subscribe to the <see cref="E:Robust.Shared.GameObjects.SharedTransformSystem.OnGlobalMoveEvent"/>.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.MoveEvent.#ctor(Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.TransformComponent,Robust.Shared.GameObjects.MetaDataComponent},Robust.Shared.Map.EntityCoordinates,Robust.Shared.Map.EntityCoordinates,Robust.Shared.Maths.Angle,Robust.Shared.Maths.Angle)">
            <summary>
            Raised directed at an entity whenever is position or rotation changes relative to their parent, or if their
            parent changed. Note that this event does not get broadcast. If you need to receive information about ALL
            move events, subscribe to the <see cref="E:Robust.Shared.GameObjects.SharedTransformSystem.OnGlobalMoveEvent"/>.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.AnchorStateChangedEvent">
            <summary>
            Raised when the Anchor state of the transform is changed.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.AnchorStateChangedEvent.#ctor(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.TransformComponent,System.Boolean)">
            <summary>
            Raised when the Anchor state of the transform is changed.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.AnchorStateChangedEvent.Detaching">
            <summary>
                If true, the entity is being detached to null-space
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.ReAnchorEvent">
            <summary>
            Raised when an entity is re-anchored to another grid.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.ReAnchorEvent.TilePos">
            <summary>
            Tile on both the old and new grid being re-anchored.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.BroadphaseData">
            <summary>
                Data used to store information about the broad-phase that any given entity is currently on.
            </summary>
            <remarks>
                A null value means that this entity is simply not on a broadphase (e.g., in null-space or in a container).
                An invalid entity UID indicates that this entity has intentionally been removed from broadphases and should
                not automatically be re-added by movement events.
            </remarks>
        </member>
        <member name="M:Robust.Shared.GameObjects.BroadphaseData.#ctor(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.EntityUid,System.Boolean,System.Boolean)">
            <summary>
                Data used to store information about the broad-phase that any given entity is currently on.
            </summary>
            <remarks>
                A null value means that this entity is simply not on a broadphase (e.g., in null-space or in a container).
                An invalid entity UID indicates that this entity has intentionally been removed from broadphases and should
                not automatically be re-added by movement events.
            </remarks>
        </member>
        <member name="T:Robust.Shared.GameObjects.BoundUserInterface">
            <summary>
                An abstract class to override to implement bound user interfaces.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.BoundUserInterface.Disposals">
            <summary>
            Additional controls to be disposed when this BUI is disposed.
            </summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.BoundUserInterface.State">
            <summary>
                The last received state object sent from the server.
            </summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.BoundUserInterface.DeferredClose">
            <summary>
            Defers state handling
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.BoundUserInterface.Open">
            <summary>
                Invoked when the UI is opened.
                Do all creation and opening of things like windows in here.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.BoundUserInterface.UpdateState(Robust.Shared.GameObjects.BoundUserInterfaceState)">
            <summary>
                Invoked when the server uses <c>SetState</c>.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.BoundUserInterface.OnProtoReload(Robust.Shared.Prototypes.PrototypesReloadedEventArgs)">
            <summary>
            Helper method that gets called upon prototype reload.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.BoundUserInterface.ReceiveMessage(Robust.Shared.GameObjects.BoundUserInterfaceMessage)">
            <summary>
                Invoked when the server sends an arbitrary message.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.BoundUserInterface.Close">
            <summary>
                Invoked to close the UI.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.BoundUserInterface.SendMessage(Robust.Shared.GameObjects.BoundUserInterfaceMessage)">
            <summary>
                Sends a message to the server-side UI.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.BoundUserInterfaceRegisterExt">
            <summary>
            Helper extension methods for working with Bound User Interface events.
            </summary>
            <seealso cref="T:Robust.Shared.GameObjects.BoundUserInterfaceMessage"/>
        </member>
        <member name="T:Robust.Shared.GameObjects.BoundUserInterfaceRegisterExt.BuiEventSubscriber`1">
            <summary>
            Delegate that subscribes to actual BUI events.
            Used as a lambda via <see cref="M:Robust.Shared.GameObjects.BoundUserInterfaceRegisterExt.BuiEvents``1(Robust.Shared.GameObjects.EntitySystem.Subscriptions,System.Object,Robust.Shared.GameObjects.BoundUserInterfaceRegisterExt.BuiEventSubscriber{``0})"/>.
            </summary>
            <typeparam name="TComp">The type of component that will receive the events.</typeparam>
        </member>
        <member name="M:Robust.Shared.GameObjects.BoundUserInterfaceRegisterExt.BuiEvents``1(Robust.Shared.GameObjects.EntitySystem.Subscriptions,System.Object,Robust.Shared.GameObjects.BoundUserInterfaceRegisterExt.BuiEventSubscriber{``0})">
            <summary>
            Extension method to subscribe to one or more Bound User Interface events via a system,
            sharing the same UI key and owning component.
            </summary>
            <param name="subs">
            The entity system subscriptions.
            Call this with <see cref="T:Robust.Shared.GameObjects.EntitySystem.Subscriptions"/>.
            </param>
            <param name="uiKey">
            The UI key to filter these subscriptions. The handler will only receive events targeted for this UI key.
            </param>
            <param name="subscriber">The delegate that will subscribe to the actual events.</param>
            <typeparam name="TComp">The type of component that will receive the events.</typeparam>
            <seealso cref="T:Robust.Shared.GameObjects.BoundUserInterfaceRegisterExt.Subscriber`1"/>
        </member>
        <member name="T:Robust.Shared.GameObjects.BoundUserInterfaceRegisterExt.Subscriber`1">
            <summary>
            Helper class to register Bound User Interface subscriptions against.
            Created by <see cref="M:Robust.Shared.GameObjects.BoundUserInterfaceRegisterExt.BuiEvents``1(Robust.Shared.GameObjects.EntitySystem.Subscriptions,System.Object,Robust.Shared.GameObjects.BoundUserInterfaceRegisterExt.BuiEventSubscriber{``0})"/>.
            </summary>
            <typeparam name="TComp">The type of component that will receive the events.</typeparam>
        </member>
        <member name="M:Robust.Shared.GameObjects.BoundUserInterfaceRegisterExt.Subscriber`1.Event``1(Robust.Shared.GameObjects.ComponentEventHandler{`0,``0})">
            <summary>
            Subscribe to a local event. This is effectively equivalent to <see cref="M:Robust.Shared.GameObjects.EntitySystem.SubscribeLocalEvent``2(Robust.Shared.GameObjects.ComponentEventHandler{``0,``1},System.Type[],System.Type[])"/>,
            but reduces repetition and automatically filters for the appropriate UI key.
            </summary>
            <param name="handler">The handler that will get executed whenever the appropriate event is raised.</param>
            <typeparam name="TEvent">The type of event to handle with this subscription.</typeparam>
            <seealso cref="M:Robust.Shared.GameObjects.EntitySystem.SubscribeLocalEvent``2(Robust.Shared.GameObjects.ComponentEventHandler{``0,``1},System.Type[],System.Type[])"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.BoundUserInterfaceRegisterExt.Subscriber`1.Event``1(Robust.Shared.GameObjects.EntityEventRefHandler{`0,``0})">
            <summary>
            Subscribe to a local event. This is effectively equivalent to <see cref="M:Robust.Shared.GameObjects.EntitySystem.SubscribeLocalEvent``2(Robust.Shared.GameObjects.ComponentEventHandler{``0,``1},System.Type[],System.Type[])"/>,
            but reduces repetition and automatically filters for the appropriate UI key.
            </summary>
            <param name="handler">The handler that will get executed whenever the appropriate event is raised.</param>
            <typeparam name="TEvent">The type of event to handle with this subscription.</typeparam>
            <seealso cref="M:Robust.Shared.GameObjects.EntitySystem.SubscribeLocalEvent``2(Robust.Shared.GameObjects.ComponentEventHandler{``0,``1},System.Type[],System.Type[])"/>
        </member>
        <member name="T:Robust.Shared.GameObjects.IgnoreUIRangeComponent">
            <summary>
                Lets any entities with this component ignore user interface range checks that would normally
                close the UI automatically.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IgnoreUIRangeComponent.InternalCopy(Robust.Shared.GameObjects.IgnoreUIRangeComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.IgnoreUIRangeComponent.Copy(Robust.Shared.GameObjects.IgnoreUIRangeComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.IgnoreUIRangeComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.IgnoreUIRangeComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.IgnoreUIRangeComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.IgnoreUIRangeComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.IgnoreUIRangeComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.ActiveUserInterfaceComponent.InternalCopy(Robust.Shared.GameObjects.ActiveUserInterfaceComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.ActiveUserInterfaceComponent.Copy(Robust.Shared.GameObjects.ActiveUserInterfaceComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.ActiveUserInterfaceComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.ActiveUserInterfaceComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.ActiveUserInterfaceComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.ActiveUserInterfaceComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.ActiveUserInterfaceComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="F:Robust.Shared.GameObjects.UserInterfaceComponent.ClientOpenInterfaces">
            <summary>
            The currently open interfaces. Used clientside to store the UI.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.UserInterfaceComponent.Actors">
            <summary>
            Actors that currently have interfaces open.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.UserInterfaceComponent.States">
            <summary>
            Legacy data, new BUIs should be using comp states.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.UserInterfaceComponent.InternalCopy(Robust.Shared.GameObjects.UserInterfaceComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.UserInterfaceComponent.Copy(Robust.Shared.GameObjects.UserInterfaceComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.UserInterfaceComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.UserInterfaceComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.UserInterfaceComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.UserInterfaceComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.UserInterfaceComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="F:Robust.Shared.GameObjects.InterfaceData.InteractionRange">
            <summary>
                Maximum range before a BUI auto-closes. A non-positive number means there is no limit.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.InterfaceData.RequireInputValidation">
            <summary>
                Determines whether the server should verify that a client is capable of performing generic UI interactions when receiving UI messages.
            </summary>
            <remarks>
                Avoids requiring each system to individually validate client inputs. However, perhaps some BUIs are supposed to be bypass accessibility checks
            </remarks>
        </member>
        <member name="M:Robust.Shared.GameObjects.InterfaceData.InternalCopy(Robust.Shared.GameObjects.InterfaceData@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.InterfaceData.Copy(Robust.Shared.GameObjects.InterfaceData@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.InterfaceData.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.InterfaceData.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Shared.GameObjects.BoundUserInterfaceMessageAttempt">
            <summary>
                Raised whenever the server receives a BUI message from a client relating to a UI that requires input
                validation.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.BoundUserInterfaceMessageAttempt.#ctor(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.EntityUid,System.Enum,Robust.Shared.GameObjects.BoundUserInterfaceMessage)">
            <summary>
                Raised whenever the server receives a BUI message from a client relating to a UI that requires input
                validation.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.BaseLocalBoundUserInterfaceEvent">
            <summary>
            Abstract class for local BUI events.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.BaseLocalBoundUserInterfaceEvent.Entity">
            <summary>
                The Entity receiving the message.
                Only set when the message is raised as a directed event.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.BaseBoundUserInterfaceEvent">
            <summary>
            Abstract class for all BUI events.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.BaseBoundUserInterfaceEvent.UiKey">
            <summary>
                The UI of this message.
                Only set when the message is raised as a directed event.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.BaseBoundUserInterfaceEvent.Actor">
            <summary>
                The session sending or receiving this message.
                Only set when the message is raised as a directed event.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.BoundUserInterfaceMessage">
            <summary>
            Abstract class for networked BUI events.
            </summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.BoundUserInterfaceMessage.Entity">
            <summary>
                The Entity receiving the message.
                Only set when the message is raised as a directed event.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.BoundUIWrapMessage">
            <summary>
            Helper message raised from client to server.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.BoundUIWrapMessage.#ctor(Robust.Shared.GameObjects.NetEntity,Robust.Shared.GameObjects.BoundUserInterfaceMessage,System.Enum)">
            <summary>
            Helper message raised from client to server.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.UserInterfaceUserComponent">
            <summary>
            Stores data about this entity and what BUIs they have open.
            </summary>
            <remarks>
            This component is implicitly networked via <see cref="T:Robust.Shared.GameObjects.UserInterfaceComponent"/>.
            I.e., the other component is authoritative about what UIs are open
            </remarks>
        </member>
        <member name="M:Robust.Shared.GameObjects.UserInterfaceUserComponent.InternalCopy(Robust.Shared.GameObjects.UserInterfaceUserComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.UserInterfaceUserComponent.Copy(Robust.Shared.GameObjects.UserInterfaceUserComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.UserInterfaceUserComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.UserInterfaceUserComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.UserInterfaceUserComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.UserInterfaceUserComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.UserInterfaceUserComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Shared.GameObjects.DrawDepth">
            <summary>
            Tag type for defining the representation of rendering draw depth in
            terms of named constants in the content. To understand more about the
            point of this type, see the <see cref="T:Robust.Shared.Serialization.ConstantsForAttribute"/>.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.DrawDepth.Default">
            <summary>
            The default draw depth. The content enum which represents draw depth
            should respect this value, since it is used in the engine.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.EntityCreationException">
            <summary>
                Thrown if an entity fails to be created due to an exception inside a component.
            </summary>
            <remarks>
                See the <see cref="P:System.Exception.InnerException"/> for the actual exception.
            </remarks>
        </member>
        <member name="T:Robust.Shared.GameObjects.IBroadcastEventBus">
            <summary>
            Provides a central event bus that EntitySystems can subscribe to. This is the main way that
            EntitySystems communicate with each other.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IBroadcastEventBus.SubscribeEvent``1(Robust.Shared.GameObjects.EventSource,Robust.Shared.GameObjects.IEntityEventSubscriber,Robust.Shared.GameObjects.EntityEventHandler{``0})">
            <summary>
            Subscribes an event handler for an event type.
            </summary>
            <typeparam name="T">Event type to subscribe to.</typeparam>
            <param name="source"></param>
            <param name="subscriber">Subscriber that owns the handler.</param>
            <param name="eventHandler">Delegate that handles the event.</param>
            <seealso cref="M:Robust.Shared.GameObjects.IBroadcastEventBus.SubscribeEvent``1(Robust.Shared.GameObjects.EventSource,Robust.Shared.GameObjects.IEntityEventSubscriber,Robust.Shared.GameObjects.EntityEventRefHandler{``0})"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.IBroadcastEventBus.SubscribeEvent``1(Robust.Shared.GameObjects.EventSource,Robust.Shared.GameObjects.IEntityEventSubscriber,Robust.Shared.GameObjects.EntityEventHandler{``0},System.Type,System.Type[],System.Type[])">
            <seealso cref="M:Robust.Shared.GameObjects.IBroadcastEventBus.SubscribeEvent``1(Robust.Shared.GameObjects.EventSource,Robust.Shared.GameObjects.IEntityEventSubscriber,Robust.Shared.GameObjects.EntityEventRefHandler{``0})"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.IBroadcastEventBus.UnsubscribeEvent``1(Robust.Shared.GameObjects.EventSource,Robust.Shared.GameObjects.IEntityEventSubscriber)">
            <summary>
            Unsubscribes all event handlers of a given type.
            </summary>
            <typeparam name="T">Event type being unsubscribed from.</typeparam>
            <param name="source"></param>
            <param name="subscriber">Subscriber that owns the handlers.</param>
        </member>
        <member name="M:Robust.Shared.GameObjects.IBroadcastEventBus.RaiseEvent(Robust.Shared.GameObjects.EventSource,System.Object)">
            <summary>
            Immediately raises an event onto the bus.
            </summary>
            <param name="source"></param>
            <param name="toRaise">Event being raised.</param>
        </member>
        <member name="M:Robust.Shared.GameObjects.IBroadcastEventBus.QueueEvent(Robust.Shared.GameObjects.EventSource,Robust.Shared.GameObjects.EntityEventArgs)">
            <summary>
            Queues an event to be raised at a later time.
            </summary>
            <param name="source"></param>
            <param name="toRaise">Event being raised.</param>
        </member>
        <member name="M:Robust.Shared.GameObjects.IBroadcastEventBus.UnsubscribeEvents(Robust.Shared.GameObjects.IEntityEventSubscriber)">
            <summary>
            Unsubscribes all event handlers for a given subscriber.
            </summary>
            <param name="subscriber">Owner of the handlers being removed.</param>
        </member>
        <member name="T:Robust.Shared.GameObjects.IBroadcastEventBusInternal">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.IBroadcastEventBusInternal.ProcessEventQueue">
            <summary>
            Raises all queued events onto the event bus. This needs to be called often.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.EntityEventBus">
            <summary>
            Implements the event broadcast functions.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityEventBus.UnsubscribeEvents(Robust.Shared.GameObjects.IEntityEventSubscriber)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityEventBus.ProcessEventQueue">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityEventBus.SubscribeEvent``1(Robust.Shared.GameObjects.EventSource,Robust.Shared.GameObjects.IEntityEventSubscriber,Robust.Shared.GameObjects.EntityEventHandler{``0})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityEventBus.UnsubscribeEvent``1(Robust.Shared.GameObjects.EventSource,Robust.Shared.GameObjects.IEntityEventSubscriber)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityEventBus.RaiseEvent(Robust.Shared.GameObjects.EventSource,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityEventBus.QueueEvent(Robust.Shared.GameObjects.EventSource,Robust.Shared.GameObjects.EntityEventArgs)">
            <inheritdoc />
        </member>
        <member name="F:Robust.Shared.GameObjects.EntityEventBus._eventSubs">
            <summary>
            Array of component events and their handlers. The array is indexed by a component's
            <see cref="F:Robust.Shared.GameObjects.CompIdx.Value"/>, while the dictionary is indexed by the event type. This does not include events
            with the <see cref="T:Robust.Shared.GameObjects.ComponentEventAttribute"/>
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.EntityEventBus._compEventSubs">
            <summary>
            Variant of <see cref="F:Robust.Shared.GameObjects.EntityEventBus._eventSubs"/> that also includes events with the <see cref="T:Robust.Shared.GameObjects.ComponentEventAttribute"/>
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.EntityEventBus._eventSubsInv">
            <summary>
            Inverse of <see cref="F:Robust.Shared.GameObjects.EntityEventBus._eventSubs"/>, mapping event types to sets of components.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.EntityEventBus.EventData">
            <summary>
            Information for a single event type handled by EventBus. Not specific to broadcast registrations.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.EntityEventBus.EventData.ComponentEvent">
            <summary>
            <see cref="T:Robust.Shared.GameObjects.ComponentEventAttribute"/> set?
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.EntityEventBus.MaxEventLinkedListSize">
            <summary>
            Max size of a components event subscription linked list.
            Used to limit the stackalloc in <see cref="M:Robust.Shared.GameObjects.EntityEventBus.EntDispatch(Robust.Shared.GameObjects.EntityUid,System.Type,Robust.Shared.GameObjects.EntityEventBus.Unit@)"/>
            </summary>
            <remarks>
            SS14 currently requires only 18, I doubt it will ever need to exceed 256.
            </remarks>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityEventBus.#ctor(Robust.Shared.GameObjects.IEntityManager,Robust.Shared.Reflection.IReflectionManager)">
            <summary>
            Constructs a new instance of <see cref="T:Robust.Shared.GameObjects.EntityEventBus"/>.
            </summary>
            <param name="entMan">The entity manager to watch for entity/component events.</param>
            <param name="reflection">The reflection manager to use when finding derived types.</param>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityEventBus.RaiseComponentEvent``1(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.IComponent,``0)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityEventBus.RaiseComponentEvent``2(Robust.Shared.GameObjects.EntityUid,``1,``0)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityEventBus.RaiseComponentEvent``1(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.IComponent,Robust.Shared.GameObjects.CompIdx,``0)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityEventBus.RaiseComponentEvent``1(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.IComponent,``0@)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityEventBus.RaiseComponentEvent``2(Robust.Shared.GameObjects.EntityUid,``1,``0@)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityEventBus.RaiseComponentEvent``1(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.IComponent,Robust.Shared.GameObjects.CompIdx,``0@)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityEventBus.RaiseLocalEvent``1(Robust.Shared.GameObjects.EntityUid,``0,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityEventBus.RaiseLocalEvent(Robust.Shared.GameObjects.EntityUid,System.Object,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityEventBus.SubscribeLocalEvent``2(Robust.Shared.GameObjects.ComponentEventHandler{``0,``1})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityEventBus.UnsubscribeLocalEvent``2">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityEventBus.UpdateOrderSeq(System.Type,Robust.Shared.GameObjects.EntityEventBus.EventData)">
            <summary>
            Calculate sequence order for all event subscriptions, broadcast and directed.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.EntityEventBus.OrderedRegistration">
            <summary>
            Base type for directed and broadcast subscriptions. Contains ordering data.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityEventBus.CalcOrdering">
             <summary>
             Ensure all ordered events are sorted out and verified.
             </summary>
             <remarks>
             Internal sorting for ordered events is normally deferred until raised
             (since broadcast event subscriptions can be edited at any time).
            
             Calling this gets all the sorting done ahead of time,
             and makes sure that there are no problems with cycles and such.
             </remarks>
        </member>
        <member name="M:Robust.Shared.GameObjects.IDirectedEventBus.RaiseComponentEvent``2(Robust.Shared.GameObjects.EntityUid,``1,``0)">
            <summary>
            Dispatches an event directly to a specific component.
            </summary>
            <remarks>
            This has a very specific purpose, and has massive potential to be abused.
            DO NOT USE THIS IN CONTENT UNLESS YOU KNOW WHAT YOU'RE DOING, the only reason it's not internal
            is because of the component network source generator.
            </remarks>
        </member>
        <member name="M:Robust.Shared.GameObjects.IDirectedEventBus.RaiseComponentEvent``1(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.IComponent,``0)">
            <inheritdoc cref="M:Robust.Shared.GameObjects.IDirectedEventBus.RaiseComponentEvent``2(Robust.Shared.GameObjects.EntityUid,``1,``0)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.IDirectedEventBus.RaiseComponentEvent``1(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.IComponent,Robust.Shared.GameObjects.CompIdx,``0)">
            <inheritdoc cref="M:Robust.Shared.GameObjects.IDirectedEventBus.RaiseComponentEvent``2(Robust.Shared.GameObjects.EntityUid,``1,``0)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.IDirectedEventBus.RaiseComponentEvent``1(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.IComponent,``0@)">
            <inheritdoc cref="M:Robust.Shared.GameObjects.IDirectedEventBus.RaiseComponentEvent``2(Robust.Shared.GameObjects.EntityUid,``1,``0)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.IDirectedEventBus.RaiseComponentEvent``2(Robust.Shared.GameObjects.EntityUid,``1,``0@)">
            <inheritdoc cref="M:Robust.Shared.GameObjects.IDirectedEventBus.RaiseComponentEvent``2(Robust.Shared.GameObjects.EntityUid,``1,``0)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.IDirectedEventBus.RaiseComponentEvent``1(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.IComponent,Robust.Shared.GameObjects.CompIdx,``0@)">
            <inheritdoc cref="M:Robust.Shared.GameObjects.IDirectedEventBus.RaiseComponentEvent``2(Robust.Shared.GameObjects.EntityUid,``1,``0)"/>
        </member>
        <member name="T:Robust.Shared.GameObjects.ComponentEventHandler`2">
            <seealso cref="T:Robust.Shared.GameObjects.ComponentEventRefHandler`2"/>
        </member>
        <member name="P:Robust.Shared.GameObjects.HandledEntityEventArgs.Handled">
            <summary>
                If this message has already been "handled" by a previous system.
            </summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.CancellableEntityEventArgs.Cancelled">
            <summary>
                Whether this even has been cancelled.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.CancellableEntityEventArgs.Cancel">
            <summary>
                Cancels the event.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.CancellableEntityEventArgs.Uncancel">
            <summary>
                Uncancels the event. Don't call this unless you know what you're doing.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.EntityLifeStage">
            <summary>
            The life stages of an ECS Entity.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.EntityLifeStage.PreInit">
            <summary>
            The entity has just been created, and needs to be initialized.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.EntityLifeStage.Initializing">
            <summary>
            The entity is currently being initialized.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.EntityLifeStage.Initialized">
            <summary>
            The entity has been initialized.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.EntityLifeStage.MapInitialized">
            <summary>
            The map this entity is on has been initialized, so this entity has been as well.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.EntityLifeStage.Terminating">
            <summary>
            The entity is currently removing all of it's components and is about to be deleted.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.EntityLifeStage.Deleted">
            <summary>
            The entity has been deleted.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.EntityManager">
            <inheritdoc />
            <inheritdoc />
        </member>
        <member name="E:Robust.Shared.GameObjects.EntityManager.ComponentAdded">
            <inheritdoc />
        </member>
        <member name="E:Robust.Shared.GameObjects.EntityManager.ComponentRemoved">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.ClearComponents">
            <summary>
                Instantly clears all components from the manager. This will NOT shut them down gracefully.
                Any entities relying on existing components will be broken.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.Count``1">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.Count(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.AddComponents(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Prototypes.EntityPrototype,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.AddComponents(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Prototypes.ComponentRegistry,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.RemoveComponents(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Prototypes.EntityPrototype)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.RemoveComponents(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Prototypes.ComponentRegistry)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.AddComponentUninitialized``1(Robust.Shared.GameObjects.EntityUid)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.AddComponent``1(Robust.Shared.GameObjects.EntityUid,``0,System.Boolean,Robust.Shared.GameObjects.MetaDataComponent)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.RemoveComponent``1(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.RemoveComponent(Robust.Shared.GameObjects.EntityUid,System.Type,Robust.Shared.GameObjects.MetaDataComponent)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.RemoveComponent(Robust.Shared.GameObjects.EntityUid,System.UInt16,Robust.Shared.GameObjects.MetaDataComponent)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.RemoveComponent(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.IComponent,Robust.Shared.GameObjects.MetaDataComponent)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.RemoveComponentDeferred``1(Robust.Shared.GameObjects.EntityUid)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.RemoveComponentDeferred(Robust.Shared.GameObjects.EntityUid,System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.RemoveComponentDeferred(Robust.Shared.GameObjects.EntityUid,System.UInt16,Robust.Shared.GameObjects.MetaDataComponent)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.RemoveComponentDeferred(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.IComponent)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.RemoveComponentDeferred(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.Component)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.RemoveComponents(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.DisposeComponents(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.CullRemovedComponents">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.HasComponent``1(Robust.Shared.GameObjects.EntityUid)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.HasComponent``1(System.Nullable{Robust.Shared.GameObjects.EntityUid})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.HasComponent(Robust.Shared.GameObjects.EntityUid,System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.HasComponent(System.Nullable{Robust.Shared.GameObjects.EntityUid},System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.HasComponent(Robust.Shared.GameObjects.EntityUid,System.UInt16,Robust.Shared.GameObjects.MetaDataComponent)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.HasComponent(System.Nullable{Robust.Shared.GameObjects.EntityUid},System.UInt16,Robust.Shared.GameObjects.MetaDataComponent)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.EnsureComponent``1(Robust.Shared.GameObjects.EntityUid)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.EnsureComponent``1(Robust.Shared.GameObjects.Entity{``0}@)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.EnsureComponent``1(Robust.Shared.GameObjects.EntityUid,``0@)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.GetComponent``1(Robust.Shared.GameObjects.EntityUid)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.GetComponent(Robust.Shared.GameObjects.EntityUid,System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.GetComponent(Robust.Shared.GameObjects.EntityUid,System.UInt16,Robust.Shared.GameObjects.MetaDataComponent)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.GetComponentInternal(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.CompIdx)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.TryGetComponent``1(Robust.Shared.GameObjects.EntityUid,``0@)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.TryGetComponent``1(System.Nullable{Robust.Shared.GameObjects.EntityUid},``0@)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.TryGetComponent(Robust.Shared.GameObjects.EntityUid,System.Type,Robust.Shared.GameObjects.IComponent@)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.TryGetComponent(System.Nullable{Robust.Shared.GameObjects.EntityUid},System.Type,Robust.Shared.GameObjects.IComponent@)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.TryGetComponent(Robust.Shared.GameObjects.EntityUid,System.UInt16,Robust.Shared.GameObjects.IComponent@,Robust.Shared.GameObjects.MetaDataComponent)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.TryGetComponent(System.Nullable{Robust.Shared.GameObjects.EntityUid},System.UInt16,Robust.Shared.GameObjects.IComponent@,Robust.Shared.GameObjects.MetaDataComponent)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.GetComponents(Robust.Shared.GameObjects.EntityUid)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.GetComponentsInternal(Robust.Shared.GameObjects.EntityUid)">
            <summary>
            Internal variant of <see cref="M:Robust.Shared.GameObjects.EntityManager.GetComponents(Robust.Shared.GameObjects.EntityUid)"/> that directly returns the actual component set.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.ComponentCount(Robust.Shared.GameObjects.EntityUid)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.CopyComponentsInto(System.Span{Robust.Shared.GameObjects.IComponent}@,Robust.Shared.GameObjects.EntityUid)">
            <summary>
            Copy the components for an entity into the given span,
            or re-allocate the span as an array if there's not enough space.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.GetComponents``1(Robust.Shared.GameObjects.EntityUid)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.GetNetComponents(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.GetNetComponentsOrNull(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.ComponentQueryEnumerator(Robust.Shared.Prototypes.ComponentRegistry)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.CompRegistryQueryEnumerator(Robust.Shared.Prototypes.ComponentRegistry)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.EntityQuery``1(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.EntityQuery``2(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.EntityQuery``3(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.EntityQuery``4(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.GetAllComponents(System.Type,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.GetComponentState(Robust.Shared.GameObjects.IEventBus,Robust.Shared.GameObjects.IComponent,Robust.Shared.Player.ICommonSession,Robust.Shared.Timing.GameTick)">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.GameObjects.EntityManager.CurrentTick">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.GameObjects.EntityManager.EntitySysManager">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.GameObjects.EntityManager.EntityNetManager">
            <inheritdoc />
        </member>
        <member name="F:Robust.Shared.GameObjects.EntityManager.Entities">
            <summary>
                All entities currently stored in the manager.
            </summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.EntityManager.EventBus">
            <inheritdoc />
        </member>
        <member name="E:Robust.Shared.GameObjects.EntityManager.EntityQueueDeleted">
            <summary>
            Raised when an entity is queued for deletion. Not raised if an entity is deleted.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.#ctor">
            <summary>
            Constructs a new instance of <see cref="T:Robust.Shared.GameObjects.EntityManager"/>.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.IsDefault(Robust.Shared.GameObjects.EntityUid)">
            <summary>
            Returns true if the entity's data (apart from transform) is default.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.CreateEntityUninitialized(System.String,Robust.Shared.GameObjects.EntityUid,Robust.Shared.Prototypes.ComponentRegistry)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.CreateEntityUninitialized(System.String,Robust.Shared.Prototypes.ComponentRegistry)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.CreateEntityUninitialized(System.String,Robust.Shared.Map.EntityCoordinates,Robust.Shared.Prototypes.ComponentRegistry,Robust.Shared.Maths.Angle)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.CreateEntityUninitialized(System.String,Robust.Shared.Map.MapCoordinates,Robust.Shared.Prototypes.ComponentRegistry,Robust.Shared.Maths.Angle)">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.GameObjects.EntityManager.EntityCount">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.GetEntities">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.DirtyEntity(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.Dirty(Robust.Shared.GameObjects.IComponent,Robust.Shared.GameObjects.MetaDataComponent)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.Dirty(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.IComponent,Robust.Shared.GameObjects.MetaDataComponent)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.Dirty``1(Robust.Shared.GameObjects.Entity{``0},Robust.Shared.GameObjects.MetaDataComponent)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.Dirty``2(Robust.Shared.GameObjects.Entity{``0,``1},Robust.Shared.GameObjects.MetaDataComponent)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.Dirty``3(Robust.Shared.GameObjects.Entity{``0,``1,``2},Robust.Shared.GameObjects.MetaDataComponent)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.Dirty``4(Robust.Shared.GameObjects.Entity{``0,``1,``2,``3},Robust.Shared.GameObjects.MetaDataComponent)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.DeleteEntity(System.Nullable{Robust.Shared.GameObjects.EntityUid})">
            <summary>
            Shuts-down and removes given Entity. This is also broadcast to all clients.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.DeleteEntity(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent,Robust.Shared.GameObjects.TransformComponent)">
            <summary>
            Shuts-down and removes given Entity. This is also broadcast to all clients.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.IsPaused(System.Nullable{Robust.Shared.GameObjects.EntityUid},Robust.Shared.GameObjects.MetaDataComponent)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.FlushEntities">
            <summary>
            Disposes all entities and clears all lists.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.AllocEntity(Robust.Shared.Prototypes.EntityPrototype,Robust.Shared.GameObjects.MetaDataComponent@)">
            <summary>
                Allocates an entity and stores it but does not load components or do initialization.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.AllocEntity(Robust.Shared.GameObjects.MetaDataComponent@)">
            <summary>
                Allocates an entity and stores it but does not load components or do initialization.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.CreateEntity(System.String,Robust.Shared.GameObjects.MetaDataComponent@,Robust.Shared.GameObjects.IEntityLoadContext)">
            <summary>
                Allocates an entity and loads components but does not do initialization.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.CreateEntity(Robust.Shared.Prototypes.EntityPrototype,Robust.Shared.GameObjects.MetaDataComponent@,Robust.Shared.GameObjects.IEntityLoadContext)">
            <summary>
                Allocates an entity and loads components but does not do initialization.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.ToPrettyString(System.Nullable{Robust.Shared.GameObjects.EntityUid},Robust.Shared.GameObjects.MetaDataComponent)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.ToPrettyString(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.ToPrettyString(Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.MetaDataComponent})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.ToPrettyString(System.Nullable{Robust.Shared.GameObjects.NetEntity})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.ToPrettyString(Robust.Shared.GameObjects.NetEntity)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.RaiseSharedEvent``1(``0,System.Nullable{Robust.Shared.GameObjects.EntityUid})">
            <summary>
            Raises an event locally on client or networked on server.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.RaiseSharedEvent``1(``0,Robust.Shared.Player.ICommonSession)">
            <summary>
            Raises an event locally on client or networked on server.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.GenerateEntityUid">
            <summary>
                Factory for generating a new EntityUid for an entity currently being created.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.GenerateNetEntity">
            <summary>
            Generates a unique network id and increments <see cref="F:Robust.Shared.GameObjects.EntityManager.NextNetworkId"/>
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.LifeAddToEntity(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.IComponent,Robust.Shared.GameObjects.CompIdx)">
            <summary>
            Increases the life stage from <see cref="F:Robust.Shared.GameObjects.ComponentLifeStage.PreAdd" /> to <see cref="F:Robust.Shared.GameObjects.ComponentLifeStage.Added" />,
            after raising a <see cref="T:Robust.Shared.GameObjects.ComponentAdd"/> event.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.LifeInitialize(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.IComponent,Robust.Shared.GameObjects.CompIdx)">
            <summary>
            Increases the life stage from <see cref="F:Robust.Shared.GameObjects.ComponentLifeStage.Added" /> to <see cref="F:Robust.Shared.GameObjects.ComponentLifeStage.Initialized" />,
            calling <see cref="M:Robust.Shared.GameObjects.EntityManager.Initialize" />.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.LifeStartup(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.IComponent,Robust.Shared.GameObjects.CompIdx)">
            <summary>
            Increases the life stage from <see cref="F:Robust.Shared.GameObjects.ComponentLifeStage.Initialized" /> to
            <see cref="F:Robust.Shared.GameObjects.ComponentLifeStage.Running" />, calling <see cref="M:Robust.Shared.GameObjects.EntityManager.Startup" />.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.LifeShutdown(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.IComponent,Robust.Shared.GameObjects.CompIdx)">
            <summary>
            Increases the life stage from <see cref="F:Robust.Shared.GameObjects.ComponentLifeStage.Running" /> to <see cref="F:Robust.Shared.GameObjects.ComponentLifeStage.Stopped" />,
            calling <see cref="M:Robust.Shared.GameObjects.EntityManager.Shutdown" />.
            </summary>
            <remarks>
            Components are allowed to remove themselves in their own Startup function.
            </remarks>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.LifeRemoveFromEntity(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.IComponent,Robust.Shared.GameObjects.CompIdx)">
            <summary>
            Increases the life stage from <see cref="F:Robust.Shared.GameObjects.ComponentLifeStage.Stopped" /> to <see cref="F:Robust.Shared.GameObjects.ComponentLifeStage.Deleted" />,
            calling <see cref="!:Component.OnRemove" />.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.EntityManager.NetEntityLookup">
            <summary>
            Inverse lookup for net entities.
            Regular lookup uses MetadataComponent.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.ClearNetEntity(Robust.Shared.GameObjects.NetEntity)">
            <summary>
            Clears an old inverse lookup for a particular entityuid.
            Do not call this unless you are sure of what you're doing.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.SetNetEntity(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.NetEntity,Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
            Set the inverse lookup for a particular entityuid.
            Do not call this unless you are sure of what you're doing.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.IsClientSide(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.TryParseNetEntity(System.String,System.Nullable{Robust.Shared.GameObjects.EntityUid}@)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.TryGetEntity(Robust.Shared.GameObjects.NetEntity,System.Nullable{Robust.Shared.GameObjects.EntityUid}@)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.TryGetEntityData(Robust.Shared.GameObjects.NetEntity,System.Nullable{Robust.Shared.GameObjects.EntityUid}@,Robust.Shared.GameObjects.MetaDataComponent@)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.TryGetEntity(System.Nullable{Robust.Shared.GameObjects.NetEntity},System.Nullable{Robust.Shared.GameObjects.EntityUid}@)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.TryGetNetEntity(Robust.Shared.GameObjects.EntityUid,System.Nullable{Robust.Shared.GameObjects.NetEntity}@,Robust.Shared.GameObjects.MetaDataComponent)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.TryGetNetEntity(System.Nullable{Robust.Shared.GameObjects.EntityUid},System.Nullable{Robust.Shared.GameObjects.NetEntity}@,Robust.Shared.GameObjects.MetaDataComponent)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.EnsureEntity``1(Robust.Shared.GameObjects.NetEntity,Robust.Shared.GameObjects.EntityUid)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.EnsureEntity``1(System.Nullable{Robust.Shared.GameObjects.NetEntity},Robust.Shared.GameObjects.EntityUid)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.GetEntity(Robust.Shared.GameObjects.NetEntity)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.GetEntity(System.Nullable{Robust.Shared.GameObjects.NetEntity})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.GetNetEntity(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.GetNetEntity(System.Nullable{Robust.Shared.GameObjects.EntityUid},Robust.Shared.GameObjects.MetaDataComponent)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.GetNetCoordinates(Robust.Shared.Map.EntityCoordinates,Robust.Shared.GameObjects.MetaDataComponent)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.GetNetCoordinates(System.Nullable{Robust.Shared.Map.EntityCoordinates},Robust.Shared.GameObjects.MetaDataComponent)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.GetCoordinates(Robust.Shared.Map.NetCoordinates)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.GetCoordinates(System.Nullable{Robust.Shared.Map.NetCoordinates})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.EnsureCoordinates``1(Robust.Shared.Map.NetCoordinates,Robust.Shared.GameObjects.EntityUid)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.EnsureCoordinates``1(System.Nullable{Robust.Shared.Map.NetCoordinates},Robust.Shared.GameObjects.EntityUid)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.GetEntitySet(System.Collections.Generic.HashSet{Robust.Shared.GameObjects.NetEntity})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.GetEntityList(System.Collections.Generic.List{Robust.Shared.GameObjects.NetEntity})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.EnsureEntityList``1(System.Collections.Generic.List{Robust.Shared.GameObjects.NetEntity},Robust.Shared.GameObjects.EntityUid)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.GetEntityList(System.Collections.Generic.ICollection{Robust.Shared.GameObjects.NetEntity})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.GetEntityList(System.Collections.Generic.List{System.Nullable{Robust.Shared.GameObjects.NetEntity}})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.GetEntityArray(Robust.Shared.GameObjects.NetEntity[])">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.GetEntityArray(System.Nullable{Robust.Shared.GameObjects.NetEntity}[])">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.GetNetEntitySet(System.Collections.Generic.HashSet{Robust.Shared.GameObjects.EntityUid})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.GetNetEntityList(System.Collections.Generic.List{Robust.Shared.GameObjects.EntityUid})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.GetNetEntityList(System.Collections.Generic.IReadOnlyList{Robust.Shared.GameObjects.EntityUid})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.GetNetEntityList(System.Collections.Generic.ICollection{Robust.Shared.GameObjects.EntityUid})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.GetNetEntityList(System.Collections.Generic.List{System.Nullable{Robust.Shared.GameObjects.EntityUid}})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.GetNetEntityArray(Robust.Shared.GameObjects.EntityUid[])">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.GetNetEntityArray(System.Nullable{Robust.Shared.GameObjects.EntityUid}[])">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.GetNetEntityDictionary``1(System.Collections.Generic.Dictionary{Robust.Shared.GameObjects.EntityUid,``0})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.GetNetEntityDictionary``1(System.Collections.Generic.Dictionary{``0,Robust.Shared.GameObjects.EntityUid})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.GetNetEntityDictionary``1(System.Collections.Generic.Dictionary{``0,System.Nullable{Robust.Shared.GameObjects.EntityUid}})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.GetNetEntityDictionary(System.Collections.Generic.Dictionary{Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.EntityUid})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.GetNetEntityDictionary(System.Collections.Generic.Dictionary{Robust.Shared.GameObjects.EntityUid,System.Nullable{Robust.Shared.GameObjects.EntityUid}})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.GetEntitySet(System.Collections.Generic.HashSet{Robust.Shared.Map.NetCoordinates})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.GetEntityList(System.Collections.Generic.List{Robust.Shared.Map.NetCoordinates})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.GetEntityList(System.Collections.Generic.ICollection{Robust.Shared.Map.NetCoordinates})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.GetEntityList(System.Collections.Generic.List{System.Nullable{Robust.Shared.Map.NetCoordinates}})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.GetEntityArray(Robust.Shared.Map.NetCoordinates[])">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.GetEntityArray(System.Nullable{Robust.Shared.Map.NetCoordinates}[])">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.GetNetCoordinatesSet(System.Collections.Generic.HashSet{Robust.Shared.Map.EntityCoordinates})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.GetNetCoordinatesList(System.Collections.Generic.List{Robust.Shared.Map.EntityCoordinates})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.GetNetCoordinatesList(System.Collections.Generic.ICollection{Robust.Shared.Map.EntityCoordinates})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.GetNetCoordinatesList(System.Collections.Generic.List{System.Nullable{Robust.Shared.Map.EntityCoordinates}})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.GetNetCoordinatesArray(Robust.Shared.Map.EntityCoordinates[])">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManager.GetNetCoordinatesArray(System.Nullable{Robust.Shared.Map.EntityCoordinates}[])">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityQuery`1.GetComponentInternal(Robust.Shared.GameObjects.EntityUid)">
            <summary>
            Elides the component.Deleted check of <see cref="M:Robust.Shared.GameObjects.EntityQuery`1.GetComponent(Robust.Shared.GameObjects.EntityUid)"/>
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityQuery`1.TryGetComponentInternal(System.Nullable{Robust.Shared.GameObjects.EntityUid},`0@)">
            <summary>
            Elides the component.Deleted check of <see cref="M:Robust.Shared.GameObjects.EntityQuery`1.TryGetComponent(System.Nullable{Robust.Shared.GameObjects.EntityUid},`0@)"/>
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityQuery`1.TryGetComponentInternal(Robust.Shared.GameObjects.EntityUid,`0@)">
            <summary>
            Elides the component.Deleted check of <see cref="M:Robust.Shared.GameObjects.EntityQuery`1.TryGetComponent(System.Nullable{Robust.Shared.GameObjects.EntityUid},`0@)"/>
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityQuery`1.HasComponentInternal(Robust.Shared.GameObjects.EntityUid)">
            <summary>
            Elides the component.Deleted check of <see cref="M:Robust.Shared.GameObjects.EntityQuery`1.HasComponent(Robust.Shared.GameObjects.EntityUid)"/>
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityQuery`1.ResolveInternal(Robust.Shared.GameObjects.EntityUid,`0@,System.Boolean)">
            <summary>
            Elides the component.Deleted check of <see cref="M:Robust.Shared.GameObjects.EntityQuery`1.Resolve(Robust.Shared.GameObjects.EntityUid,`0@,System.Boolean)"/>
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityQuery`1.CompOrNullInternal(Robust.Shared.GameObjects.EntityUid)">
            <summary>
            Elides the component.Deleted check of <see cref="M:Robust.Shared.GameObjects.EntityQuery`1.CompOrNull(Robust.Shared.GameObjects.EntityUid)"/>
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.CompRegistryEntityEnumerator">
            <summary>
            Returns entities that match the ComponentRegistry.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.ComponentQueryEnumerator">
            <summary>
            Non-generic version of <see cref="T:Robust.Shared.GameObjects.AllEntityQueryEnumerator`1"/>
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.EntityQueryEnumerator`1">
            <summary>
            Returns all matching unpaused components.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.EntityQueryEnumerator`2">
            <summary>
            Returns all matching unpaused components.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.EntityQueryEnumerator`3">
            <summary>
            Returns all matching unpaused components.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.EntityQueryEnumerator`4">
            <summary>
            Returns all matching unpaused components.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.AllEntityQueryEnumerator`1">
            <summary>
            Returns all matching components, paused or not.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.AllEntityQueryEnumerator`2">
            <summary>
            Returns all matching components, paused or not.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.AllEntityQueryEnumerator`3">
            <summary>
            Returns all matching components, paused or not.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.AllEntityQueryEnumerator`4">
            <summary>
            Returns all matching components, paused or not.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManagerExt.TryGetRandom``1(Robust.Shared.GameObjects.IEntityManager,Robust.Shared.Random.IRobustRandom,Robust.Shared.GameObjects.EntityUid@,System.Boolean)">
            <summary>
            Picks an entity at random with the supplied component.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityManagerExt.TryGetRandom``2(Robust.Shared.GameObjects.IEntityManager,Robust.Shared.Random.IRobustRandom,Robust.Shared.GameObjects.EntityUid@,System.Boolean)">
            <summary>
            Picks an entity at random with the supplied components.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.EntityState.NetEntity">
            <summary>
            Network identifier for the entity.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.EntityState.NetComponents">
            <summary>
                Set of all networked component ids. Only sent to clients if a component has been removed sometime since the
                entity was last sent to a player.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.ComponentChange.State">
            <summary>
            State data for the created/modified component, if any.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.ComponentChange.NetID">
            <summary>
                The Network ID of the component to remove.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.EntityStringRepresentation">
            <summary>
                A type that represents an entity, and allows you to get a string containing human-readable information about it.
                This type converts implicitly to string, for convenience purposes.
            </summary>
            <remarks>
                This can be used to pretty-print information about entities and also to log various information regarding an
                entity, if you're using string interpolation handlers.
            </remarks>
            <param name="Uid">The unique identifier of the entity.</param>
            <param name="Deleted">Whether the entity has been deleted or not. Also true if the entity does not exist.</param>
            <param name="Name">The name of the entity.</param>
            <param name="Prototype">The prototype identifier of the entity, if any.</param>
            <param name="Session">The session attached to the entity, if any.</param>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityStringRepresentation.#ctor(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.NetEntity,System.Boolean,System.String,System.String,Robust.Shared.Player.ICommonSession)">
            <summary>
                A type that represents an entity, and allows you to get a string containing human-readable information about it.
                This type converts implicitly to string, for convenience purposes.
            </summary>
            <remarks>
                This can be used to pretty-print information about entities and also to log various information regarding an
                entity, if you're using string interpolation handlers.
            </remarks>
            <param name="Uid">The unique identifier of the entity.</param>
            <param name="Deleted">Whether the entity has been deleted or not. Also true if the entity does not exist.</param>
            <param name="Name">The name of the entity.</param>
            <param name="Prototype">The prototype identifier of the entity, if any.</param>
            <param name="Session">The session attached to the entity, if any.</param>
        </member>
        <member name="P:Robust.Shared.GameObjects.EntityStringRepresentation.Uid">
            <summary>The unique identifier of the entity.</summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.EntityStringRepresentation.Deleted">
            <summary>Whether the entity has been deleted or not. Also true if the entity does not exist.</summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.EntityStringRepresentation.Name">
            <summary>The name of the entity.</summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.EntityStringRepresentation.Prototype">
            <summary>The prototype identifier of the entity, if any.</summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.EntityStringRepresentation.Session">
            <summary>The session attached to the entity, if any.</summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.EntitySystem">
            <summary>
                A subsystem that acts on all components of a type at once.
            </summary>
            <remarks>
                This class is instantiated by the <c>EntitySystemManager</c>, and any IoC Dependencies will be resolved.
            </remarks>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.Initialize">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.Update(System.Single)">
            <inheritdoc />
            <remarks>
            Not ran on the client if prediction is disabled and
            <see cref="P:Robust.Shared.GameObjects.EntitySystem.UpdatesOutsidePrediction"/> is false (the default).
            </remarks>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.FrameUpdate(System.Single)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.Shutdown">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.RaiseNetworkEvent(Robust.Shared.GameObjects.EntityEventArgs,Robust.Shared.Player.Filter,System.Boolean)">
            <summary>
                Raises a networked event with some filter.
            </summary>
            <param name="message">The event to send</param>
            <param name="filter">The filter that specifies recipients</param>
            <param name="recordReplay">Optional bool specifying whether or not to save this event to replays.</param>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.Get``1">
            <summary>
            Gets the indicated entity system.
            </summary>
            <typeparam name="T">entity system to get</typeparam>
            <returns></returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.TryGet``1(``0@)">
            <summary>
            Tries to get an entity system of the specified type.
            </summary>
            <typeparam name="T">Type of entity system to find.</typeparam>
            <param name="entitySystem">instance matching the specified type (if exists).</param>
            <returns>If an instance of the specified entity system type exists.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.Exists(Robust.Shared.GameObjects.EntityUid)">
            <inheritdoc cref="M:Robust.Shared.GameObjects.IEntityManager.EntityExists(Robust.Shared.GameObjects.EntityUid)" />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.Exists(System.Nullable{Robust.Shared.GameObjects.EntityUid})">
            <inheritdoc cref="M:Robust.Shared.GameObjects.IEntityManager.EntityExists(System.Nullable{Robust.Shared.GameObjects.EntityUid})" />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.Initializing(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
                Retrieves whether the entity is initializing.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.Initialized(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
                Retrieves whether the entity has been initialized and has not yet been deleted.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.Terminating(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
                Retrieves whether the entity is being terminated.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.Deleted(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
                Retrieves whether the entity is deleted or is nonexistent. Returns false if the entity is currently in the
                process of being deleted.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.TerminatingOrDeleted(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
                Checks whether the entity is being or has been deleted (or never existed in the first place).
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.TerminatingOrDeleted(System.Nullable{Robust.Shared.GameObjects.EntityUid},Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
                Checks whether the entity is being or has been deleted (or never existed in the first place).
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.Deleted(System.Nullable{Robust.Shared.GameObjects.EntityUid})">
            <summary>
                Retrieves whether the entity is deleted or is nonexistent.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.LifeStage(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)">
            <inheritdoc cref="P:Robust.Shared.GameObjects.MetaDataComponent.EntityLifeStage" />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.DirtyEntity(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
            Marks this entity as dirty so that it will be updated over the network.
            </summary>
            <remarks>
            Calling Dirty on a component will call this directly.
            </remarks>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.Dirty(Robust.Shared.GameObjects.IComponent,Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
                Marks a component as dirty. This also implicitly dirties the entity this component belongs to.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.Dirty(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.IComponent,Robust.Shared.GameObjects.MetaDataComponent)">
            <inheritdoc cref="M:Robust.Shared.GameObjects.EntitySystem.Dirty``1(Robust.Shared.GameObjects.Entity{``0},Robust.Shared.GameObjects.MetaDataComponent)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.Dirty``1(Robust.Shared.GameObjects.Entity{``0},Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
                Marks a component as dirty. This also implicitly dirties the entity this component belongs to.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.Dirty``2(Robust.Shared.GameObjects.Entity{``0,``1},Robust.Shared.GameObjects.MetaDataComponent)">
            <inheritdoc cref="M:Robust.Shared.GameObjects.EntitySystem.Dirty``1(Robust.Shared.GameObjects.Entity{``0},Robust.Shared.GameObjects.MetaDataComponent)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.Dirty``3(Robust.Shared.GameObjects.Entity{``0,``1,``2},Robust.Shared.GameObjects.MetaDataComponent)">
            <inheritdoc cref="M:Robust.Shared.GameObjects.EntitySystem.Dirty``1(Robust.Shared.GameObjects.Entity{``0},Robust.Shared.GameObjects.MetaDataComponent)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.Dirty``4(Robust.Shared.GameObjects.Entity{``0,``1,``2,``3},Robust.Shared.GameObjects.MetaDataComponent)">
            <inheritdoc cref="M:Robust.Shared.GameObjects.EntitySystem.Dirty``1(Robust.Shared.GameObjects.Entity{``0},Robust.Shared.GameObjects.MetaDataComponent)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.Name(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
                Retrieves the name of an entity.
            </summary>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown when the entity doesn't exist.</exception>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.Description(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
                Retrieves the description of an entity.
            </summary>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown when the entity doesn't exist.</exception>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.Prototype(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
                Retrieves the prototype of an entity, if any.
            </summary>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown when the entity doesn't exist.</exception>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.LastModifiedTick(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
                Retrieves the last <see cref="T:Robust.Shared.Timing.GameTick"/> the entity was modified at.
            </summary>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown when the entity doesn't exist.</exception>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.Paused(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
                Retrieves whether the entity is paused or not.
            </summary>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown when the entity doesn't exist.</exception>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.SetPaused(Robust.Shared.GameObjects.EntityUid,System.Boolean,Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
                Sets the paused status on an entity.
            </summary>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown when the entity doesn't exist.</exception>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.TryDirty(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
                Attempts to mark an entity as dirty.
            </summary>
            <returns>Whether the operation succeeded.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.TryName(Robust.Shared.GameObjects.EntityUid,System.String@,Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
                Attempts to retrieve the name of an entity.
            </summary>
            <returns>Whether the name could be retrieved.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.TryDescription(Robust.Shared.GameObjects.EntityUid,System.String@,Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
                Attempts to retrieve the description of an entity.
            </summary>
            <returns>Whether the description could be retrieved.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.TryPrototype(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Prototypes.EntityPrototype@,Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
                Attempts to retrieve the prototype of an entity.
            </summary>
            <returns>Whether the prototype could be retrieved and was not null.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.TryLastModifiedTick(Robust.Shared.GameObjects.EntityUid,System.Nullable{Robust.Shared.Timing.GameTick}@,Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
                Attempts to retrieve the last <see cref="T:Robust.Shared.Timing.GameTick"/> the entity was modified at.
            </summary>
            <returns>Whether the last modified tick could be retrieved.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.TryPaused(Robust.Shared.GameObjects.EntityUid,System.Nullable{System.Boolean}@,Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
                Attempts to retrieve the paused status on an entity.
            </summary>
            <returns>Whether the pause status could be retrieved.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.ToPrettyString(System.Nullable{Robust.Shared.GameObjects.EntityUid},Robust.Shared.GameObjects.MetaDataComponent)">
            <inheritdoc cref="M:Robust.Shared.GameObjects.IEntityManager.ToPrettyString(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.ToPrettyString(System.Nullable{Robust.Shared.GameObjects.NetEntity})">
            <inheritdoc cref="M:Robust.Shared.GameObjects.IEntityManager.ToPrettyString(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.ToPrettyString(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)">
            <inheritdoc cref="M:Robust.Shared.GameObjects.IEntityManager.ToPrettyString(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.ToPrettyString(Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.MetaDataComponent})">
            <inheritdoc cref="M:Robust.Shared.GameObjects.IEntityManager.ToPrettyString(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.ToPrettyString(Robust.Shared.GameObjects.NetEntity)">
            <inheritdoc cref="M:Robust.Shared.GameObjects.IEntityManager.ToPrettyString(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.Comp``1(Robust.Shared.GameObjects.EntityUid)">
            <inheritdoc cref="M:Robust.Shared.GameObjects.IEntityManager.GetComponent``1(Robust.Shared.GameObjects.EntityUid)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.CompOrNull``1(Robust.Shared.GameObjects.EntityUid)">
            <summary>
                Returns the component of a specific type, or null when it's missing or the entity does not exist.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.CompOrNull``1(System.Nullable{Robust.Shared.GameObjects.EntityUid})">
            <summary>
                Returns the component of a specific type, or null when it's missing or the entity does not exist.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.TryComp``1(Robust.Shared.GameObjects.EntityUid,``0@)">
            <inheritdoc cref="M:Robust.Shared.GameObjects.IEntityManager.TryGetComponent``1(Robust.Shared.GameObjects.EntityUid,``0@)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.TryComp(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.TransformComponent@)">
            <inheritdoc cref="M:Robust.Shared.GameObjects.IEntityManager.TryGetComponent``1(Robust.Shared.GameObjects.EntityUid,``0@)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.TryComp(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent@)">
            <inheritdoc cref="M:Robust.Shared.GameObjects.IEntityManager.TryGetComponent``1(Robust.Shared.GameObjects.EntityUid,``0@)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.TryComp``1(System.Nullable{Robust.Shared.GameObjects.EntityUid},``0@)">
            <inheritdoc cref="M:Robust.Shared.GameObjects.IEntityManager.TryGetComponent``1(System.Nullable{Robust.Shared.GameObjects.EntityUid},``0@)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.TryComp(System.Nullable{Robust.Shared.GameObjects.EntityUid},Robust.Shared.GameObjects.TransformComponent@)">
            <inheritdoc cref="M:Robust.Shared.GameObjects.IEntityManager.TryGetComponent``1(System.Nullable{Robust.Shared.GameObjects.EntityUid},``0@)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.TryComp(System.Nullable{Robust.Shared.GameObjects.EntityUid},Robust.Shared.GameObjects.MetaDataComponent@)">
            <inheritdoc cref="M:Robust.Shared.GameObjects.IEntityManager.TryGetComponent``1(System.Nullable{Robust.Shared.GameObjects.EntityUid},``0@)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.AllComps(Robust.Shared.GameObjects.EntityUid)">
            <inheritdoc cref="M:Robust.Shared.GameObjects.IEntityManager.GetComponents(Robust.Shared.GameObjects.EntityUid)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.AllComps``1(Robust.Shared.GameObjects.EntityUid)">
            <inheritdoc cref="M:Robust.Shared.GameObjects.IEntityManager.GetComponents``1(Robust.Shared.GameObjects.EntityUid)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.Transform(Robust.Shared.GameObjects.EntityUid)">
            <summary>
                Returns the <see cref="T:Robust.Shared.GameObjects.TransformComponent"/> on an entity.
            </summary>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown when the entity doesn't exist.</exception>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.MetaData(Robust.Shared.GameObjects.EntityUid)">
            <summary>
                Returns the <see cref="T:Robust.Shared.GameObjects.MetaDataComponent"/> on an entity.
            </summary>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown when the entity doesn't exist.</exception>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.HasComp``1(Robust.Shared.GameObjects.EntityUid)">
            <summary>
                Retrieves whether the entity has the specified component or not.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.HasComp(Robust.Shared.GameObjects.EntityUid,System.Type)">
            <summary>
                Retrieves whether the entity has the specified component or not.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.HasComp``1(System.Nullable{Robust.Shared.GameObjects.EntityUid})">
            <summary>
                Retrieves whether the entity has the specified component or not.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.HasComp(System.Nullable{Robust.Shared.GameObjects.EntityUid},System.Type)">
            <summary>
                Retrieves whether the entity has the specified component or not.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.AddComp``1(Robust.Shared.GameObjects.EntityUid)">
            <inheritdoc cref="M:Robust.Shared.GameObjects.IEntityManager.AddComponent``1(Robust.Shared.GameObjects.EntityUid)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.AddComp``1(Robust.Shared.GameObjects.EntityUid,``0,System.Boolean)">
            <inheritdoc cref="!:IEntityManager.AddComponent&lt;T&gt;(EntityUid, T, bool)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.EnsureComp``1(Robust.Shared.GameObjects.EntityUid)">
            <inheritdoc cref="M:Robust.Shared.GameObjects.IEntityManager.EnsureComponent``1(Robust.Shared.GameObjects.EntityUid)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.EnsureComp``1(Robust.Shared.GameObjects.EntityUid,``0@)">
            <inheritdoc cref="M:Robust.Shared.GameObjects.IEntityManager.EnsureComponent``1(Robust.Shared.GameObjects.EntityUid,``0@)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.EnsureComp``1(Robust.Shared.GameObjects.Entity{``0}@)">
            <inheritdoc cref="M:Robust.Shared.GameObjects.IEntityManager.EnsureComponent``1(Robust.Shared.GameObjects.Entity{``0}@)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.RemCompDeferred``1(Robust.Shared.GameObjects.EntityUid)">
            <inheritdoc cref="M:Robust.Shared.GameObjects.IEntityManager.RemoveComponentDeferred``1(Robust.Shared.GameObjects.EntityUid)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.RemCompDeferred(Robust.Shared.GameObjects.EntityUid,System.Type)">
            <inheritdoc cref="M:Robust.Shared.GameObjects.IEntityManager.RemoveComponentDeferred(Robust.Shared.GameObjects.EntityUid,System.Type)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.RemCompDeferred(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.IComponent)">
            <inheritdoc cref="M:Robust.Shared.GameObjects.IEntityManager.RemoveComponentDeferred(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.IComponent)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.Count``1">
            <inheritdoc cref="M:Robust.Shared.GameObjects.IEntityManager.Count(System.Type)" />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.Count(System.Type)">
            <inheritdoc cref="M:Robust.Shared.GameObjects.IEntityManager.Count(System.Type)" />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.RemComp``1(Robust.Shared.GameObjects.EntityUid)">
            <inheritdoc cref="!:IEntityManager.RemoveComponent&lt;T&gt;(EntityUid)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.RemComp(Robust.Shared.GameObjects.EntityUid,System.Type)">
            <inheritdoc cref="!:IEntityManager.RemoveComponent(EntityUid, Type)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.RemComp(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.IComponent)">
            <inheritdoc cref="!:IEntityManager.RemoveComponent(EntityUid, IComponent)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.Del(System.Nullable{Robust.Shared.GameObjects.EntityUid})">
            <inheritdoc cref="!:IEntityManager.DeleteEntity(EntityUid)" />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.QueueDel(System.Nullable{Robust.Shared.GameObjects.EntityUid})">
            <inheritdoc cref="!:IEntityManager.QueueDeleteEntity(EntityUid)" />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.TryQueueDel(System.Nullable{Robust.Shared.GameObjects.EntityUid})">
            <inheritdoc cref="M:Robust.Shared.GameObjects.IEntityManager.TryQueueDeleteEntity(System.Nullable{Robust.Shared.GameObjects.EntityUid})" />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.Spawn(System.String,Robust.Shared.Map.MapCoordinates,Robust.Shared.Prototypes.ComponentRegistry,Robust.Shared.Maths.Angle)">
            <inheritdoc cref="M:Robust.Shared.GameObjects.IEntityManager.Spawn(System.String,Robust.Shared.Map.MapCoordinates,Robust.Shared.Prototypes.ComponentRegistry,Robust.Shared.Maths.Angle)" />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.Spawn(System.String,Robust.Shared.Prototypes.ComponentRegistry,System.Boolean)">
            <inheritdoc cref="M:Robust.Shared.GameObjects.IEntityManager.Spawn(System.String,Robust.Shared.Prototypes.ComponentRegistry,System.Boolean)" />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.SpawnAttachedTo(System.String,Robust.Shared.Map.EntityCoordinates,Robust.Shared.Prototypes.ComponentRegistry)">
            <inheritdoc cref="M:Robust.Shared.GameObjects.IEntityManager.SpawnAttachedTo(System.String,Robust.Shared.Map.EntityCoordinates,Robust.Shared.Prototypes.ComponentRegistry,Robust.Shared.Maths.Angle)" />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.SpawnAtPosition(System.String,Robust.Shared.Map.EntityCoordinates,Robust.Shared.Prototypes.ComponentRegistry)">
            <inheritdoc cref="M:Robust.Shared.GameObjects.IEntityManager.SpawnAtPosition(System.String,Robust.Shared.Map.EntityCoordinates,Robust.Shared.Prototypes.ComponentRegistry)" />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.TrySpawnInContainer(System.String,Robust.Shared.GameObjects.EntityUid,System.String,System.Nullable{Robust.Shared.GameObjects.EntityUid}@,Robust.Shared.Containers.ContainerManagerComponent,Robust.Shared.Prototypes.ComponentRegistry)">
            <inheritdoc cref="M:Robust.Shared.GameObjects.IEntityManager.TrySpawnInContainer(System.String,Robust.Shared.GameObjects.EntityUid,System.String,System.Nullable{Robust.Shared.GameObjects.EntityUid}@,Robust.Shared.Containers.ContainerManagerComponent,Robust.Shared.Prototypes.ComponentRegistry)" />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.TrySpawnNextTo(System.String,Robust.Shared.GameObjects.EntityUid,System.Nullable{Robust.Shared.GameObjects.EntityUid}@,Robust.Shared.GameObjects.TransformComponent,Robust.Shared.Prototypes.ComponentRegistry)">
            <inheritdoc cref="M:Robust.Shared.GameObjects.IEntityManager.TrySpawnNextTo(System.String,Robust.Shared.GameObjects.EntityUid,System.Nullable{Robust.Shared.GameObjects.EntityUid}@,Robust.Shared.GameObjects.TransformComponent,Robust.Shared.Prototypes.ComponentRegistry)" />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.SpawnNextToOrDrop(System.String,Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.TransformComponent,Robust.Shared.Prototypes.ComponentRegistry)">
            <inheritdoc cref="M:Robust.Shared.GameObjects.IEntityManager.SpawnNextToOrDrop(System.String,Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.TransformComponent,Robust.Shared.Prototypes.ComponentRegistry)" />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.SpawnInContainerOrDrop(System.String,Robust.Shared.GameObjects.EntityUid,System.String,Robust.Shared.GameObjects.TransformComponent,Robust.Shared.Containers.ContainerManagerComponent,Robust.Shared.Prototypes.ComponentRegistry)">
            <inheritdoc cref="M:Robust.Shared.GameObjects.IEntityManager.SpawnInContainerOrDrop(System.String,Robust.Shared.GameObjects.EntityUid,System.String,Robust.Shared.GameObjects.TransformComponent,Robust.Shared.Containers.ContainerManagerComponent,Robust.Shared.Prototypes.ComponentRegistry)" />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.CompNotFound``1(Robust.Shared.GameObjects.EntityUid)">
            <summary>
                Utility static method to create an exception to be thrown when an entity doesn't have a specific component.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.GetEntityQuery``1">
            <remarks>
            If you need the EntityUid, use <see cref="M:Robust.Shared.GameObjects.EntitySystem.EntityQueryEnumerator``1"/>
            </remarks>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.EntityQuery``1(System.Boolean)">
            <remarks>
            If you need the EntityUid, use <see cref="M:Robust.Shared.GameObjects.EntitySystem.EntityQueryEnumerator``1"/>
            </remarks>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.EntityQuery``2(System.Boolean)">
            <remarks>
            If you need the EntityUid, use <see cref="M:Robust.Shared.GameObjects.EntitySystem.EntityQueryEnumerator``2"/>
            </remarks>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.EntityQuery``3(System.Boolean)">
            <remarks>
            If you need the EntityUid, use <see cref="M:Robust.Shared.GameObjects.EntitySystem.EntityQueryEnumerator``3"/>
            </remarks>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.EntityQuery``4(System.Boolean)">
            <remarks>
            If you need the EntityUid, use <see cref="M:Robust.Shared.GameObjects.EntitySystem.EntityQueryEnumerator``4"/>
            </remarks>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.RaisePredictiveEvent``1(``0)">
            <summary>
                Sends a networked message to the server, while also repeatedly raising it locally for every time this tick gets re-predicted.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.GetNetEntity(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
                Returns the <see cref="T:Robust.Shared.GameObjects.NetEntity"/> of an entity. Returns <see cref="F:Robust.Shared.GameObjects.NetEntity.Invalid"/> if it doesn't exist.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.GetNetEntity(System.Nullable{Robust.Shared.GameObjects.EntityUid},Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
                Returns the <see cref="T:Robust.Shared.GameObjects.NetEntity"/> of an entity.  Logs an error if the entity does not exist.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.EnsureEntity``1(Robust.Shared.GameObjects.NetEntity,Robust.Shared.GameObjects.EntityUid)">
            <summary>
                Returns the <see cref="T:Robust.Shared.GameObjects.NetEntity"/> of an entity or creates a new entity if none exists.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.EnsureEntity``1(System.Nullable{Robust.Shared.GameObjects.NetEntity},Robust.Shared.GameObjects.EntityUid)">
            <summary>
                Returns the <see cref="T:Robust.Shared.GameObjects.NetEntity"/> of an entity or creates a new one if not null.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.EnsureCoordinates``1(Robust.Shared.Map.NetCoordinates,Robust.Shared.GameObjects.EntityUid)">
            <summary>
                Returns the <see cref="T:Robust.Shared.Map.NetCoordinates"/> of an entity or creates a new entity if none exists.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.EnsureCoordinates``1(System.Nullable{Robust.Shared.Map.NetCoordinates},Robust.Shared.GameObjects.EntityUid)">
            <summary>
                Returns the <see cref="T:Robust.Shared.Map.NetCoordinates"/> of an entity or creates a new one if not null.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.GetEntity(Robust.Shared.GameObjects.NetEntity)">
            <summary>
                Returns the <see cref="T:Robust.Shared.GameObjects.EntityUid"/> of a <see cref="T:Robust.Shared.GameObjects.NetEntity"/>. Returns <see cref="F:Robust.Shared.GameObjects.EntityUid.Invalid"/> if it doesn't exist.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.GetEntity(System.Nullable{Robust.Shared.GameObjects.NetEntity})">
            <summary>
                Returns the <see cref="T:Robust.Shared.GameObjects.EntityUid"/> of a <see cref="T:Robust.Shared.GameObjects.NetEntity"/>. Returns <see cref="F:Robust.Shared.GameObjects.EntityUid.Invalid"/> if it doesn't exist.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.GetNetEntitySet(System.Collections.Generic.HashSet{Robust.Shared.GameObjects.EntityUid})">
            <summary>
                Returns the <see cref="T:Robust.Shared.GameObjects.NetEntity"/> versions of the supplied entities. Logs an error if the entities do not exist.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.GetEntitySet(System.Collections.Generic.HashSet{Robust.Shared.GameObjects.NetEntity})">
            <summary>
                Returns the <see cref="T:Robust.Shared.GameObjects.EntityUid"/> versions of the supplied <see cref="T:Robust.Shared.GameObjects.NetEntity"/>. Returns <see cref="F:Robust.Shared.GameObjects.EntityUid.Invalid"/> if it doesn't exist.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.GetNetEntityList(System.Collections.Generic.ICollection{Robust.Shared.GameObjects.EntityUid})">
            <summary>
                Returns the <see cref="T:Robust.Shared.GameObjects.NetEntity"/> versions of the supplied entities. Logs an error if the entities do not exist.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.GetNetEntityList(System.Collections.Generic.IReadOnlyList{Robust.Shared.GameObjects.EntityUid})">
            <summary>
                Returns the <see cref="T:Robust.Shared.GameObjects.NetEntity"/> versions of the supplied entities. Logs an error if the entities do not exist.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.GetEntityList(System.Collections.Generic.ICollection{Robust.Shared.GameObjects.NetEntity})">
            <summary>
                Returns the <see cref="T:Robust.Shared.GameObjects.EntityUid"/> versions of the supplied <see cref="T:Robust.Shared.GameObjects.NetEntity"/>. Returns <see cref="F:Robust.Shared.GameObjects.EntityUid.Invalid"/> if it doesn't exist.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.GetNetEntityList(System.Collections.Generic.List{Robust.Shared.GameObjects.EntityUid})">
            <summary>
                Returns the <see cref="T:Robust.Shared.GameObjects.NetEntity"/> versions of the supplied entities. Logs an error if the entities do not exist.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.GetEntityList(System.Collections.Generic.List{Robust.Shared.GameObjects.NetEntity})">
            <summary>
                Returns the <see cref="T:Robust.Shared.GameObjects.EntityUid"/> versions of the supplied <see cref="T:Robust.Shared.GameObjects.NetEntity"/>. Returns <see cref="F:Robust.Shared.GameObjects.EntityUid.Invalid"/> if it doesn't exist.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.GetNetEntityList(System.Collections.Generic.List{System.Nullable{Robust.Shared.GameObjects.EntityUid}})">
            <summary>
                Returns the <see cref="T:Robust.Shared.GameObjects.NetEntity"/> versions of the supplied entities. Logs an error if the entities do not exist.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.GetEntityList(System.Collections.Generic.List{System.Nullable{Robust.Shared.GameObjects.NetEntity}})">
            <summary>
                Returns the <see cref="T:Robust.Shared.GameObjects.EntityUid"/> versions of the supplied <see cref="T:Robust.Shared.GameObjects.NetEntity"/>. Returns <see cref="F:Robust.Shared.GameObjects.EntityUid.Invalid"/> if it doesn't exist.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.GetNetEntityArray(Robust.Shared.GameObjects.EntityUid[])">
            <summary>
                Returns the <see cref="T:Robust.Shared.GameObjects.NetEntity"/> versions of the supplied entities. Logs an error if the entities do not exist.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.GetEntityArray(Robust.Shared.GameObjects.NetEntity[])">
            <summary>
                Returns the <see cref="T:Robust.Shared.GameObjects.EntityUid"/> versions of the supplied <see cref="T:Robust.Shared.GameObjects.NetEntity"/>. Returns <see cref="F:Robust.Shared.GameObjects.EntityUid.Invalid"/> if it doesn't exist.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.GetNetEntityArray(System.Nullable{Robust.Shared.GameObjects.EntityUid}[])">
            <summary>
                Returns the <see cref="T:Robust.Shared.GameObjects.NetEntity"/> versions of the supplied entities.  Logs an error if the entities do not exist.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.GetEntityArray(System.Nullable{Robust.Shared.GameObjects.NetEntity}[])">
            <summary>
                Returns the <see cref="T:Robust.Shared.GameObjects.EntityUid"/> versions of the supplied <see cref="T:Robust.Shared.GameObjects.NetEntity"/>. Returns <see cref="F:Robust.Shared.GameObjects.EntityUid.Invalid"/> if it doesn't exist.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.GetNetEntityDictionary``1(System.Collections.Generic.Dictionary{Robust.Shared.GameObjects.EntityUid,``0})">
            <summary>
                Returns the <see cref="T:Robust.Shared.GameObjects.NetEntity"/> versions of the supplied entities.  Logs an error if the entities do not exist.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.GetNetEntityDictionary``1(System.Collections.Generic.Dictionary{``0,Robust.Shared.GameObjects.EntityUid})">
            <summary>
                Returns the <see cref="T:Robust.Shared.GameObjects.NetEntity"/> versions of the supplied entities.  Logs an error if the entities do not exist.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.GetNetEntityDictionary``1(System.Collections.Generic.Dictionary{``0,System.Nullable{Robust.Shared.GameObjects.EntityUid}})">
            <summary>
                Returns the <see cref="T:Robust.Shared.GameObjects.NetEntity"/> versions of the supplied entities.  Logs an error if the entities do not exist.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.GetNetEntityDictionary(System.Collections.Generic.Dictionary{Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.EntityUid})">
            <summary>
                Returns the <see cref="T:Robust.Shared.GameObjects.NetEntity"/> versions of the supplied entities.  Logs an error if the entities do not exist.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.GetNetEntityDictionary(System.Collections.Generic.Dictionary{Robust.Shared.GameObjects.EntityUid,System.Nullable{Robust.Shared.GameObjects.EntityUid}})">
            <summary>
                Returns the <see cref="T:Robust.Shared.GameObjects.NetEntity"/> versions of the supplied entities.  Logs an error if the entities do not exist.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.GetEntityDictionary``1(System.Collections.Generic.Dictionary{Robust.Shared.GameObjects.NetEntity,``0})">
            <summary>
                Returns the <see cref="T:Robust.Shared.GameObjects.EntityUid"/> versions of the supplied <see cref="T:Robust.Shared.GameObjects.NetEntity"/>. Returns <see cref="F:Robust.Shared.GameObjects.EntityUid.Invalid"/> if it doesn't exist.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.GetEntityDictionary``1(System.Collections.Generic.Dictionary{``0,Robust.Shared.GameObjects.NetEntity})">
            <summary>
                Returns the <see cref="T:Robust.Shared.GameObjects.EntityUid"/> versions of the supplied <see cref="T:Robust.Shared.GameObjects.NetEntity"/>. Returns <see cref="F:Robust.Shared.GameObjects.EntityUid.Invalid"/> if it doesn't exist.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.GetEntityDictionary``1(System.Collections.Generic.Dictionary{``0,System.Nullable{Robust.Shared.GameObjects.NetEntity}})">
            <summary>
                Returns the <see cref="T:Robust.Shared.GameObjects.EntityUid"/> versions of the supplied <see cref="T:Robust.Shared.GameObjects.NetEntity"/>. Returns <see cref="F:Robust.Shared.GameObjects.EntityUid.Invalid"/> if it doesn't exist.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.GetEntityDictionary(System.Collections.Generic.Dictionary{Robust.Shared.GameObjects.NetEntity,Robust.Shared.GameObjects.NetEntity})">
            <summary>
                Returns the <see cref="T:Robust.Shared.GameObjects.EntityUid"/> versions of the supplied <see cref="T:Robust.Shared.GameObjects.NetEntity"/>. Returns <see cref="F:Robust.Shared.GameObjects.EntityUid.Invalid"/> if it doesn't exist.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.GetEntityDictionary(System.Collections.Generic.Dictionary{Robust.Shared.GameObjects.NetEntity,System.Nullable{Robust.Shared.GameObjects.NetEntity}})">
            <summary>
                Returns the <see cref="T:Robust.Shared.GameObjects.EntityUid"/> versions of the supplied <see cref="T:Robust.Shared.GameObjects.NetEntity"/>. Returns <see cref="F:Robust.Shared.GameObjects.EntityUid.Invalid"/> if it doesn't exist.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.GetNetCoordinates(System.Nullable{Robust.Shared.Map.EntityCoordinates},Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
                Returns the <see cref="T:Robust.Shared.GameObjects.NetEntity"/> of an entity. Returns <see cref="F:Robust.Shared.GameObjects.NetEntity.Invalid"/> if it doesn't exist.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.GetCoordinates(Robust.Shared.Map.NetCoordinates)">
            <summary>
                Returns the <see cref="T:Robust.Shared.GameObjects.EntityUid"/> of a <see cref="T:Robust.Shared.GameObjects.NetEntity"/>. Returns <see cref="F:Robust.Shared.GameObjects.EntityUid.Invalid"/> if it doesn't exist.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.GetCoordinates(System.Nullable{Robust.Shared.Map.NetCoordinates})">
            <summary>
                Returns the <see cref="T:Robust.Shared.GameObjects.EntityUid"/> of a <see cref="T:Robust.Shared.GameObjects.NetEntity"/>. Returns <see cref="F:Robust.Shared.GameObjects.EntityUid.Invalid"/> if it doesn't exist.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.Resolve``1(Robust.Shared.GameObjects.EntityUid,``0@,System.Boolean)">
            <summary>
                Resolves the component on the entity but only if the component instance is null.
            </summary>
            <param name="uid">The entity where to query the components.</param>
            <param name="component">A reference to the variable storing the component, or null if it has to be resolved.</param>
            <param name="logMissing">Whether to log missing components.</param>
            <typeparam name="TComp">The component type to resolve.</typeparam>
            <returns>True if the component is not null or was resolved correctly, false if the component couldn't be resolved.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.Resolve(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent@,System.Boolean)">
            <inheritdoc cref="!:Resolve&lt;TComp&gt;(Robust.Shared.GameObjects.EntityUid,ref TComp?,bool)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.Resolve(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.TransformComponent@,System.Boolean)">
            <inheritdoc cref="!:Resolve&lt;TComp&gt;(Robust.Shared.GameObjects.EntityUid,ref TComp?,bool)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.Resolve``2(Robust.Shared.GameObjects.EntityUid,``0@,``1@,System.Boolean)">
            <summary>
                Resolves the components on the entity for the null component references.
            </summary>
            <param name="uid">The entity where to query the components.</param>
            <param name="comp1">A reference to the variable storing the component, or null if it has to be resolved.</param>
            <param name="comp2">A reference to the variable storing the component, or null if it has to be resolved.</param>
            <param name="logMissing">Whether to log missing components.</param>
            <typeparam name="TComp1">The component type to resolve.</typeparam>
            <typeparam name="TComp2">The component type to resolve.</typeparam>
            <returns>True if the components are not null or were resolved correctly, false if any of the component couldn't be resolved.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.Resolve``3(Robust.Shared.GameObjects.EntityUid,``0@,``1@,``2@,System.Boolean)">
            <summary>
                Resolves the components on the entity for the null component references.
            </summary>
            <param name="uid">The entity where to query the components.</param>
            <param name="comp1">A reference to the variable storing the component, or null if it has to be resolved.</param>
            <param name="comp2">A reference to the variable storing the component, or null if it has to be resolved.</param>
            <param name="comp3">A reference to the variable storing the component, or null if it has to be resolved.</param>
            <param name="logMissing">Whether to log missing components.</param>
            <typeparam name="TComp1">The component type to resolve.</typeparam>
            <typeparam name="TComp2">The component type to resolve.</typeparam>
            <typeparam name="TComp3">The component type to resolve.</typeparam>
            <returns>True if the components are not null or were resolved correctly, false if any of the component couldn't be resolved.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.Resolve``4(Robust.Shared.GameObjects.EntityUid,``0@,``1@,``2@,``3@,System.Boolean)">
            <summary>
                Resolves the components on the entity for the null component references.
            </summary>
            <param name="uid">The entity where to query the components.</param>
            <param name="comp1">A reference to the variable storing the component, or null if it has to be resolved.</param>
            <param name="comp2">A reference to the variable storing the component, or null if it has to be resolved.</param>
            <param name="comp3">A reference to the variable storing the component, or null if it has to be resolved.</param>
            <param name="comp4">A reference to the variable storing the component, or null if it has to be resolved.</param>
            <param name="logMissing">Whether to log missing components.</param>
            <typeparam name="TComp1">The component type to resolve.</typeparam>
            <typeparam name="TComp2">The component type to resolve.</typeparam>
            <typeparam name="TComp3">The component type to resolve.</typeparam>
            <typeparam name="TComp4">The component type to resolve.</typeparam>
            <returns>True if the components are not null or were resolved correctly, false if any of the component couldn't be resolved.</returns>
        </member>
        <member name="P:Robust.Shared.GameObjects.EntitySystem.Subs">
            <summary>
            A handle to allow subscription on this entity system's behalf.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.SubscribeLocalEvent``1(Robust.Shared.GameObjects.EntityEventHandler{``0},System.Type[],System.Type[])">
            <seealso cref="M:Robust.Shared.GameObjects.EntitySystem.SubscribeLocalEvent``1(Robust.Shared.GameObjects.EntityEventRefHandler{``0},System.Type[],System.Type[])"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.SubEvent``1(Robust.Shared.GameObjects.EventSource,Robust.Shared.GameObjects.EntityEventHandler{``0},System.Type[],System.Type[])">
            <seealso cref="M:Robust.Shared.GameObjects.EntitySystem.SubEvent``1(Robust.Shared.GameObjects.EventSource,Robust.Shared.GameObjects.EntityEventRefHandler{``0},System.Type[],System.Type[])"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.SubscribeLocalEvent``2(Robust.Shared.GameObjects.ComponentEventHandler{``0,``1},System.Type[],System.Type[])">
            <seealso cref="M:Robust.Shared.GameObjects.EntitySystem.SubscribeLocalEvent``2(Robust.Shared.GameObjects.ComponentEventRefHandler{``0,``1},System.Type[],System.Type[])"/>
        </member>
        <member name="T:Robust.Shared.GameObjects.EntitySystem.Subscriptions">
            <summary>
            API class to allow registering on an EntitySystem's behalf.
            Intended to support creation of boilerplate-reduction-methods
            that need to subscribe stuff on an entity system.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.Subscriptions.SubscribeLocalEvent``2(Robust.Shared.GameObjects.ComponentEventRefHandler{``0,``1},System.Type[],System.Type[])">
            <summary>
            Proxy to <see cref="M:Robust.Shared.GameObjects.EntitySystem.SubscribeLocalEvent``2(Robust.Shared.GameObjects.ComponentEventRefHandler{``0,``1},System.Type[],System.Type[])" />
            on the owning system.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.Subscriptions.SubscribeLocalEvent``2(Robust.Shared.GameObjects.EntityEventRefHandler{``0,``1},System.Type[],System.Type[])">
            <summary>
            Proxy to <see cref="M:Robust.Shared.GameObjects.EntitySystem.SubscribeLocalEvent``2(Robust.Shared.GameObjects.EntityEventRefHandler{``0,``1},System.Type[],System.Type[])" />
            on the owning system.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystem.Subscriptions.RegisterUnsubscription(System.Action)">
            <summary>
            Register an action to be ran when this entity system is shut down.
            </summary>
            <remarks>
            This can be used by extension methods for <see cref="T:Robust.Shared.GameObjects.EntitySystem.Subscriptions"/>
            to unsubscribe from from external sources such as CVars.
            </remarks>
            <param name="action">An action to be ran when the entity system is shut down.</param>
        </member>
        <member name="E:Robust.Shared.GameObjects.EntitySystemManager.SystemLoaded">
            <inheritdoc />
        </member>
        <member name="E:Robust.Shared.GameObjects.EntitySystemManager.SystemUnloaded">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystemManager.GetEntitySystem``1">
            <exception cref="T:Robust.Shared.IoC.Exceptions.UnregisteredTypeException">Thrown if the provided type is not registered.</exception>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystemManager.TryGetEntitySystem``1(``0@)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystemManager.Initialize(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystemManager.Shutdown">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystemManager.TickUpdate(System.Single,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystemManager.FrameUpdate(System.Single)">
            <inheritdoc />
        </member>
        <member name="T:Robust.Shared.GameObjects.EntityPausedEvent">
            <summary>
            Raised directed on an entity when it is paused.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.EntityUnpausedEvent">
            <summary>
            Raised directed on an entity when it is unpaused.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityUnpausedEvent.#ctor(System.TimeSpan)">
            <summary>
            Raised directed on an entity when it is unpaused.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.EntityRenamedEvent">
            <summary>
            Raised directed on an entity when its name is changed.
            Contains the EntityUid as systems may need to subscribe to it without targeting a specific component.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityRenamedEvent.#ctor(Robust.Shared.GameObjects.EntityUid,System.String,System.String)">
            <summary>
            Raised directed on an entity when its name is changed.
            Contains the EntityUid as systems may need to subscribe to it without targeting a specific component.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.EntityTerminatingEvent">
            <summary>
            The children of this entity are about to be deleted.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityTerminatingEvent.#ctor(Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.MetaDataComponent})">
            <summary>
            The children of this entity are about to be deleted.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.EntParentChangedMessage">
            <summary>
                Raised when an entity parent is changed.
            </summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.EntParentChangedMessage.Entity">
            <summary>
                Entity that was adopted. The transform component has a property with the new parent.
            </summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.EntParentChangedMessage.OldParent">
            <summary>
                Old parent that abandoned the Entity.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.EntParentChangedMessage.OldMapId">
            <summary>
                The map that the entity was on before its parent changed.
            </summary>
            <remarks>
                If the old parent was detached to null without manually updating the map ID of its children, then this
                is required as we cannot simply use the old parent's map ID. Also avoids having to fetch the old
                parent's transform component.
            </remarks>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntParentChangedMessage.#ctor(Robust.Shared.GameObjects.EntityUid,System.Nullable{Robust.Shared.GameObjects.EntityUid},System.Nullable{Robust.Shared.GameObjects.EntityUid},Robust.Shared.GameObjects.TransformComponent)">
            <summary>
                Creates a new instance of <see cref="T:Robust.Shared.GameObjects.EntParentChangedMessage"/>.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.EntitySystemSubscriptionExt">
            <summary>
            Extra subscription helpers for <see cref="T:Robust.Shared.GameObjects.EntitySystem"/> that are not part of the core entity system behavior.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystemSubscriptionExt.CVar``1(Robust.Shared.GameObjects.EntitySystem.Subscriptions,Robust.Shared.Configuration.IConfigurationManager,System.String,System.Action{``0},System.Boolean)">
            <summary>
            Listen for an event for if the config value changes.
            </summary>
            <remarks>
            This is an O(n) operation.
            </remarks>
            <param name="subs">
            The entity system subscriptions.
            Call this with <see cref="T:Robust.Shared.GameObjects.EntitySystem.Subscriptions"/>.
            </param>
            <param name="cfg">The configuration manager.</param>
            <param name="name">The name of the CVar to listen for.</param>
            <param name="onValueChanged">The delegate to run when the value was changed.</param>
            <param name="invokeImmediately">
            Whether to run the callback immediately inw this method. Can help reduce boilerplate
            </param>
            <typeparam name="T">The type of value contained in this CVar.</typeparam>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystemSubscriptionExt.CVar``1(Robust.Shared.GameObjects.EntitySystem.Subscriptions,Robust.Shared.Configuration.IConfigurationManager,Robust.Shared.Configuration.CVarDef{``0},System.Action{``0},System.Boolean)">
            <summary>
            Listen for an event for if the config value changes.
            </summary>
            <remarks>
            This is an O(n) operation.
            </remarks>
            <param name="subs">
            The entity system subscriptions.
            Call this with <see cref="T:Robust.Shared.GameObjects.EntitySystem.Subscriptions"/>.
            </param>
            <param name="cfg">The configuration manager.</param>
            <param name="cVar">The CVar to listen for.</param>
            <param name="onValueChanged">The delegate to run when the value was changed.</param>
            <param name="invokeImmediately">
            Whether to run the callback immediately in this method. Can help reduce boilerplate
            </param>
            <typeparam name="T">The type of value contained in this CVar.</typeparam>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystemSubscriptionExt.CVar``1(Robust.Shared.GameObjects.EntitySystem.Subscriptions,Robust.Shared.Configuration.IConfigurationManager,System.String,Robust.Shared.Configuration.CVarChanged{``0},System.Boolean)">
            <summary>
            Listen for an event for if the config value changes.
            </summary>
            <remarks>
            This is an O(n) operation.
            </remarks>
            <param name="subs">
            The entity system subscriptions.
            Call this with <see cref="T:Robust.Shared.GameObjects.EntitySystem.Subscriptions"/>.
            </param>
            <param name="cfg">The configuration manager.</param>
            <param name="name">The name of the CVar to listen for.</param>
            <param name="onValueChanged">The delegate to run when the value was changed.</param>
            <param name="invokeImmediately">
            Whether to run the callback immediately in this method. Can help reduce boilerplate
            </param>
            <typeparam name="T">The type of value contained in this CVar.</typeparam>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntitySystemSubscriptionExt.CVar``1(Robust.Shared.GameObjects.EntitySystem.Subscriptions,Robust.Shared.Configuration.IConfigurationManager,Robust.Shared.Configuration.CVarDef{``0},Robust.Shared.Configuration.CVarChanged{``0},System.Boolean)">
            <summary>
            Listen for an event for if the config value changes.
            </summary>
            <remarks>
            This is an O(n) operation.
            </remarks>
            <param name="subs">
            The entity system subscriptions.
            Call this with <see cref="T:Robust.Shared.GameObjects.EntitySystem.Subscriptions"/>.
            </param>
            <param name="cfg">The configuration manager.</param>
            <param name="cVar">The CVar to listen for.</param>
            <param name="onValueChanged">The delegate to run when the value was changed.</param>
            <param name="invokeImmediately">
            Whether to run the callback immediately in this method. Can help reduce boilerplate
            </param>
            <typeparam name="T">The type of value contained in this CVar.</typeparam>
        </member>
        <member name="T:Robust.Shared.GameObjects.EntityUid">
            <summary>
                This type contains a network identification number of an entity.
                This can be used by the EntityManager to access an entity
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.EntityUid.Invalid">
            <summary>
                An Invalid entity UID you can compare against.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.EntityUid.FirstUid">
            <summary>
                The first entity UID the entityManager should use when the manager is initialized.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityUid.#ctor(System.Int32)">
            <summary>
                Creates an instance of this structure, with the given network ID.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityUid.Parse(System.ReadOnlySpan{System.Char})">
            <summary>
                Creates an entity UID by parsing a string number.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityUid.IsValid">
            <summary>
                Checks if the ID value is valid. Does not check if it identifies
                a valid Entity.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityUid.Equals(Robust.Shared.GameObjects.EntityUid)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityUid.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityUid.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityUid.op_Equality(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.EntityUid)">
            <summary>
                Check for equality by value between two objects.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityUid.op_Inequality(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.EntityUid)">
            <summary>
                Check for inequality by value between two objects.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityUid.op_Explicit(Robust.Shared.GameObjects.EntityUid)~System.Int32">
            <summary>
                Explicit conversion of EntityId to int. This should only be used in special
                cases like serialization. Do NOT use this in content.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityUid.ToString">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityUid.CompareTo(Robust.Shared.GameObjects.EntityUid)">
            <inheritdoc />
        </member>
        <member name="T:Robust.Shared.GameObjects.ComponentEventAttribute">
            <summary>
            Indicates that an eventbus event should only ever be raised through <see cref="!:IDirectedEventBus.RaiseComponentEvent&lt;TEvent&gt;(IComponent, TEvent)"/>.
            This allows extra optimizations.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.IComponent">
            <remarks>
                Base component for the ECS system.
                Instances are dynamically instantiated by a <c>ComponentFactory</c>, and will have their IoC Dependencies resolved.
            </remarks>
        </member>
        <member name="P:Robust.Shared.GameObjects.IComponent.LifeStage">
            <summary>
                The current lifetime stage of this component. You can use this to check
                if the component is initialized or being deleted.
            </summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.IComponent.NetSyncEnabled">
            <summary>
                Whether this component should be synchronized with clients when modified.
                If this is true, the server will synchronize all client instances with the data in this instance.
                If this is false, clients can modify the data in their instances without being overwritten by the server.
                This flag has no effect if <see cref="T:Robust.Shared.GameStates.NetworkedComponentAttribute" /> is not defined on the component.
                This is enabled by default.
            </summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.IComponent.SendOnlyToOwner">
            <summary>
                If true, and if this is a networked component, then component data will only be sent to players if their
                controlled entity is the owner of this component. This is less performance intensive than <see cref="P:Robust.Shared.GameObjects.IComponent.SessionSpecific"/>.
            </summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.IComponent.SessionSpecific">
            <summary>
                If true, and if this is a networked component, then this component will cause <see
                cref="T:Robust.Shared.GameStates.ComponentGetStateAttemptEvent"/> events to be raised to check whether a given player should
                receive this component's state.
            </summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.IComponent.Owner">
            <summary>
                Entity that this component is attached to.
            </summary>
            <seealso cref="T:Robust.Shared.GameObjects.EntityQueryEnumerator`1"/>
        </member>
        <member name="P:Robust.Shared.GameObjects.IComponent.Initialized">
            <summary>
            Component has been (or is currently being) initialized.
            </summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.IComponent.Running">
            <summary>
                This is true when the component is active.
            </summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.IComponent.Deleted">
            <summary>
                True if the component has been removed from its owner, AKA deleted.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IComponent.Dirty(Robust.Shared.GameObjects.IEntityManager)">
            <summary>
                Marks the component as dirty so that the network will re-sync it with clients.
            </summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.IComponent.CreationTick">
            <summary>
                This is the tick the component was created.
            </summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.IComponent.LastModifiedTick">
            <summary>
                This is the last game tick Dirty() was called.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.IComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.IComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.IComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.IComponentDebug.InternalCopy(Robust.Shared.GameObjects.IComponentDebug@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.IComponentDebug.Copy(Robust.Shared.GameObjects.IComponentDebug@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.IComponentDebug.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.IComponentDebug.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.IComponentDebug.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.IComponentDebug.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Shared.GameObjects.ComponentAvailability">
            <summary>
            Used by <see cref="T:Robust.Shared.Prototypes.EntityPrototype" /> to determine whether a component is available.
            This distinction is important because prototypes are shared across client and server, but the two might have different components.
            </summary>
            <seealso cref="T:Robust.Shared.GameObjects.IComponentFactory" />
        </member>
        <member name="F:Robust.Shared.GameObjects.ComponentAvailability.Available">
            <summary>
            The component is available and can be instantiated.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.ComponentAvailability.Ignore">
            <summary>
            The component is not available, but should be ignored (prevent warnings for missing components).
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.ComponentAvailability.Unknown">
            <summary>
            The component is unknown entirely. This may warrant a warning or error.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.IComponentFactory">
            <summary>
            Handles the registration and spawning of components.
            </summary>
            <remarks>
            <p>
            When referring to component names, this is the name the component has been registered as,
            and what's used in prototypes. However, most commonly the type is referred through by an interface.
            </p>
            <p>
            Before a component can be spawned, it must be registered so things such as name, networking ID, type, etc...
            are known to the factory.
            Components are registered into a registry.
            The relevant methods for writing to this registry are <see cref="!:RegisterReference" />.
            The data is exposed for reading through <see cref="M:Robust.Shared.GameObjects.IComponentFactory.GetRegistration(System.String,System.Boolean)" /> and its overloads.
            This data is returned in the form of a <see cref="!:IComponentRegistration" />, which represents one component's registration.
            </p>
            </remarks>
            <seealso cref="!:IComponentRegistration" />
            <seealso cref="T:Robust.Shared.GameObjects.IComponent" />
        </member>
        <member name="P:Robust.Shared.GameObjects.IComponentFactory.AllRegisteredTypes">
            <summary>
                All IComponent types that are currently registered to this factory.
            </summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.IComponentFactory.NetworkedComponents">
            <summary>
            The subset of all registered components that are networked, so that they can be
            referenced between the client and the server.
            </summary>
            <remarks>
            This will be null if the network Ids have not been generated yet.
            </remarks>
            <seealso cref="M:Robust.Shared.GameObjects.IComponentFactory.GenerateNetIds"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.IComponentFactory.GetComponentAvailability(System.String,System.Boolean)">
            <summary>
            Get whether a component is available right now.
            </summary>
            <param name="componentName">The name of the component to check.</param>
            <param name="ignoreCase">Whether or not to ignore casing on <see cref="!:componentName"/></param>
            <returns>The availability of the component.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IComponentFactory.GetIndex(System.Type)">
            <summary>
            Slow-path for Type -> CompIdx mapping without generics.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IComponentFactory.GetArrayIndex(System.Type)">
            <summary>
            Slow-path to get the component index for a specified type.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IComponentFactory.RegisterClass``1(System.Boolean)">
            <summary>
            Registers a component class with the factory.
            </summary>
            <param name="overwrite">If the component already exists, will this replace it?</param>
        </member>
        <member name="M:Robust.Shared.GameObjects.IComponentFactory.RegisterTypes(System.Type[])">
            <summary>
            Registers component types with the factory.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IComponentFactory.RegisterIgnore(System.String[])">
            <summary>
            Registers a component name as being ignored.
            </summary>
            <param name="names">The names to be ignored.</param>
        </member>
        <member name="M:Robust.Shared.GameObjects.IComponentFactory.IgnoreMissingComponents(System.String)">
            <summary>
            Disables throwing on missing components. Missing components will instead be treated as ignored.
            </summary>
            <param name="postfix">If provided, will only ignore components ending with the postfix.</param>
        </member>
        <member name="M:Robust.Shared.GameObjects.IComponentFactory.GetComponent(System.Type)">
            <summary>
            Gets a new component instantiated of the specified type.
            </summary>
            <param name="componentType">type of component to make</param>
            <returns>A Component</returns>
            <exception cref="T:System.InvalidOperationException">
                Thrown if no component of type <see cref="!:componentType"/> is registered.
            </exception>
        </member>
        <member name="M:Robust.Shared.GameObjects.IComponentFactory.GetComponent``1">
            <summary>
            Gets a new component instantiated of the specified type.
            </summary>
            <typeparam name="T">The type of component to make.</typeparam>
            <returns>A Component</returns>
            <exception cref="T:System.InvalidOperationException">
                Thrown if no component of type <see cref="!:T"/> is registered.
            </exception>
        </member>
        <member name="M:Robust.Shared.GameObjects.IComponentFactory.GetComponent(Robust.Shared.GameObjects.ComponentRegistration)">
            <summary>
            Gets a new component instantiated from the specified component registration.
            </summary>
            <returns>A Component</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IComponentFactory.GetComponent(System.String,System.Boolean)">
            <summary>
            Gets a new component instantiated of the specified <see cref="!:IComponent.Name"/>.
            </summary>
            <param name="componentName">name of component to make</param>
            <param name="ignoreCase">Whether or not to ignore casing on <see cref="!:componentName"/></param>
            <returns>A Component</returns>
            <exception cref="T:Robust.Shared.GameObjects.UnknownComponentException">
                Thrown if no component exists with the given name <see cref="!:componentName"/>.
            </exception>
        </member>
        <member name="M:Robust.Shared.GameObjects.IComponentFactory.GetComponent(System.UInt16)">
            <summary>
            Gets a new component instantiated of the specified network ID.
            </summary>
            <param name="netId">net id of component to make</param>
            <returns>A Component</returns>
            <exception cref="T:Robust.Shared.GameObjects.UnknownComponentException">
                Thrown if no component exists with the given id <see cref="!:netId"/>.
            </exception>
        </member>
        <member name="M:Robust.Shared.GameObjects.IComponentFactory.GetComponentName(System.Type)">
            <summary>
                Gets the name of a component, throwing an exception if it does not exist.
            </summary>
            <param name="componentType">The type of the component</param>
            <returns>The registered name of the component</returns>
            <exception cref="T:Robust.Shared.GameObjects.UnknownComponentException">
                Thrown if no component exists with the given type <see cref="!:componentType"/>.
            </exception>
        </member>
        <member name="M:Robust.Shared.GameObjects.IComponentFactory.GetComponentName(System.UInt16)">
            <summary>
                Gets the name of a component, throwing an exception if it does not exist.
            </summary>
            <param name="netID">The network ID corresponding to the component.</param>
            <returns>The registered name of the component</returns>
            <exception cref="T:Robust.Shared.GameObjects.UnknownComponentException">
                Thrown if no component with id <see cref="!:netID"/> exists.
            </exception>
        </member>
        <member name="M:Robust.Shared.GameObjects.IComponentFactory.GetRegistration(System.String,System.Boolean)">
            <summary>
                Gets the registration belonging to a component, throwing an exception if it does not exist.
            </summary>
            <param name="componentName">The name of the component.</param>
            <param name="ignoreCase">Whether or not to ignore casing on <see cref="!:componentName"/></param>
            <exception cref="T:Robust.Shared.GameObjects.UnknownComponentException">
                Thrown if no component exists with the given name <see cref="!:componentName"/>.
            </exception>
        </member>
        <member name="M:Robust.Shared.GameObjects.IComponentFactory.GetRegistration(System.Type)">
            <summary>
                Gets the registration belonging to a component, throwing an exception if it does not exist.
            </summary>
            <param name="reference">The type of the component to lookup.</param>
            <exception cref="T:Robust.Shared.GameObjects.UnknownComponentException">
                Thrown if no component exists of type <see cref="!:reference"/>.
            </exception>
        </member>
        <member name="M:Robust.Shared.GameObjects.IComponentFactory.GetRegistration``1">
            <summary>
                Gets the registration belonging to a component, throwing an exception if it does not exist.
            </summary>
            <typeparam name="T">A type referencing the component.</typeparam>
            <exception cref="T:Robust.Shared.GameObjects.UnknownComponentException">
                Thrown if no component of type <see cref="!:T"/> exists.
            </exception>
        </member>
        <member name="M:Robust.Shared.GameObjects.IComponentFactory.GetRegistration(System.UInt16)">
            <summary>
                Gets the registration belonging to a component, throwing an
                exception if it does not exist.
            </summary>
            <param name="netID">The network ID corresponding to the component.</param>
            <returns></returns>
            <exception cref="T:Robust.Shared.GameObjects.UnknownComponentException">
                Thrown if no component with id <see cref="!:netID"/> exists.
            </exception>
        </member>
        <member name="M:Robust.Shared.GameObjects.IComponentFactory.GetRegistration(Robust.Shared.GameObjects.IComponent)">
            <summary>
                Gets the registration of a component, throwing an exception if
                it does not exist.
            </summary>
            <param name="component">An instance of the component.</param>
            <returns></returns>
            <exception cref="T:Robust.Shared.GameObjects.UnknownComponentException">
                Thrown if no registration exists for component <see cref="!:component"/>.
            </exception>
        </member>
        <member name="M:Robust.Shared.GameObjects.IComponentFactory.IsIgnored(System.String)">
            <summary>
                Returns true if the given component name has been registered as ignored.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IComponentFactory.TryGetRegistration(System.String,Robust.Shared.GameObjects.ComponentRegistration@,System.Boolean)">
            <summary>
                Tries to get the registration belonging to a component.
            </summary>
            <param name="componentName">The name of the component.</param>
            <param name="registration">The registration if found, null otherwise.</param>
            <param name="ignoreCase">Whether or not to ignore casing on <see cref="!:componentName"/></param>
            <returns>true it found, false otherwise.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IComponentFactory.TryGetRegistration(System.Type,Robust.Shared.GameObjects.ComponentRegistration@)">
            <summary>
                Tries to get the registration belonging to a component.
            </summary>
            <param name="reference">A reference corresponding to the component to look up.</param>
            <param name="registration">The registration if found, null otherwise.</param>
            <returns>true it found, false otherwise.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IComponentFactory.TryGetRegistration``1(Robust.Shared.GameObjects.ComponentRegistration@)">
            <summary>
                Tries to get the registration belonging to a component.
            </summary>
            <typeparam name="T">A type referencing the component.</typeparam>
            <param name="registration">The registration if found, null otherwise.</param>
            <returns>true it found, false otherwise.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IComponentFactory.TryGetRegistration(System.UInt16,Robust.Shared.GameObjects.ComponentRegistration@)">
            <summary>
                Tries to get the registration belonging to a component.
            </summary>
            <param name="netID">The network ID corresponding to the component.</param>
            <param name="registration">The registration if found, null otherwise.</param>
            <returns>true it found, false otherwise.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IComponentFactory.TryGetRegistration(Robust.Shared.GameObjects.IComponent,Robust.Shared.GameObjects.ComponentRegistration@)">
            <summary>
                Tries to get the registration of a component.
            </summary>
            <param name="component">An instance of the component.</param>
            <param name="registration">The registration if found, null otherwise.</param>
            <returns>true it found, false otherwise.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IComponentFactory.DoAutoRegistrations">
            <summary>
                Automatically create registrations for all components with a <see cref="T:Robust.Shared.GameObjects.RegisterComponentAttribute" />
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IComponentFactory.GetHash(System.Boolean)">
            <summary>
            Gets a hash of all the registered components.
            </summary>
            <param name="networkedOnly">Whether to include all components or only networked ones.</param>
        </member>
        <member name="T:Robust.Shared.GameObjects.IEntityLoadContext">
            <summary>
                Interface used to allow the map loader to override prototype data with map data.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityLoadContext.TryGetComponent(System.String,Robust.Shared.GameObjects.IComponent@)">
            <summary>
                Tries getting the data of the provided component
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityLoadContext.GetExtraComponentTypes">
            <summary>
                Gets all components registered for the entityloadcontext, overrides as well as extra components
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityLoadContext.ShouldSkipComponent(System.String)">
            <summary>
                Checks whether a given component should be added to an entity. Used to prevent certain prototype components from being added while spawning an entity.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.IEntityManager">
            <summary>
                Holds a collection of entities and the components attached to them.
            </summary>
        </member>
        <member name="E:Robust.Shared.GameObjects.IEntityManager.ComponentAdded">
            <summary>
                A component was added to the manager.
            </summary>
        </member>
        <member name="E:Robust.Shared.GameObjects.IEntityManager.ComponentRemoved">
            <summary>
                A component was removed from the manager.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.InitializeComponents(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
                Calls Initialize() on all registered components of the entity.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.StartComponents(Robust.Shared.GameObjects.EntityUid)">
            <summary>
                Calls Startup() on all registered components of the entity.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.Count``1">
            <summary>
            Gets the number of a specific component.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.Count(System.Type)">
            <summary>
            Gets the number of a specific component.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.AddComponents(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Prototypes.EntityPrototype,System.Boolean)">
            <summary>
            Adds the specified components from the <see cref="T:Robust.Shared.Prototypes.EntityPrototype"/>
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.AddComponents(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Prototypes.ComponentRegistry,System.Boolean)">
            <summary>
            Adds the specified registry components to the target entity.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.RemoveComponents(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Prototypes.EntityPrototype)">
            <summary>
            Removes the specified entity prototype components from the target entity.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.RemoveComponents(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Prototypes.ComponentRegistry)">
            <summary>
            Removes the specified registry components from the target entity.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.AddComponent``1(Robust.Shared.GameObjects.EntityUid)">
            <summary>
                Adds a Component type to an entity. If the entity is already Initialized, the component will
                automatically be Initialized and Started.
            </summary>
            <typeparam name="T">Concrete component type to add.</typeparam>
            <returns>The newly added component.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.AddComponent(Robust.Shared.GameObjects.EntityUid,System.UInt16,Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
                Adds a Component with a given network id to an entity.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.AddComponentUninitialized``1(Robust.Shared.GameObjects.EntityUid)">
            <summary>
                Adds an uninitialized Component type to an entity.
            </summary>
            <remarks>
                This function returns a disposable initialize handle that you can use in a <see langword="using" /> statement, to set up a component
                before initialization is ran on it.
            </remarks>
            <typeparam name="T">Concrete component type to add.</typeparam>
            <param name="uid">Entity being modified.</param>
            <returns>Component initialization handle. When you are done setting up the component, make sure to dispose this.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.AddComponent``1(Robust.Shared.GameObjects.EntityUid,``0,System.Boolean,Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
                Adds a Component to an entity. If the entity is already Initialized, the component will
                automatically be Initialized and Started.
            </summary>
            <param name="uid">Entity being modified.</param>
            <param name="component">Component to add.</param>
            <param name="overwrite">Should it overwrite existing components?</param>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.RemoveComponent``1(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
                Removes the component with the specified reference type,
                Without needing to have the component itself.
            </summary>
            <typeparam name="T">The component reference type to remove.</typeparam>
            <param name="uid">Entity UID to modify.</param>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.RemoveComponent(Robust.Shared.GameObjects.EntityUid,System.Type,Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
                Removes the component with a specified type.
            </summary>
            <param name="uid">Entity UID to modify.</param>
            <param name="type">A trait or component type to check for.</param>
            <returns>Returns false if the entity did not have the specified component.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.RemoveComponent(Robust.Shared.GameObjects.EntityUid,System.UInt16,Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
                Removes the component with a specified network ID.
            </summary>
            <param name="uid">Entity UID to modify.</param>
            <param name="netID">Network ID of the component to remove.</param>
            <returns>Returns false if the entity did not have the specified component.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.RemoveComponent(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.IComponent,Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
                Removes the specified component. Throws if the given component does not belong to the entity.
            </summary>
            <param name="uid">Entity UID to modify.</param>
            <param name="component">Component to remove.</param>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.RemoveComponentDeferred``1(Robust.Shared.GameObjects.EntityUid)">
            <summary>
                Immediately shuts down a component, but defers the removal and deletion until the end of the tick.
                Without needing to have the component itself.
            </summary>
            <typeparam name="T">The component reference type to remove.</typeparam>
            <param name="uid">Entity UID to modify.</param>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.RemoveComponentDeferred(Robust.Shared.GameObjects.EntityUid,System.Type)">
            <summary>
                Immediately shuts down a component, but defers the removal and deletion until the end of the tick.
            </summary>
            <param name="uid">Entity UID to modify.</param>
            <param name="type">A trait or component type to check for.</param>
            <returns>Returns false if the entity did not have the specified component.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.RemoveComponentDeferred(Robust.Shared.GameObjects.EntityUid,System.UInt16,Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
                Immediately shuts down a component, but defers the removal and deletion until the end of the tick.
            </summary>
            <param name="uid">Entity UID to modify.</param>
            <param name="netID">Network ID of the component to remove.</param>
            <returns>Returns false if the entity did not have the specified component.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.RemoveComponentDeferred(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.IComponent)">
            <summary>
                Immediately shuts down a component, but defers the removal and deletion until the end of the tick.
                Throws if the given component does not belong to the entity.
            </summary>
            <param name="uid">Entity UID to modify.</param>
            <param name="component">Component to remove.</param>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.RemoveComponents(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
                Removes all components from an entity, except the required components.
            </summary>
            <param name="uid">Entity UID to modify.</param>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.DisposeComponents(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
                Removes ALL components from an entity. This includes the required components,
                <see cref="T:Robust.Shared.GameObjects.TransformComponent"/> and <see cref="T:Robust.Shared.GameObjects.MetaDataComponent"/>. This should ONLY be
                used when deleting an entity.
            </summary>
            <param name="uid">Entity UID to modify.</param>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.HasComponent``1(Robust.Shared.GameObjects.EntityUid)">
            <summary>
                Checks if the entity has a component type.
            </summary>
            <typeparam name="T">Component reference type to check for.</typeparam>
            <param name="uid">Entity UID to check.</param>
            <returns>True if the entity has the component type, otherwise false.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.HasComponent``1(System.Nullable{Robust.Shared.GameObjects.EntityUid})">
            <summary>
                Checks if the entity has a component type.
            </summary>
            <typeparam name="T">Component reference type to check for.</typeparam>
            <param name="uid">Entity UID to check.</param>
            <returns>True if the entity has the component type, otherwise false.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.HasComponent(Robust.Shared.GameObjects.EntityUid,System.Type)">
            <summary>
                Checks if the entity has a component type.
            </summary>
            <param name="uid">Entity UID to check.</param>
            <param name="type">A trait or component type to check for.</param>
            <returns>True if the entity has the component type, otherwise false.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.HasComponent(System.Nullable{Robust.Shared.GameObjects.EntityUid},System.Type)">
            <summary>
                Checks if the entity has a component type.
            </summary>
            <param name="uid">Entity UID to check.</param>
            <param name="type">A trait or component type to check for.</param>
            <returns>True if the entity has the component type, otherwise false.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.HasComponent(Robust.Shared.GameObjects.EntityUid,System.UInt16,Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
                Checks if the entity has a component with a given network ID. This does not check
                if the component is deleted.
            </summary>
            <param name="uid">Entity UID to check.</param>
            <param name="netId">Network ID to check for.</param>
            <returns>True if the entity has a component with the given network ID, otherwise false.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.HasComponent(System.Nullable{Robust.Shared.GameObjects.EntityUid},System.UInt16,Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
                Checks if the entity has a component with a given network ID. This does not check
                if the component is deleted.
            </summary>
            <param name="uid">Entity UID to check.</param>
            <param name="netId">Network ID to check for.</param>
            <returns>True if the entity has a component with the given network ID, otherwise false.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.EnsureComponent``1(Robust.Shared.GameObjects.EntityUid)">
            <summary>
                This method will always return a component for a certain entity, adding it if it's not there already.
            </summary>
            <param name="uid">Entity to modify.</param>
            <typeparam name="T">Component to add.</typeparam>
            <returns>The component in question</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.EnsureComponent``1(Robust.Shared.GameObjects.EntityUid,``0@)">
            <summary>
                This method will always return a component for a certain entity, adding it if it's not there already.
            </summary>
            <param name="uid">Entity to modify.</param>
            <param name="component">The output component after being ensured.</param>
            <typeparam name="T">Component to add.</typeparam>
            <returns>True if the component already existed</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.EnsureComponent``1(Robust.Shared.GameObjects.Entity{``0}@)">
            <summary>
                This method will always return a component for a certain entity, adding it if it's not there already.
            </summary>
            <param name="entity">Entity to modify.</param>
            <typeparam name="T">Component to add.</typeparam>
            <returns>True if the component already existed</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.GetComponent``1(Robust.Shared.GameObjects.EntityUid)">
            <summary>
                Returns the component of a specific type.
            </summary>
            <typeparam name="T">A trait or type of a component to retrieve.</typeparam>
            <param name="uid">Entity UID to look on.</param>
            <returns>The component of Type from the Entity.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.GetComponent(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.CompIdx)">
            <summary>
                Returns the component of a specific type.
            </summary>
            <param name="uid">Entity UID to look on.</param>
            <param name="type">A trait or component type to check for.</param>
            <returns>The component of Type from the Entity.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.GetComponent(Robust.Shared.GameObjects.EntityUid,System.Type)">
            <summary>
                Returns the component of a specific type.
            </summary>
            <param name="uid">Entity UID to look on.</param>
            <param name="type">A trait or component type to check for.</param>
            <returns>The component of Type from the Entity.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.GetComponent(Robust.Shared.GameObjects.EntityUid,System.UInt16,Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
                Returns the component with a specific network ID. This does not check
                if the component is deleted.
            </summary>
            <param name="uid">Entity UID to look on.</param>
            <param name="netId">Network ID of the component to retrieve.</param>
            <returns>The component with the specified network id.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.GetComponentInternal(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.CompIdx)">
            <summary>
                Returns the component of a specific type, even if it has been marked for deletion.
            </summary>
            <param name="uid">Entity UID to look on.</param>
            <param name="type">A trait or component type to check for.</param>
            <returns>The component of Type from the Entity.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.TryGetComponent``1(Robust.Shared.GameObjects.EntityUid,``0@)">
            <summary>
                Returns the component of a specific type.
            </summary>
            <typeparam name="T">A trait or type of a component to retrieve.</typeparam>
            <param name="uid">Entity UID to check.</param>
            <param name="component">Component of the specified type (if exists).</param>
            <returns>If the component existed in the entity.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.TryGetComponent``1(System.Nullable{Robust.Shared.GameObjects.EntityUid},``0@)">
            <summary>
                Returns the component of a specific type.
            </summary>
            <typeparam name="T">A trait or type of a component to retrieve.</typeparam>
            <param name="uid">Entity UID to check.</param>
            <param name="component">Component of the specified type (if exists).</param>
            <returns>If the component existed in the entity.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.TryGetComponent(Robust.Shared.GameObjects.EntityUid,System.Type,Robust.Shared.GameObjects.IComponent@)">
            <summary>
                Returns the component of a specific type.
            </summary>
            <param name="uid">Entity UID to check.</param>
            <param name="type">A trait or component type to check for.</param>
            <param name="component">Component of the specified type (if exists).</param>
            <returns>If the component existed in the entity.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.TryGetComponent(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.CompIdx,Robust.Shared.GameObjects.IComponent@)">
            <summary>
                Returns the component of a specific type.
            </summary>
            <param name="uid">Entity UID to check.</param>
            <param name="type">A trait or component type to check for.</param>
            <param name="component">Component of the specified type (if exists).</param>
            <returns>If the component existed in the entity.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.TryGetComponent(System.Nullable{Robust.Shared.GameObjects.EntityUid},System.Type,Robust.Shared.GameObjects.IComponent@)">
            <summary>
                Returns the component of a specific type.
            </summary>
            <param name="uid">Entity UID to check.</param>
            <param name="type">A trait or component type to check for.</param>
            <param name="component">Component of the specified type (if exists).</param>
            <returns>If the component existed in the entity.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.TryGetComponent(Robust.Shared.GameObjects.EntityUid,System.UInt16,Robust.Shared.GameObjects.IComponent@,Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
                Returns the component with a specified network ID. This does not check
                if the component is deleted.
            </summary>
            <param name="uid">Entity UID to check.</param>
            <param name="netId">Component Network ID to check for.</param>
            <param name="component">Component with the specified network id.</param>
            <returns>If the component existed in the entity.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.TryGetComponent(System.Nullable{Robust.Shared.GameObjects.EntityUid},System.UInt16,Robust.Shared.GameObjects.IComponent@,Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
                Returns the component with a specified network ID. This does not check
                if the component is deleted.
            </summary>
            <param name="uid">Entity UID to check.</param>
            <param name="netId">Component Network ID to check for.</param>
            <param name="component">Component with the specified network id.</param>
            <returns>If the component existed in the entity.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.GetEntityQuery``1">
            <summary>
            Returns a cached struct enumerator with the specified component.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.GetComponents(Robust.Shared.GameObjects.EntityUid)">
            <summary>
                Returns ALL component type instances on an entity. A single component instance
                can have multiple component types.
            </summary>
            <param name="uid">Entity UID to look on.</param>
            <returns>All component types on the Entity.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.GetComponents``1(Robust.Shared.GameObjects.EntityUid)">
            <summary>
                Returns ALL component type instances that are assignable to the specified type.
                A single component instance can have multiple component type instances.
            </summary>
            <typeparam name="T">A trait or type of a component to retrieve.</typeparam>
            <param name="uid">Entity UID to look on.</param>
            <returns>All components that are assignable to the specified type.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.ComponentCount(Robust.Shared.GameObjects.EntityUid)">
            <summary>
            Returns the number of components on this entity.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.GetNetComponents(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
                Returns ALL networked components on an entity, including deleted ones.
            </summary>
            <param name="uid">Entity UID to look on.</param>
            <returns>All components that have a network ID.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.GetNetComponentsOrNull(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
                Returns ALL networked components on an entity, including deleted ones. Returns null if the entity does
                not exist.
            </summary>
            <param name="uid">Entity UID to look on.</param>
            <returns>All components that have a network ID.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.GetComponentState(Robust.Shared.GameObjects.IEventBus,Robust.Shared.GameObjects.IComponent,Robust.Shared.Player.ICommonSession,Robust.Shared.Timing.GameTick)">
            <summary>
                Gets a component state.
            </summary>
            <param name="eventBus">A reference to the event bus instance.</param>
            <param name="component">Component to generate the state for.</param>
            <param name="player">The player that is going to receive this state. Null implies that this state is for a replay.</param>
            <param name="fromTick">The from tick, which indicates the range of data that must be included for delta-states.</param>
            <returns>The component state of the component.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.CanGetComponentState(Robust.Shared.GameObjects.IEventBus,Robust.Shared.GameObjects.IComponent,Robust.Shared.Player.ICommonSession)">
            <summary>
                Checks if a certain player should get a component state.
            </summary>
            <param name="eventBus">A reference to the event bus instance.</param>
            <param name="component">Component to generate the state for.</param>
            <param name="player">The player to generate the state for.</param>
            <returns>True if the player should get the component state.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.AllComponents``1">
            <summary>
            Returns all instances of a component in an array.
            Use sparingly.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.AllComponentsList``1">
            <summary>
            Returns all instances of a component in a List.
            Use sparingly.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.ComponentQueryEnumerator(Robust.Shared.Prototypes.ComponentRegistry)">
            <summary>
            <see cref="M:Robust.Shared.GameObjects.IEntityManager.ComponentQueryEnumerator(Robust.Shared.Prototypes.ComponentRegistry)"/>
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.CompRegistryQueryEnumerator(Robust.Shared.Prototypes.ComponentRegistry)">
            <summary>
            <see cref="M:Robust.Shared.GameObjects.IEntityManager.CompRegistryQueryEnumerator(Robust.Shared.Prototypes.ComponentRegistry)"/>
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.EntityQuery``1(System.Boolean)">
            <summary>
                Returns ALL component instances of a specified type.
            </summary>
            <typeparam name="T">A trait or type of a component to retrieve.</typeparam>
            <returns>All components that have the specified type.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.EntityQuery``2(System.Boolean)">
            <summary>
            Returns the relevant components from all entities that contain the two required components.
            </summary>
            <typeparam name="TComp1">First required component.</typeparam>
            <typeparam name="TComp2">Second required component.</typeparam>
            <returns>The pairs of components from each entity that has the two required components.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.EntityQuery``3(System.Boolean)">
            <summary>
            Returns the relevant components from all entities that contain the three required components.
            </summary>
            <typeparam name="TComp1">First required component.</typeparam>
            <typeparam name="TComp2">Second required component.</typeparam>
            <typeparam name="TComp3">Third required component.</typeparam>
            <returns>The pairs of components from each entity that has the three required components.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.EntityQuery``4(System.Boolean)">
            <summary>
            Returns the relevant components from all entities that contain the four required components.
            </summary>
            <typeparam name="TComp1">First required component.</typeparam>
            <typeparam name="TComp2">Second required component.</typeparam>
            <typeparam name="TComp3">Third required component.</typeparam>
            <typeparam name="TComp4">Fourth required component.</typeparam>
            <returns>The pairs of components from each entity that has the four required components.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.GetAllComponents(System.Type,System.Boolean)">
            <summary>
                 Returns ALL component instances of a specified type.
            </summary>
            <param name="type">A trait or component type to check for.</param>
            <param name="includePaused"></param>
            <returns>All components that are the specified type.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.CullRemovedComponents">
            <summary>
                Culls all components from the collection that are marked as deleted. This needs to be called often.
            </summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.IEntityManager.CurrentTick">
            <summary>
                The current simulation tick being processed.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.Cleanup">
            <summary>
                Drops every entity, component and entity system.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.FlushEntities">
            <summary>
                Deletes all entities.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.TickUpdate(System.Single,System.Boolean,Prometheus.Histogram)">
            <param name="noPredictions">
            Only run systems with <see cref="P:Robust.Shared.GameObjects.EntitySystem.UpdatesOutsidePrediction"/> set true.
            </param>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.FrameUpdate(System.Single)">
            <summary>
                Client-specific per-render frame updating.
            </summary>
        </member>
        <member name="E:Robust.Shared.GameObjects.IEntityManager.EntityDirtied">
            <summary>
            Invoked when an entity gets dirtied. This only gets raised after initialization, and at most once per tick.
            </summary>
        </member>
        <member name="E:Robust.Shared.GameObjects.IEntityManager.BeforeEntityFlush">
            <summary>
            Invoked just before all entities get deleted. See <see cref="M:Robust.Shared.GameObjects.IEntityManager.FlushEntities"/>.
            </summary>
        </member>
        <member name="E:Robust.Shared.GameObjects.IEntityManager.AfterEntityFlush">
            <summary>
            Invoked just after all entities got deleted. See <see cref="M:Robust.Shared.GameObjects.IEntityManager.FlushEntities"/>.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.CreateEntityUninitialized(System.String,Robust.Shared.GameObjects.EntityUid,Robust.Shared.Prototypes.ComponentRegistry)">
            <summary>
            Creates an uninitialized entity.
            </summary>
            <param name="prototypeName"><inheritdoc cref="M:Robust.Shared.GameObjects.IEntityManager.CreateEntityUninitialized(System.String,Robust.Shared.Map.MapCoordinates,Robust.Shared.Prototypes.ComponentRegistry,Robust.Shared.Maths.Angle)"/></param>
            <param name="euid">Does nothing. Used to be the forced EntityUid of the new entity.</param>
            <param name="overrides"><inheritdoc cref="M:Robust.Shared.GameObjects.IEntityManager.CreateEntityUninitialized(System.String,Robust.Shared.Map.MapCoordinates,Robust.Shared.Prototypes.ComponentRegistry,Robust.Shared.Maths.Angle)"/></param>
            <returns><inheritdoc cref="M:Robust.Shared.GameObjects.IEntityManager.CreateEntityUninitialized(System.String,Robust.Shared.Map.MapCoordinates,Robust.Shared.Prototypes.ComponentRegistry,Robust.Shared.Maths.Angle)"/></returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.CreateEntityUninitialized(System.String,Robust.Shared.Prototypes.ComponentRegistry)">
            <summary>
            Creates an uninitialized entity.
            </summary>
            <param name="prototypeName"><inheritdoc cref="M:Robust.Shared.GameObjects.IEntityManager.CreateEntityUninitialized(System.String,Robust.Shared.Map.MapCoordinates,Robust.Shared.Prototypes.ComponentRegistry,Robust.Shared.Maths.Angle)"/></param>
            <param name="overrides"><inheritdoc cref="M:Robust.Shared.GameObjects.IEntityManager.CreateEntityUninitialized(System.String,Robust.Shared.Map.MapCoordinates,Robust.Shared.Prototypes.ComponentRegistry,Robust.Shared.Maths.Angle)"/></param>
            <returns><inheritdoc cref="M:Robust.Shared.GameObjects.IEntityManager.CreateEntityUninitialized(System.String,Robust.Shared.Map.MapCoordinates,Robust.Shared.Prototypes.ComponentRegistry,Robust.Shared.Maths.Angle)"/></returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.CreateEntityUninitialized(System.String,Robust.Shared.Map.EntityCoordinates,Robust.Shared.Prototypes.ComponentRegistry,Robust.Shared.Maths.Angle)">
            <summary>
            Creates an uninitialized entity and sets its position to the EntityCoordinates provided.
            </summary>
            <param name="prototypeName"><inheritdoc cref="M:Robust.Shared.GameObjects.IEntityManager.CreateEntityUninitialized(System.String,Robust.Shared.Map.MapCoordinates,Robust.Shared.Prototypes.ComponentRegistry,Robust.Shared.Maths.Angle)"/></param>
            <param name="coordinates">Coordinates to set position and parent of the newly spawned entity to.</param>
            <param name="overrides"><inheritdoc cref="M:Robust.Shared.GameObjects.IEntityManager.CreateEntityUninitialized(System.String,Robust.Shared.Map.MapCoordinates,Robust.Shared.Prototypes.ComponentRegistry,Robust.Shared.Maths.Angle)"/></param>
            <returns><inheritdoc cref="M:Robust.Shared.GameObjects.IEntityManager.CreateEntityUninitialized(System.String,Robust.Shared.Map.MapCoordinates,Robust.Shared.Prototypes.ComponentRegistry,Robust.Shared.Maths.Angle)"/></returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.CreateEntityUninitialized(System.String,Robust.Shared.Map.MapCoordinates,Robust.Shared.Prototypes.ComponentRegistry,Robust.Shared.Maths.Angle)">
            <summary>
            Creates an uninitialized entity and puts it on the grid or map at the MapCoordinates provided.
            </summary>
            <param name="prototypeName">Name of the <see cref="T:Robust.Shared.Prototypes.EntityPrototype"/> to spawn.</param>
            <param name="coordinates">Coordinates to place the newly spawned entity.</param>
            <param name="overrides">Overrides to add or remove components that differ from the prototype.</param>
            <param name="rotation">Map rotation to set the newly spawned entity to.</param>
            <returns>A new uninitialized entity.</returns>
            <remarks>If there is a grid at the <paramref name="coordinates"/>, the entity will be parented to the grid.
            Otherwise, it will be parented to the map.</remarks>
        </member>
        <member name="P:Robust.Shared.GameObjects.IEntityManager.EntityCount">
            <summary>
            How many entities are currently active.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.GetEntities">
            <summary>
            Returns all entities
            </summary>
            <returns></returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.TryQueueDeleteEntity(System.Nullable{Robust.Shared.GameObjects.EntityUid})">
            <summary>
            Tries to QueueDeleteEntity if the entity is not already deleted.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.DeleteEntity(System.Nullable{Robust.Shared.GameObjects.EntityUid})">
            <summary>
            Shuts-down and removes the entity with the given <see cref="T:Robust.Shared.GameObjects.EntityUid"/>. This is also broadcast to all clients.
            </summary>
            <param name="uid">Uid of entity to remove.</param>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.DeleteEntity(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent,Robust.Shared.GameObjects.TransformComponent)">
            <summary>
            Shuts-down and removes the entity with the given <see cref="T:Robust.Shared.GameObjects.EntityUid"/>. This is also broadcast to all clients.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.EntityExists(Robust.Shared.GameObjects.EntityUid)">
            <summary>
            Checks whether an entity with the specified ID exists.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.EntityExists(System.Nullable{Robust.Shared.GameObjects.EntityUid})">
            <summary>
            Checks whether an entity with the specified ID exists.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.IsPaused(System.Nullable{Robust.Shared.GameObjects.EntityUid},Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
            Returns true if entity is valid and paused.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.Deleted(Robust.Shared.GameObjects.EntityUid)">
            <summary>
            Checks whether an entity with the specified ID has been deleted or is nonexistent.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.Deleted(System.Nullable{Robust.Shared.GameObjects.EntityUid})">
            <summary>
            Checks whether an entity with the specified ID has been deleted or is nonexistent.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.ToPrettyString(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
            Returns a string representation of an entity with various information regarding it.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.ToPrettyString(Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.MetaDataComponent})">
            <summary>
            Returns a string representation of an entity with various information regarding it.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.ToPrettyString(Robust.Shared.GameObjects.NetEntity)">
            <summary>
            Returns a string representation of an entity with various information regarding it.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.ToPrettyString(System.Nullable{Robust.Shared.GameObjects.EntityUid},Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
            Returns a string representation of an entity with various information regarding it.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.ToPrettyString(System.Nullable{Robust.Shared.GameObjects.NetEntity})">
            <summary>
            Returns a string representation of an entity with various information regarding it.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.RaisePredictiveEvent``1(``0)">
            <summary>
                Sends a networked message to the server, while also repeatedly raising it locally for every time this tick gets re-predicted.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.TryParseNetEntity(System.String,System.Nullable{Robust.Shared.GameObjects.EntityUid}@)">
            <summary>
            Tries to parse a string as a NetEntity and return the relevant EntityUid.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.TryGetEntity(Robust.Shared.GameObjects.NetEntity,System.Nullable{Robust.Shared.GameObjects.EntityUid}@)">
            <summary>
            TryGet version of <see cref="M:Robust.Shared.GameObjects.IEntityManager.GetEntity(Robust.Shared.GameObjects.NetEntity)"/>
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.TryGetEntity(System.Nullable{Robust.Shared.GameObjects.NetEntity},System.Nullable{Robust.Shared.GameObjects.EntityUid}@)">
            <summary>
            TryGet version of <see cref="M:Robust.Shared.GameObjects.IEntityManager.GetEntity(Robust.Shared.GameObjects.NetEntity)"/>
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.TryGetEntityData(Robust.Shared.GameObjects.NetEntity,System.Nullable{Robust.Shared.GameObjects.EntityUid}@,Robust.Shared.GameObjects.MetaDataComponent@)">
            <summary>
            Tries to returns the corresponding local <see cref="T:Robust.Shared.GameObjects.EntityUid"/> along with the metdata component.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.TryGetNetEntity(Robust.Shared.GameObjects.EntityUid,System.Nullable{Robust.Shared.GameObjects.NetEntity}@,Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
            TryGet version of <see cref="M:Robust.Shared.GameObjects.IEntityManager.GetNetEntity(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)"/>
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.TryGetNetEntity(System.Nullable{Robust.Shared.GameObjects.EntityUid},System.Nullable{Robust.Shared.GameObjects.NetEntity}@,Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
            TryGet version of <see cref="M:Robust.Shared.GameObjects.IEntityManager.GetNetEntity(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)"/>
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.IsClientSide(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
            Returns true if the entity only exists on the client.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.EnsureEntity``1(Robust.Shared.GameObjects.NetEntity,Robust.Shared.GameObjects.EntityUid)">
            <summary>
            Tries to get a corresponding <see cref="T:Robust.Shared.GameObjects.EntityUid"/> if it exists, otherwise creates an entity for it.
            </summary>
            <param name="nEntity">The net entity we're trying to resolve.</param>
            <param name="T">The type of the component that may need its state handling run later.</param>
            <param name="callerEntity">The entity trying to resolve the net entity. This may be flagged for later component state handling.</param>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.EnsureEntity``1(System.Nullable{Robust.Shared.GameObjects.NetEntity},Robust.Shared.GameObjects.EntityUid)">
            <summary>
            Tries to get a corresponding <see cref="T:Robust.Shared.GameObjects.EntityUid"/> if it exists and nEntity is not null.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.GetEntity(Robust.Shared.GameObjects.NetEntity)">
            <summary>
            Returns the corresponding local <see cref="T:Robust.Shared.GameObjects.EntityUid"/>.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.GetEntity(System.Nullable{Robust.Shared.GameObjects.NetEntity})">
            <summary>
            Returns the corresponding local <see cref="T:Robust.Shared.GameObjects.EntityUid"/>.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.GetNetEntity(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
            Returns the corresponding <see cref="T:Robust.Shared.GameObjects.NetEntity"/> for the local entity.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.GetNetEntity(System.Nullable{Robust.Shared.GameObjects.EntityUid},Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
            Returns the corresponding <see cref="T:Robust.Shared.GameObjects.NetEntity"/> for the local entity.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.GetEntitySet(System.Collections.Generic.HashSet{Robust.Shared.GameObjects.NetEntity})">
            <summary>
            HashSet version of <see cref="M:Robust.Shared.GameObjects.IEntityManager.GetEntity(Robust.Shared.GameObjects.NetEntity)"/>
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.GetEntityList(System.Collections.Generic.List{Robust.Shared.GameObjects.NetEntity})">
            <summary>
            List version of <see cref="M:Robust.Shared.GameObjects.IEntityManager.GetEntity(Robust.Shared.GameObjects.NetEntity)"/>
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.GetEntityList(System.Collections.Generic.ICollection{Robust.Shared.GameObjects.NetEntity})">
            <summary>
            List version of <see cref="M:Robust.Shared.GameObjects.IEntityManager.GetEntity(Robust.Shared.GameObjects.NetEntity)"/>
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.GetEntityList(System.Collections.Generic.List{System.Nullable{Robust.Shared.GameObjects.NetEntity}})">
            <summary>
            List version of <see cref="M:Robust.Shared.GameObjects.IEntityManager.GetEntity(Robust.Shared.GameObjects.NetEntity)"/>
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.GetEntityArray(Robust.Shared.GameObjects.NetEntity[])">
            <summary>
            List version of <see cref="M:Robust.Shared.GameObjects.IEntityManager.GetEntity(Robust.Shared.GameObjects.NetEntity)"/>
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.GetEntityArray(System.Nullable{Robust.Shared.GameObjects.NetEntity}[])">
            <summary>
            List version of <see cref="M:Robust.Shared.GameObjects.IEntityManager.GetEntity(Robust.Shared.GameObjects.NetEntity)"/>
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.GetEntityDictionary``1(System.Collections.Generic.Dictionary{Robust.Shared.GameObjects.NetEntity,``0})">
            <summary>
            Dictionary version of <see cref="M:Robust.Shared.GameObjects.IEntityManager.GetEntity(Robust.Shared.GameObjects.NetEntity)"/>
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.GetEntityDictionary``1(System.Collections.Generic.Dictionary{``0,Robust.Shared.GameObjects.NetEntity})">
            <summary>
            Dictionary version of <see cref="M:Robust.Shared.GameObjects.IEntityManager.GetEntity(Robust.Shared.GameObjects.NetEntity)"/>
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.GetNetEntitySet(System.Collections.Generic.HashSet{Robust.Shared.GameObjects.EntityUid})">
            <summary>
            HashSet version of <see cref="M:Robust.Shared.GameObjects.IEntityManager.GetNetEntity(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)"/>
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.GetNetEntityList(System.Collections.Generic.List{Robust.Shared.GameObjects.EntityUid})">
            <summary>
            List version of <see cref="M:Robust.Shared.GameObjects.IEntityManager.GetNetEntity(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)"/>
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.GetNetEntityList(System.Collections.Generic.IReadOnlyList{Robust.Shared.GameObjects.EntityUid})">
            <summary>
            List version of <see cref="M:Robust.Shared.GameObjects.IEntityManager.GetNetEntity(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)"/>
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.GetNetEntityList(System.Collections.Generic.ICollection{Robust.Shared.GameObjects.EntityUid})">
            <summary>
            List version of <see cref="M:Robust.Shared.GameObjects.IEntityManager.GetNetEntity(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)"/>
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.GetNetEntityList(System.Collections.Generic.List{System.Nullable{Robust.Shared.GameObjects.EntityUid}})">
            <summary>
            List version of <see cref="M:Robust.Shared.GameObjects.IEntityManager.GetNetEntity(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)"/>
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.GetNetEntityArray(Robust.Shared.GameObjects.EntityUid[])">
            <summary>
            Array version of <see cref="M:Robust.Shared.GameObjects.IEntityManager.GetNetEntity(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)"/>
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.GetNetEntityArray(System.Nullable{Robust.Shared.GameObjects.EntityUid}[])">
            <summary>
            Array version of <see cref="M:Robust.Shared.GameObjects.IEntityManager.GetNetEntity(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)"/>
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.GetNetEntityDictionary``1(System.Collections.Generic.Dictionary{Robust.Shared.GameObjects.EntityUid,``0})">
            <summary>
            Dictionary version of <see cref="M:Robust.Shared.GameObjects.IEntityManager.GetNetEntity(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)"/>
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.GetNetEntityDictionary``1(System.Collections.Generic.Dictionary{``0,Robust.Shared.GameObjects.EntityUid})">
            <summary>
            Dictionary version of <see cref="M:Robust.Shared.GameObjects.IEntityManager.GetNetEntity(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)"/>
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.GetNetEntityDictionary``1(System.Collections.Generic.Dictionary{``0,System.Nullable{Robust.Shared.GameObjects.EntityUid}})">
            <summary>
            Dictionary version of <see cref="M:Robust.Shared.GameObjects.IEntityManager.GetNetEntity(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)"/>
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.GetNetEntityDictionary(System.Collections.Generic.Dictionary{Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.EntityUid})">
            <summary>
            Dictionary version of <see cref="M:Robust.Shared.GameObjects.IEntityManager.GetNetEntity(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)"/>
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.GetNetEntityDictionary(System.Collections.Generic.Dictionary{Robust.Shared.GameObjects.EntityUid,System.Nullable{Robust.Shared.GameObjects.EntityUid}})">
            <summary>
            Dictionary version of <see cref="M:Robust.Shared.GameObjects.IEntityManager.GetNetEntity(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)"/>
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.GetNetCoordinates(Robust.Shared.Map.EntityCoordinates,Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
            Returns the corresponding <see cref="T:Robust.Shared.Map.NetCoordinates"/> for the specified local coordinates.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.GetNetCoordinates(System.Nullable{Robust.Shared.Map.EntityCoordinates},Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
            Returns the corresponding <see cref="T:Robust.Shared.Map.NetCoordinates"/> for the specified local coordinates.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.GetCoordinates(Robust.Shared.Map.NetCoordinates)">
            <summary>
            Returns the corresponding <see cref="T:Robust.Shared.Map.EntityCoordinates"/> for the specified network coordinates.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.GetCoordinates(System.Nullable{Robust.Shared.Map.NetCoordinates})">
            <summary>
            Returns the corresponding <see cref="T:Robust.Shared.Map.EntityCoordinates"/> for the specified network coordinates.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.EnsureCoordinates``1(Robust.Shared.Map.NetCoordinates,Robust.Shared.GameObjects.EntityUid)">
            <summary>
            Tries to get a corresponding <see cref="T:Robust.Shared.Map.EntityCoordinates"/> if it exists, otherwise creates an entity for it.
            </summary>
            <param name="netCoordinates">The net coordinates we're trying to resolve.</param>
            <param name="T">The type of the component that may need its state handling run later.</param>
            <param name="callerEntity">The entity trying to resolve the net entity. This may be flagged for later component state handling.</param>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.EnsureCoordinates``1(System.Nullable{Robust.Shared.Map.NetCoordinates},Robust.Shared.GameObjects.EntityUid)">
            <summary>
            Tries to get a corresponding <see cref="T:Robust.Shared.Map.EntityCoordinates"/> if it exists and nEntity is not null.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.GetEntityData(Robust.Shared.GameObjects.NetEntity)">
            <summary>
            Returns the corresponding local <see cref="T:Robust.Shared.GameObjects.EntityUid"/> along with the metdata component.
            throws an exception if the net entity does not exist.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.Spawn(System.String,Robust.Shared.Prototypes.ComponentRegistry,System.Boolean)">
            <summary>
            Spawns an entity in nullspace.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.Spawn(System.String,Robust.Shared.Map.MapCoordinates,Robust.Shared.Prototypes.ComponentRegistry,Robust.Shared.Maths.Angle)">
            <summary>
            Spawns an entity at a specific world position. The entity will either be parented to the map or a grid.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.SpawnAttachedTo(System.String,Robust.Shared.Map.EntityCoordinates,Robust.Shared.Prototypes.ComponentRegistry,Robust.Shared.Maths.Angle)">
            <summary>
            Spawns an entity and then parents it to the entity that the given entity coordinates are relative to.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.SpawnAtPosition(System.String,Robust.Shared.Map.EntityCoordinates,Robust.Shared.Prototypes.ComponentRegistry)">
            <summary>
            Resolves the given entity coordinates into world coordinates and spawns an entity at that location. The
            entity will either be parented to the map or a grid.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.TrySpawnInContainer(System.String,Robust.Shared.GameObjects.EntityUid,System.String,System.Nullable{Robust.Shared.GameObjects.EntityUid}@,Robust.Shared.Containers.ContainerManagerComponent,Robust.Shared.Prototypes.ComponentRegistry)">
            <summary>
            Attempt to spawn an entity and insert it into a container. If the insertion fails, the entity gets deleted.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.SpawnInContainerOrDrop(System.String,Robust.Shared.GameObjects.EntityUid,System.String,Robust.Shared.GameObjects.TransformComponent,Robust.Shared.Containers.ContainerManagerComponent,Robust.Shared.Prototypes.ComponentRegistry)">
            <summary>
            Attempts to spawn an entity inside of a container. If it fails to insert into the container, it will
            instead drop the entity next to the target (see <see cref="M:Robust.Shared.GameObjects.IEntityManager.SpawnNextToOrDrop(System.String,Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.TransformComponent,Robust.Shared.Prototypes.ComponentRegistry)"/>).
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.SpawnInContainerOrDrop(System.String,Robust.Shared.GameObjects.EntityUid,System.String,System.Boolean@,Robust.Shared.GameObjects.TransformComponent,Robust.Shared.Containers.ContainerManagerComponent,Robust.Shared.Prototypes.ComponentRegistry)">
            <inheritdoc cref="M:Robust.Shared.GameObjects.IEntityManager.SpawnInContainerOrDrop(System.String,Robust.Shared.GameObjects.EntityUid,System.String,Robust.Shared.GameObjects.TransformComponent,Robust.Shared.Containers.ContainerManagerComponent,Robust.Shared.Prototypes.ComponentRegistry)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.TrySpawnNextTo(System.String,Robust.Shared.GameObjects.EntityUid,System.Nullable{Robust.Shared.GameObjects.EntityUid}@,Robust.Shared.GameObjects.TransformComponent,Robust.Shared.Prototypes.ComponentRegistry)">
            <summary>
            Attempts to spawn an entity adjacent to some other target entity. If the target entity is in
            a container, this will attempt to insert the spawned entity into the same container. If the insertion fails,
            the entity is deleted. If the entity is not in a container, this behaves like <see cref="M:Robust.Shared.GameObjects.IEntityManager.SpawnNextToOrDrop(System.String,Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.TransformComponent,Robust.Shared.Prototypes.ComponentRegistry)"/>.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.SpawnNextToOrDrop(System.String,Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.TransformComponent,Robust.Shared.Prototypes.ComponentRegistry)">
            <summary>
            Attempts to spawn an entity adjacent to some other entity. If the other entity is in a container, this will
            attempt to insert the new entity into the same container. If it fails to insert into the container, it will
            instead attempt to spawn the entity next to the target's parent.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.System``1">
            <summary>
            Get an entity system of the specified type.
            </summary>
            <typeparam name="T">The type of entity system to find.</typeparam>
            <returns>The <see cref="T:Robust.Shared.GameObjects.IEntitySystem"/> instance matching the specified type.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.SystemOrNull``1">
            <summary>
            Get an entity system of the specified type, or null if it is not registered.
            </summary>
            <typeparam name="T">The type of entity system to find.</typeparam>
            <returns>The <see cref="T:Robust.Shared.GameObjects.IEntitySystem"/> instance matching the specified type, or null.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityManager.TrySystem``1(``0@)">
            <summary>
            Tries to get an entity system of the specified type.
            </summary>
            <typeparam name="T">Type of entity system to find.</typeparam>
            <param name="entitySystem">instance matching the specified type (if exists).</param>
            <returns>If an instance of the specified entity system type exists.</returns>
        </member>
        <member name="T:Robust.Shared.GameObjects.IEntityNetworkManager">
            <summary>
            Manages the sending and receiving of network messages between the server and client(s).
            </summary>
        </member>
        <member name="E:Robust.Shared.GameObjects.IEntityNetworkManager.ReceivedSystemMessage">
            <summary>
            This event is raised when a system message comes in from the network.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityNetworkManager.SetupNetworking">
            <summary>
            Initializes networking for this manager. This should only be called once.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityNetworkManager.SendSystemNetworkMessage(Robust.Shared.GameObjects.EntityEventArgs,System.Boolean)">
            <summary>
            Sends an Entity System Message to relevant System(s).
            Client: Sends the message to the relevant server side System(s).
            Server: Sends the message to the relevant systems of all connected clients.
            Server: Use the alternative overload to send to a single client.
            </summary>
            <param name="message">Message that should be sent.</param>
            <param name="recordReplay">Whether or not this message should be saved to replays.</param>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntityNetworkManager.SendSystemNetworkMessage(Robust.Shared.GameObjects.EntityEventArgs,Robust.Shared.Network.INetChannel)">
            <summary>
            Sends an Entity System Message to relevant System on a client.
            Server: Sends the message to the relevant systems of the client on <paramref name="channel"/>
            </summary>
            <param name="message">Message that should be sent.</param>
            <param name="channel">The client to send the message to.</param>
            <exception cref="T:System.NotSupportedException">
               Thrown if called on the client.
            </exception>
        </member>
        <member name="T:Robust.Shared.GameObjects.IEntitySystem">
            <summary>
                A subsystem that acts on all components of a type at once.
                Entity systems are similar to TGstation13 subsystems.
                They have a set of entities to run over and run every once in a while.
                They get managed by an <see cref="T:Robust.Shared.GameObjects.IEntitySystemManager" />.
            </summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.IEntitySystem.UpdatesOutsidePrediction">
            <summary>
            If prediction is disabled on the client, <see cref="M:Robust.Shared.GameObjects.IEntitySystem.Update(System.Single)"/> will not be ran unless this flag is set.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntitySystem.Initialize">
            <summary>
                Called once when the system is created to initialize its state.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntitySystem.Shutdown">
            <summary>
                Called once before the system is destroyed so that the system can clean up.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntitySystem.Update(System.Single)">
            <summary>
                Called once per frame/tick to update the system.
            </summary>
            <param name="frameTime">Delta time since Update() was last called.</param>
        </member>
        <member name="T:Robust.Shared.GameObjects.IEntitySystemManager">
            <summary>
            Like SS13's master controller. It controls <see cref="T:Robust.Shared.GameObjects.IEntitySystem"/> instances.
            These instances have set of rules for which components they can run over.
            </summary>
            <remarks>
            The management of these amounts to a couple of things:
            <list type="bullet">
            <item>
            <description>Periodically ticking them through <see cref="M:Robust.Shared.GameObjects.IEntitySystem.Update(System.Single)"/>.</description>
            </item>
            </list>
            Periodically ticks <see cref="T:Robust.Shared.GameObjects.IEntitySystem"/> instances.
            </remarks>
            <seealso cref="T:Robust.Shared.GameObjects.IEntitySystem"/>
        </member>
        <member name="E:Robust.Shared.GameObjects.IEntitySystemManager.SystemLoaded">
            <summary>
            A new entity system has been loaded into the manager.
            </summary>
        </member>
        <member name="E:Robust.Shared.GameObjects.IEntitySystemManager.SystemUnloaded">
            <summary>
            An existing entity system has been unloaded from the manager.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntitySystemManager.GetEntitySystem``1">
            <summary>
            Get an entity system of the specified type.
            </summary>
            <typeparam name="T">The type of entity system to find.</typeparam>
            <returns>The <see cref="T:Robust.Shared.GameObjects.IEntitySystem"/> instance matching the specified type.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntitySystemManager.GetEntitySystemOrNull``1">
            <summary>
            Get an entity system of the specified type, or null if it is not registered.
            </summary>
            <typeparam name="T">The type of entity system to find.</typeparam>
            <returns>The <see cref="T:Robust.Shared.GameObjects.IEntitySystem"/> instance matching the specified type, or null.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntitySystemManager.Resolve``1(``0@)">
            <summary>
            Resolves an entity system.
            </summary>
            <exception cref="T:Robust.Shared.IoC.Exceptions.UnregisteredTypeException">Thrown if the provided type is not registered.</exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown if the resolved type hasn't been created yet
            because the dependency collection object graph still needs to be constructed for it.
            </exception>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntitySystemManager.Resolve``2(``0@,``1@)">
            <inheritdoc cref="!:Resolve&lt;T&gt;(ref T?)"/>
            <summary>
            Resolve two entity systems.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntitySystemManager.Resolve``3(``0@,``1@,``2@)">
            <inheritdoc cref="!:Resolve&lt;T1, T2&gt;(ref T1?, ref T2?)"/>
            <summary>
            Resolve three entity systems.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntitySystemManager.Resolve``4(``0@,``1@,``2@,``3@)">
            <inheritdoc cref="!:Resolve&lt;T1, T2, T3&gt;(ref T1?, ref T2?, ref T3?)"/>
            <summary>
            Resolve four entity systems.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntitySystemManager.TryGetEntitySystem``1(``0@)">
            <summary>
            Tries to get an entity system of the specified type.
            </summary>
            <typeparam name="T">Type of entity system to find.</typeparam>
            <param name="entitySystem">instance matching the specified type (if exists).</param>
            <returns>If an instance of the specified entity system type exists.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntitySystemManager.Initialize(System.Boolean)">
            <summary>
            Initialize, discover systems and initialize them through <see cref="M:Robust.Shared.GameObjects.IEntitySystem.Initialize"/>.
            </summary>
            <param name="discover">Whether we should automatically find systems or have they been supplied already.</param>
            <seealso cref="M:Robust.Shared.GameObjects.IEntitySystem.Initialize"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntitySystemManager.Shutdown">
            <summary>
            Clean up, shut down all systems through <see cref="M:Robust.Shared.GameObjects.IEntitySystem.Shutdown"/> and remove them.
            </summary>
            <seealso cref="M:Robust.Shared.GameObjects.IEntitySystem.Shutdown"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntitySystemManager.TickUpdate(System.Single,System.Boolean)">
            <summary>
            Update all systems.
            </summary>
            <param name="frameTime">Time since the last frame was rendered.</param>
            <param name="noPredictions">
            Only run systems with <see cref="P:Robust.Shared.GameObjects.EntitySystem.UpdatesOutsidePrediction"/> set true.
            </param>
            <seealso cref="M:Robust.Shared.GameObjects.IEntitySystem.Update(System.Single)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.IEntitySystemManager.LoadExtraSystemType``1">
            <summary>
                Adds an extra entity system type that otherwise would not be loaded automatically, useful for testing.
            </summary>
            <typeparam name="T">The type of the entity system to load.</typeparam>
            <exception cref="T:System.InvalidOperationException">
            Thrown if the manager has been initialized already.
            </exception>
        </member>
        <member name="T:Robust.Shared.GameObjects.MapInitEvent">
            <summary>
                Raised directed on an entity when the map is initialized.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.NetEntity">
            <summary>
            Network identifier for entities; used by client and server to refer to the same entity where their local <see cref="T:Robust.Shared.GameObjects.EntityUid"/> may differ.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.NetEntity.Invalid">
            <summary>
                An Invalid entity UID you can compare against.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.NetEntity.First">
            <summary>
                The first entity UID the entityManager should use when the manager is initialized.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.NetEntity.#ctor(System.Int32)">
            <summary>
                Creates an instance of this structure, with the given network ID.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.NetEntity.Parse(System.ReadOnlySpan{System.Char})">
            <summary>
                Creates a network entity UID by parsing a string number.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.NetEntity.IsValid">
            <summary>
                Checks if the ID value is valid. Does not check if it identifies
                a valid Entity.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.NetEntity.Equals(Robust.Shared.GameObjects.NetEntity)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.NetEntity.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.NetEntity.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.NetEntity.op_Equality(Robust.Shared.GameObjects.NetEntity,Robust.Shared.GameObjects.NetEntity)">
            <summary>
                Check for equality by value between two objects.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.NetEntity.op_Inequality(Robust.Shared.GameObjects.NetEntity,Robust.Shared.GameObjects.NetEntity)">
            <summary>
                Check for inequality by value between two objects.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.NetEntity.op_Explicit(Robust.Shared.GameObjects.NetEntity)~System.Int32">
            <summary>
                Explicit conversion of EntityId to int. This should only be used in special
                cases like serialization. Do NOT use this in content.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.NetEntity.ToString">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.NetEntity.CompareTo(Robust.Shared.GameObjects.NetEntity)">
            <inheritdoc />
        </member>
        <member name="T:Robust.Shared.GameObjects.PlacementReplacementComponent">
            <summary>
            If an entity with this component is placed on top of another anchored entity with this component and the same key it will replace it.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.PlacementReplacementComponent.InternalCopy(Robust.Shared.GameObjects.PlacementReplacementComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.PlacementReplacementComponent.Copy(Robust.Shared.GameObjects.PlacementReplacementComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.PlacementReplacementComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.PlacementReplacementComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.PlacementReplacementComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.PlacementReplacementComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.PlacementReplacementComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Shared.GameObjects.RobustMemoryManager">
            <summary>
            Generic memory manager for engine use.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityLookupSystem.AddEntitiesIntersecting(Robust.Shared.Map.MapId,System.Collections.Generic.HashSet{Robust.Shared.GameObjects.EntityUid},Robust.Shared.Physics.Collision.Shapes.IPhysShape,Robust.Shared.Physics.Transform,Robust.Shared.GameObjects.LookupFlags)">
            <summary>
            Wrapper around the per-grid version.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityLookupSystem.AnyEntitiesIntersecting(Robust.Shared.Map.MapId,Robust.Shared.Physics.Collision.Shapes.IPhysShape,Robust.Shared.Physics.Transform,Robust.Shared.GameObjects.LookupFlags,System.Nullable{Robust.Shared.GameObjects.EntityUid})">
            <summary>
            Wrapper around the per-grid version.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityLookupSystem.FindLookupsIntersecting(Robust.Shared.Map.MapId,Robust.Shared.Maths.Box2Rotated,Robust.Shared.GameObjects.ComponentQueryCallback{Robust.Shared.Physics.BroadphaseComponent})">
            <summary>
            Gets the relevant <see cref="T:Robust.Shared.Physics.BroadphaseComponent"/> that intersects the specified area.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityLookupSystem.IsIntersecting(Robust.Shared.Map.MapId,Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.TransformComponent,Robust.Shared.Physics.Collision.Shapes.IPhysShape,Robust.Shared.Physics.Transform,Robust.Shared.Maths.Box2,Robust.Shared.GameObjects.LookupFlags)">
            <summary>
            Common method to determine if an entity overlaps the specified shape.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityLookupSystem.UseBoundsQuery(System.Type,System.Single)">
            <summary>
            Should we just iterate every component and check position or do bounds checks.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityLookupSystem.UseBoundsQuery``1(System.Single)">
            <summary>
            Should we just iterate every component and check position or do bounds checks.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityLookupSystem.GetEntitiesOnMap``1(Robust.Shared.Map.MapId,System.Collections.Generic.HashSet{Robust.Shared.GameObjects.Entity{``0}})">
            <summary>
            Gets entities with the specified component with the specified map.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityLookupSystem.GetEntitiesOnMap``2(Robust.Shared.Map.MapId,System.Collections.Generic.HashSet{Robust.Shared.GameObjects.Entity{``0,``1}})">
            <summary>
            Gets entities with the specified component with the specified parent.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityLookupSystem.GetLocalEntitiesIntersecting``1(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Maths.Vector2i,System.Collections.Generic.HashSet{Robust.Shared.GameObjects.Entity{``0}},System.Single,Robust.Shared.GameObjects.LookupFlags,Robust.Shared.Map.Components.MapGridComponent)">
            <summary>
            Gets the entities intersecting the specified broadphase entity using a local AABB.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityLookupSystem.GetLocalEntitiesIntersecting``1(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Maths.Box2,System.Collections.Generic.HashSet{Robust.Shared.GameObjects.Entity{``0}},Robust.Shared.GameObjects.LookupFlags)">
            <summary>
            Gets the entities intersecting the specified broadphase entity using a local AABB.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityLookupSystem.GetLocalEntitiesIntersecting``1(Robust.Shared.GameObjects.Entity{Robust.Shared.Physics.BroadphaseComponent},Robust.Shared.Maths.Box2,System.Collections.Generic.HashSet{Robust.Shared.GameObjects.Entity{``0}},Robust.Shared.GameObjects.EntityQuery{``0},Robust.Shared.GameObjects.LookupFlags)">
            <summary>
            Gets the entities intersecting the specified broadphase entity using a local AABB.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityLookupSystem.GetChildEntities``1(Robust.Shared.GameObjects.EntityUid,System.Collections.Generic.HashSet{Robust.Shared.GameObjects.Entity{``0}})">
            <summary>
            Gets entities with the specified component with the specified parent.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityLookupSystem.GetChildEntities``2(Robust.Shared.GameObjects.EntityUid,System.Collections.Generic.HashSet{Robust.Shared.GameObjects.Entity{``0,``1}})">
            <summary>
            Gets entities with the specified component with the specified parent.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.EntityLookupSystem.TileEnlargementRadius">
            <summary>
            1 x 1 polygons can overlap neighboring tiles (even without considering the polygon skin around them.
            When querying for specific tile fixtures we shrink the bounds by this amount to avoid this overlap.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.EntityLookupSystem.LookupEpsilon">
            <summary>
            The minimum size an entity is assumed to be for point purposes.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.EntityLookupSystem.DefaultFlags">
            <summary>
            Returns all non-grid entities. Consider using your own flags if you wish for a faster query.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityLookupSystem.UpdateEntityTree(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.TransformComponent)">
            <summary>
                Variant of <see cref="!:FindAndAddToEntityTree(EntityUid, TransformComponent?)"/> that just re-adds the entity to the current tree (updates positions).
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityLookupSystem.RemoveFromEntityTree(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.TransformComponent)">
            <summary>
            Recursively iterates through this entity's children and removes them from the BroadphaseComponent.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityLookupSystem.RemoveFromEntityTree(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Physics.BroadphaseComponent,Robust.Shared.Physics.Dynamics.PhysicsMapComponent@,Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.TransformComponent,System.Boolean)">
            <summary>
            Recursively iterates through this entity's children and removes them from the BroadphaseComponent.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityLookupSystem.GetAABB(Robust.Shared.GameObjects.EntityUid,System.Numerics.Vector2,Robust.Shared.Maths.Angle,Robust.Shared.GameObjects.TransformComponent,Robust.Shared.GameObjects.EntityQuery{Robust.Shared.GameObjects.TransformComponent})">
            <summary>
            Get the AABB of an entity with the supplied position and angle. Tries to consider if the entity is in a container.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityLookupSystem.GetAABBNoContainer(Robust.Shared.GameObjects.EntityUid,System.Numerics.Vector2,Robust.Shared.Maths.Angle)">
            <summary>
            Get the AABB of an entity with the supplied position and angle without considering containers.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityLookupSystem.GetLocalEntitiesIntersecting(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Maths.Vector2i,System.Collections.Generic.HashSet{Robust.Shared.GameObjects.EntityUid},System.Single,Robust.Shared.GameObjects.LookupFlags,Robust.Shared.Map.Components.MapGridComponent)">
            <summary>
            Gets the entities intersecting the specified broadphase entity using a local AABB.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityLookupSystem.GetLocalEntitiesIntersecting(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Maths.Box2,System.Collections.Generic.HashSet{Robust.Shared.GameObjects.EntityUid},Robust.Shared.GameObjects.LookupFlags)">
            <summary>
            Gets the entities intersecting the specified broadphase entity using a local AABB.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityLookupSystem.GetLocalEntitiesIntersecting(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Maths.Box2Rotated,System.Collections.Generic.HashSet{Robust.Shared.GameObjects.EntityUid},Robust.Shared.GameObjects.LookupFlags)">
            <summary>
            Gets the entities intersecting the specified broadphase entity using a local Box2Rotated.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.EntityLookupSystem.GetLocalEntitiesIntersecting(Robust.Shared.GameObjects.EntityUid,System.Collections.Generic.IEnumerable{Robust.Shared.Maths.Vector2i},Robust.Shared.GameObjects.LookupFlags)">
            <summary>
            Returns the entities intersecting any of the supplied tiles. Faster than doing each tile individually.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.LookupFlags.Approximate">
            <summary>
            Should we use the approximately intersecting entities or check tighter bounds.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.LookupFlags.Dynamic">
            <summary>
            Should we query dynamic physics bodies.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.LookupFlags.Static">
            <summary>
            Should we query static physics bodies.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.LookupFlags.Sundries">
            <summary>
            Should we query non-collidable physics bodies.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.LookupFlags.Contained">
            <summary>
            Include entities that are currently in containers.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.LookupFlags.Sensors">
            <summary>
            Do we include non-hard fixtures.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.WorldAABBEvent">
            <summary>
            Raised on entities to try to get its WorldAABB.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.MetaDataSystem.GetPauseTime(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
            Gets how long this entity has been paused.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.MetaDataSystem.PauseOffset(Robust.Shared.GameObjects.EntityUid,System.TimeSpan@,Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
            Offsets the specified time by how long the entity has been paused.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.MetaDataSystem.RemoveFlag(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.MetaDataFlags,Robust.Shared.GameObjects.MetaDataComponent)">
            <summary>
            Attempts to remove the specific flag from metadata.
            Other systems can choose not to allow the removal if it's still relevant.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.MetaFlagRemoveAttemptEvent">
            <summary>
            Raised if <see cref="T:Robust.Shared.GameObjects.MetaDataSystem"/> is trying to remove a particular flag.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.PrototypeReloadSystem">
            <summary>
            Responsible for applying relevant changes to active entities when prototypes are reloaded.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedAppearanceSystem.QueueUpdate(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.AppearanceComponent)">
            <summary>
                Mark an appearance component as dirty, so that the appearance will get updated in the next frame update.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedAppearanceSystem.CopyData(Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.AppearanceComponent},Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.AppearanceComponent})">
            <summary>
            Copies appearance data from <c>src</c> to <c>dest</c>.
            If <c>src</c> has no <see cref="T:Robust.Shared.GameObjects.AppearanceComponent"/> nothing is done.
            If <c>dest</c> has no <c>AppearanceComponent</c> then it is created.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedAppearanceSystem.AppendData(Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.AppearanceComponent},Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.AppearanceComponent})">
            <summary>
            Appends appearance data from <c>src</c> to <c>dest</c>. If a key/value pair already exists in <c>dest</c>, it gets replaced.
            If <c>src</c> has no <see cref="T:Robust.Shared.GameObjects.AppearanceComponent"/> nothing is done.
            If <c>dest</c> has no <c>AppearanceComponent</c> then it is created.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.SharedDebugPhysicsSystem">
            <summary>
                Only reason this exists is so we can avoid the message allocation when not needed.
                It's only useful for debugging and is kind of a perf sink.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedEyeSystem.UpdateEye(Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.EyeComponent})">
            <summary>
            Refreshes all values for IEye with the component.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedEyeSystem.SetTarget(Robust.Shared.GameObjects.EntityUid,System.Nullable{Robust.Shared.GameObjects.EntityUid},Robust.Shared.GameObjects.EyeComponent)">
            <summary>
            Sets the eye component as tracking another entity.
            Will also add the target to view subscribers so they can leave range and still work with PVS.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.GridFixtureChangeEvent">
            <summary>
            Event raised after a grids fixtures have changed, but before <see cref="M:Robust.Shared.Physics.Systems.FixtureSystem.FixtureUpdate(Robust.Shared.GameObjects.EntityUid,System.Boolean,System.Boolean,Robust.Shared.Physics.FixturesComponent,Robust.Shared.Physics.Components.PhysicsComponent)"/> is called.
            Allows content to modify some fixture properties, like density.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.RequestGridNodesMessage">
            <summary>
            Raised by a client who wants to receive gridsplitnode messages.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.SharedGridTraversalSystem">
            <summary>
                Handles moving entities between grids as they move around.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.SharedGridTraversalSystem.Enabled">
            <summary>
            Enables or disables changing grid / map uid upon moving.
            </summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.SharedInputSystem.BindRegistry">
            <summary>
                Holds the keyFunction -> handler bindings for the simulation.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedMapSystem.AlignToGrid(Robust.Shared.Map.EntityCoordinates)">
            <summary>
            If the supplied coordinates intersects a grid will align with the tile center, otherwise returns the coordinates.
            </summary>
            <param name="coordinates"></param>
            <returns></returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedMapSystem.ToCoordinates(Robust.Shared.Map.TileRef,Robust.Shared.Map.Components.MapGridComponent)">
            <summary>
            Converts a tileRef to EntityCoordinates.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedMapSystem.ToCoordinates(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Maths.Vector2i,Robust.Shared.Map.Components.MapGridComponent)">
            <summary>
            Converts a tileRef to EntityCoordinates.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedMapSystem.ToCenterCoordinates(Robust.Shared.Map.TileRef,Robust.Shared.Map.Components.MapGridComponent)">
            <summary>
            Converts a tileRef to EntityCoordinates for the center of the tile.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedMapSystem.ToCenterCoordinates(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Maths.Vector2i,Robust.Shared.Map.Components.MapGridComponent)">
            <summary>
            Converts a tileRef to EntityCoordinates for the center of the tile.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedMapSystem.GetChunkRelative(System.Numerics.Vector2,System.Int32)">
            <summary>
            Returns the tile offset to a chunk origin based on the provided size.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedMapSystem.GetChunkRelative(System.Numerics.Vector2,System.Byte)">
            <summary>
            Returns the tile offset to a chunk origin based on the provided size.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedMapSystem.GetChunkRelative(Robust.Shared.Maths.Vector2i,System.Int32)">
            <summary>
            Returns the tile offset to a chunk origin based on the provided size.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedMapSystem.GetChunkRelative(Robust.Shared.Maths.Vector2i,System.Byte)">
            <summary>
            Returns the tile offset to a chunk origin based on the provided size.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedMapSystem.GetGridPosition(Robust.Shared.GameObjects.Entity{Robust.Shared.Physics.Components.PhysicsComponent},System.Numerics.Vector2,Robust.Shared.Maths.Angle)">
            <summary>
            <see cref="M:Robust.Shared.GameObjects.SharedMapSystem.GetGridPosition(Robust.Shared.GameObjects.Entity{Robust.Shared.Physics.Components.PhysicsComponent},System.Numerics.Vector2,Robust.Shared.Maths.Angle)"/>
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedMapSystem.GetGridPosition(Robust.Shared.GameObjects.Entity{Robust.Shared.Physics.Components.PhysicsComponent,Robust.Shared.GameObjects.TransformComponent})">
            <summary>
            Gets the mapgrid's position considering its local physics center.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedMapSystem.RegenerateCollision(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Map.Components.MapGridComponent,Robust.Shared.Map.MapChunk)">
            <summary>
            Regenerates the chunk local bounds of this chunk.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedMapSystem.RegenerateCollision(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Map.Components.MapGridComponent,System.Collections.Generic.IReadOnlySet{Robust.Shared.Map.MapChunk})">
            <summary>
            Regenerate collision for multiple chunks at once; faster than doing it individually.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedMapSystem.ClearEmptyMapChunks(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Map.Components.MapGridComponent,System.Collections.Generic.IReadOnlySet{Robust.Shared.Map.MapChunk})">
            <summary>
            Variation of <see cref="M:Robust.Shared.GameObjects.SharedMapSystem.RegenerateCollision(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Map.Components.MapGridComponent,Robust.Shared.Map.MapChunk)"/>
            that only simply removes empty chunks. Intended for use with "planet-maps", which have no grid fixtures.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedMapSystem.GetTileRef(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Map.Components.MapGridComponent,Robust.Shared.Map.MapChunk,System.UInt16,System.UInt16)">
            <summary>
                Returns the tile at the given chunk indices.
            </summary>
            <param name="mapChunk"></param>
            <param name="xIndex">The X tile index relative to the chunk origin.</param>
            <param name="yIndex">The Y tile index relative to the chunk origin.</param>
            <returns>A reference to a tile.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedMapSystem.TileToVector(Robust.Shared.GameObjects.Entity{Robust.Shared.Map.Components.MapGridComponent},Robust.Shared.Maths.Vector2i)">
            <summary>
            Turns a gridtile origin into a Vector2, accounting for tile size.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedMapSystem.TileCenterToVector(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Map.Components.MapGridComponent,Robust.Shared.Maths.Vector2i)">
            <summary>
            Turns a gridtile center into a Vector2, accounting for tile size.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedMapSystem.TileCenterToVector(Robust.Shared.GameObjects.Entity{Robust.Shared.Map.Components.MapGridComponent},Robust.Shared.Maths.Vector2i)">
            <summary>
            Turns a gridtile center into a Vector2, accounting for tile size.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedMapSystem.TryGetTileDef(Robust.Shared.Map.Components.MapGridComponent,Robust.Shared.Maths.Vector2i,Robust.Shared.Map.ITileDefinition@)">
            <summary>
            Attempts to get the <see cref="T:Robust.Shared.Map.ITileDefinition"/> for the tile at the given grid indices. This will throw an
            exception if the tile at this location has no registered tile definition.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedMapSystem.CalcWorldAABB(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Map.Components.MapGridComponent,Robust.Shared.Map.MapChunk)">
            <summary>
            Calculate the world space AABB for this chunk.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.SharedMapSystem.TilesEnumerator">
            <summary>
            Iterates the local tiles of the specified data.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedMapSystem.SetChunkTile(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Map.Components.MapGridComponent,Robust.Shared.Map.MapChunk,System.UInt16,System.UInt16,Robust.Shared.Map.Tile)">
            <summary>
                Replaces a single tile inside of the chunk.
            </summary>
            <param name="xIndex">The X tile index relative to the chunk.</param>
            <param name="yIndex">The Y tile index relative to the chunk.</param>
            <param name="tile">The new tile to insert.</param>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedMapSystem.GetMapOrInvalid(System.Nullable{Robust.Shared.Map.MapId})">
            <summary>
            Get the entity UID for a map, or <see cref="F:Robust.Shared.GameObjects.EntityUid.Invalid"/> if the map doesn't exist.
            </summary>
            <param name="mapId">The ID of the map to look up.</param>
            <returns>
            The entity UID of the map entity with the specific map ID,
            or <see cref="F:Robust.Shared.GameObjects.EntityUid.Invalid"/> if the map doesn't exist.
            </returns>
            <seealso cref="M:Robust.Shared.GameObjects.SharedMapSystem.GetMap(Robust.Shared.Map.MapId)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedMapSystem.CreateMap(Robust.Shared.Map.MapId@,System.Boolean)">
            <summary>
                Creates a new map, automatically assigning a map id.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedMapSystem.CreateMap(System.Boolean)">
            <inheritdoc cref="M:Robust.Shared.GameObjects.SharedMapSystem.CreateMap(Robust.Shared.Map.MapId@,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedMapSystem.CreateMap(Robust.Shared.Map.MapId,System.Boolean)">
            <summary>
                Creates a new map with the specified map id.
            </summary>
            <exception cref="T:System.ArgumentException">Throws if an invalid or already existing map id is provided.</exception>
        </member>
        <member name="T:Robust.Shared.GameObjects.MapChangedEvent">
            <summary>
                Arguments for when a map is created or deleted.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.MapChangedEvent.#ctor(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Map.MapId,System.Boolean)">
            <summary>
                Creates a new instance of this class.
            </summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.MapChangedEvent.Map">
            <summary>
                Map that is being modified.
            </summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.MapChangedEvent.Created">
            <summary>
                The map is being created.
            </summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.MapChangedEvent.Destroyed">
            <summary>
                The map is being destroyed (not <see cref="P:Robust.Shared.GameObjects.MapChangedEvent.Created"/>).
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.GridInitializeEvent">
            <summary>
            Raised whenever a grid is being initialized.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.GridAddEvent">
            <summary>
            Raised whenever a grid is Added
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.TileChangedEvent">
            <summary>
                Arguments for when a single tile on a grid is changed locally or remotely.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.TileChangedEvent.#ctor(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Map.TileRef,Robust.Shared.Map.Tile,Robust.Shared.Maths.Vector2i)">
            <summary>
                Creates a new instance of this class.
            </summary>
        </member>
        <member name="P:Robust.Shared.GameObjects.TileChangedEvent.EmptyChanged">
            <summary>
            Was the tile previously empty or is it now empty.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.TileChangedEvent.Entity">
            <summary>
                EntityUid of the grid with the tile-change. TileRef stores the GridId.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.TileChangedEvent.NewTile">
            <summary>
                New tile that replaced the old one.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.TileChangedEvent.OldTile">
            <summary>
                Old tile that was replaced.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.TileChangedEvent.ChunkIndex">
            <summary>
                The index of the grid-chunk that this tile belongs to.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedTransformSystem.ContainsEntity(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.TransformComponent})">
            <summary>
                Checks whether the first entity or one of it's children is the parent of some other entity.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedTransformSystem.IsParentOf(Robust.Shared.GameObjects.TransformComponent,Robust.Shared.GameObjects.EntityUid)">
            <summary>
            Checks whether the given component is the parent of the entity without having to fetch the child's
            transform component.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedTransformSystem.SetGridIdNoRecursive(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.TransformComponent,System.Nullable{Robust.Shared.GameObjects.EntityUid})">
            <summary>
            Sets the <see cref="!:GridId"/> for the transformcomponent without updating its children. Does not Dirty it.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedTransformSystem.SetGridId(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.TransformComponent,System.Nullable{Robust.Shared.GameObjects.EntityUid},System.Nullable{Robust.Shared.GameObjects.EntityQuery{Robust.Shared.GameObjects.TransformComponent}})">
            <summary>
            Sets the <see cref="!:GridId"/> for the transformcomponent. Does not Dirty it.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedTransformSystem.SetCoordinates(Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.TransformComponent,Robust.Shared.GameObjects.MetaDataComponent},Robust.Shared.Map.EntityCoordinates,System.Nullable{Robust.Shared.Maths.Angle},System.Boolean,Robust.Shared.GameObjects.TransformComponent,Robust.Shared.GameObjects.TransformComponent)">
            <summary>
                This sets the local position and parent of an entity.
            </summary>
            <param name="rotation">Final local rotation. If not specified, this will attempt to preserve world
            rotation.</param>
            <param name="unanchor">Whether or not to unanchor the entity before moving. Note that this will still move the
            entity even when false. If you set this to false, you need to manually manage the grid lookup changes and ensure
            the final position is valid</param>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedTransformSystem.ReparentChildren(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.EntityQuery{Robust.Shared.GameObjects.TransformComponent})">
            <summary>
            Re-parents all of the oldUid's children to the new entity.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedTransformSystem.GetRelativePositionRotation(Robust.Shared.GameObjects.TransformComponent,Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.EntityQuery{Robust.Shared.GameObjects.TransformComponent})">
            <summary>
                Returns the position and rotation relative to some entity higher up in the component's transform hierarchy.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedTransformSystem.GetRelativePosition(Robust.Shared.GameObjects.TransformComponent,Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.EntityQuery{Robust.Shared.GameObjects.TransformComponent})">
            <summary>
                Returns the position and rotation relative to some entity higher up in the component's transform hierarchy.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedTransformSystem.SetWorldPosition(Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.TransformComponent},System.Numerics.Vector2)">
            <summary>
            Sets the position of the entity in world-terms to the specified position.
            May also de-parent the entity.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedTransformSystem.SetLocalPositionRotation(Robust.Shared.GameObjects.EntityUid,System.Numerics.Vector2,Robust.Shared.Maths.Angle,Robust.Shared.GameObjects.TransformComponent)">
            <summary>
                Simultaneously set the position and rotation. This is better than setting individually, as it reduces the number of move events and matrix rebuilding operations.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedTransformSystem.AttachToGridOrMap(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.TransformComponent)">
            <summary>
            Attempts to re-parent the given entity to the grid or map that the entity is on.
            If no valid map or grid is found, this will detach the entity to null-space and queue it for deletion.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedTransformSystem.DetachEntity(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.TransformComponent)">
            <inheritdoc cref="M:Robust.Shared.GameObjects.SharedTransformSystem.DetachEntityInternal(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.TransformComponent,Robust.Shared.GameObjects.MetaDataComponent,Robust.Shared.GameObjects.TransformComponent,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedTransformSystem.DetachEntity(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.TransformComponent,Robust.Shared.GameObjects.MetaDataComponent,Robust.Shared.GameObjects.TransformComponent,System.Boolean)">
            <inheritdoc cref="M:Robust.Shared.GameObjects.SharedTransformSystem.DetachEntityInternal(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.TransformComponent,Robust.Shared.GameObjects.MetaDataComponent,Robust.Shared.GameObjects.TransformComponent,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedTransformSystem.DetachEntityInternal(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.TransformComponent,Robust.Shared.GameObjects.MetaDataComponent,Robust.Shared.GameObjects.TransformComponent,System.Boolean)">
            <summary>
            Remove an entity from the transform hierarchy and send it to null space
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedTransformSystem.DropNextTo(Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.TransformComponent},Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.TransformComponent})">
            <summary>
            Attempts to drop an entity onto the map or grid next to another entity. If the target entity is in a container,
            this will attempt to insert that entity into the same container. Otherwise it will attach the entity to the
            grid or map at the same world-position as the target entity.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedTransformSystem.PlaceNextTo(Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.TransformComponent},Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.TransformComponent})">
            <summary>
            Attempts to place one entity next to another entity. If the target entity is in a container, this will attempt
            to insert that entity into the same container. Otherwise it will attach the entity to the same parent.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedTransformSystem.SwapPositions(Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.TransformComponent},Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.TransformComponent})">
            <summary>
            Swaps the position of two entities, placing them inside of containers when applicable.
            </summary>
            <returns>Returns if the entities can have their positions swapped. Fails if the entities are parented to one another</returns>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedTransformSystem.IsValid(Robust.Shared.Map.EntityCoordinates)">
            <summary>
                Verifies that this set of coordinates can be currently resolved to a location.
            </summary>
            <returns><see langword="true" /> if this set of coordinates can be currently resolved to a location, otherwise <see langword="false" />.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedTransformSystem.WithEntityId(Robust.Shared.Map.EntityCoordinates,Robust.Shared.GameObjects.EntityUid)">
            <summary>
                Returns a new set of EntityCoordinates local to a new entity.
            </summary>
            <param name="entity">The entity that the new coordinates will be local to</param>
            <returns>A new set of EntityCoordinates local to a new entity.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedTransformSystem.ToMapCoordinates(Robust.Shared.Map.EntityCoordinates,System.Boolean)">
            <summary>
            Converts entity-local coordinates into map terms.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedTransformSystem.ToMapCoordinates(Robust.Shared.Map.NetCoordinates)">
            <summary>
            Converts entity-local coordinates into map terms.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedTransformSystem.ToCoordinates(Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.TransformComponent},Robust.Shared.Map.MapCoordinates)">
            <summary>
            Creates EntityCoordinates given an entity and some MapCoordinates.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedTransformSystem.ToCoordinates(Robust.Shared.Map.MapCoordinates)">
            <summary>
            Creates map-relative <see cref="T:Robust.Shared.Map.EntityCoordinates"/> given some <see cref="T:Robust.Shared.Map.MapCoordinates"/>.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedTransformSystem.GetGrid(Robust.Shared.Map.EntityCoordinates)">
            <summary>
            Returns the grid that the entity whose position the coordinates are relative to is on.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedTransformSystem.GetMapId(Robust.Shared.Map.EntityCoordinates)">
            <summary>
            Returns the Map Id these coordinates are on.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedTransformSystem.GetMap(Robust.Shared.Map.EntityCoordinates)">
            <summary>
            Returns the Map that these coordinates are on.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedTransformSystem.InRange(Robust.Shared.Map.EntityCoordinates,Robust.Shared.Map.EntityCoordinates,System.Single)">
            <summary>
                Compares two sets of coordinates to see if they are in range of each other.
            </summary>
            <param name="range">maximum distance between the two sets of coordinates.</param>
            <returns>True if the two points are within a given range.</returns>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedTransformSystem.InRange(Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.TransformComponent},Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.TransformComponent},System.Single)">
            <summary>
                Compares the positions of two entities to see if they are within some specified distance of each other.
            </summary>
        </member>
        <member name="E:Robust.Shared.GameObjects.SharedTransformSystem.OnGlobalMoveEvent">
            <summary>
                Invoked as an alternative to broadcasting move events, which can be expensive.
                Systems which want to subscribe broadcast to <see cref="T:Robust.Shared.GameObjects.MoveEvent"/> (which you probably shouldn't)
                should subscribe to this instead
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "E:Robust.Shared.GameObjects.SharedTransformSystem.OnBeforeMoveEvent" -->
        <member name="M:Robust.Shared.GameObjects.SharedTransformSystem.DeparentAllEntsOnTile(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Maths.Vector2i)">
            <summary>
                De-parents and unanchors all entities on a grid-tile.
            </summary>
            <remarks>
                Used when a tile on a grid is removed (becomes space). Only de-parents entities if they are actually
                parented to that grid. No more disemboweling mobs.
            </remarks>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedTransformSystem.GetMoverCoordinates(Robust.Shared.Map.EntityCoordinates)">
            <summary>
                Variant of <see cref="M:Robust.Shared.GameObjects.SharedTransformSystem.GetMoverCoordinates(Robust.Shared.GameObjects.EntityUid)"/> that uses a entity coordinates, rather than an entity's transform.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedTransformSystem.GetMoverCoordinateRotation(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.TransformComponent)">
            <summary>
                Variant of <see cref="!:GetMoverCoordinates()"/> that also returns the entity's world rotation
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedTransformSystem.GetGridOrMapTilePosition(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.TransformComponent)">
            <summary>
                Helper method that returns the grid or map tile an entity is on.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedTransformSystem.GetGridTilePositionOrDefault(Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.TransformComponent},Robust.Shared.Map.Components.MapGridComponent)">
            <summary>
            Helper method that returns the grid tile an entity is on.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedTransformSystem.TryGetGridTilePosition(Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.TransformComponent},Robust.Shared.Maths.Vector2i@,Robust.Shared.Map.Components.MapGridComponent)">
            <summary>
            Helper method that returns the grid tile an entity is on.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.TransformComponentState">
            <summary>
                Serialized state of a TransformComponent.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.TransformComponentState.ParentID">
            <summary>
                Current parent entity of this entity.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.TransformComponentState.LocalPosition">
            <summary>
                Current position offset of the entity.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.TransformComponentState.Rotation">
            <summary>
                Current rotation offset of the entity.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.TransformComponentState.NoLocalRotation">
            <summary>
            Is the transform able to be locally rotated?
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.TransformComponentState.Anchored">
            <summary>
            True if the transform is anchored to a tile.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.TransformComponentState.#ctor(System.Numerics.Vector2,Robust.Shared.Maths.Angle,Robust.Shared.GameObjects.NetEntity,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
                Constructs a new state snapshot of a TransformComponent.
            </summary>
            <param name="localPosition">Current position offset of this entity.</param>
            <param name="rotation">Current direction offset of this entity.</param>
            <param name="parentId">Current parent transform of this entity.</param>
            <param name="noLocalRotation"></param>
        </member>
        <member name="F:Robust.Shared.GameObjects.SharedUserInterfaceSystem._queuedCloses">
            <summary>
            Defer closing BUIs during state handling so client doesn't spam a BUI constantly during prediction.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedUserInterfaceSystem.OnMessageReceived(Robust.Shared.GameObjects.BoundUIWrapMessage,Robust.Shared.GameObjects.EntityUid)">
            <summary>
            Validates the received message, and then pass it onto systems/components
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedUserInterfaceSystem.EnsureClientBui(Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.UserInterfaceComponent},System.Enum,Robust.Shared.GameObjects.InterfaceData,System.Boolean)">
            <summary>
            Opens a client's BUI if not already open and applies the state to it.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedUserInterfaceSystem.GetActorUis(Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.UserInterfaceUserComponent})">
            <summary>
            Yields all the entities + keys currently open by this entity.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedUserInterfaceSystem.GetActors(Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.UserInterfaceComponent},System.Enum)">
            <summary>
            Gets the actors that have the specified key attached to this entity open.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedUserInterfaceSystem.CloseUi(Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.UserInterfaceComponent},System.Enum)">
            <summary>
            Closes the attached UI for all entities.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedUserInterfaceSystem.CloseUi(Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.UserInterfaceComponent},System.Enum,Robust.Shared.Player.ICommonSession,System.Boolean)">
            <summary>
            Closes the attached UI only for the specified actor.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedUserInterfaceSystem.CloseUi(Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.UserInterfaceComponent},System.Enum,System.Nullable{Robust.Shared.GameObjects.EntityUid},System.Boolean)">
            <summary>
            Closes the attached Ui only for the specified actor.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedUserInterfaceSystem.TryOpenUi(Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.UserInterfaceComponent},System.Enum,Robust.Shared.GameObjects.EntityUid,System.Boolean)">
            <summary>
            Tries to call OpenUi and return false if it isn't open.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedUserInterfaceSystem.SetUiState(Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.UserInterfaceComponent},System.Enum,Robust.Shared.GameObjects.BoundUserInterfaceState)">
            <summary>
            Sets a BUI state and networks it to all clients.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedUserInterfaceSystem.HasUi(Robust.Shared.GameObjects.EntityUid,System.Enum,Robust.Shared.GameObjects.UserInterfaceComponent)">
            <summary>
            Returns true if this entity has the specified Ui key available, even if not currently open.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedUserInterfaceSystem.IsUiOpen(Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.UserInterfaceComponent},System.Enum)">
            <summary>
            Returns true if the specified UI key is open for this entity by anyone.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedUserInterfaceSystem.RaiseUiMessage(Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.UserInterfaceComponent},System.Enum,Robust.Shared.GameObjects.BoundUserInterfaceMessage)">
            <summary>
            Raises a BUI message locally (on client or server) without networking it.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedUserInterfaceSystem.ServerSendUiMessage(Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.UserInterfaceComponent},System.Enum,Robust.Shared.GameObjects.BoundUserInterfaceMessage)">
            <summary>
            Sends a BUI message to any actors who have the specified Ui key open.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedUserInterfaceSystem.ServerSendUiMessage(Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.UserInterfaceComponent},System.Enum,Robust.Shared.GameObjects.BoundUserInterfaceMessage,Robust.Shared.GameObjects.EntityUid)">
            <summary>
            Sends a Bui message to the specified actor only.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedUserInterfaceSystem.ServerSendUiMessage(Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.UserInterfaceComponent},System.Enum,Robust.Shared.GameObjects.BoundUserInterfaceMessage,Robust.Shared.Player.ICommonSession)">
            <summary>
            Sends a Bui message to the specified actor only.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedUserInterfaceSystem.ClientSendUiMessage(Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.UserInterfaceComponent},System.Enum,Robust.Shared.GameObjects.BoundUserInterfaceMessage)">
            <summary>
            Raises a BUI message from the client to the server.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedUserInterfaceSystem.CloseUserUis(Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.UserInterfaceUserComponent})">
            <summary>
            Closes all Uis for the actor.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedUserInterfaceSystem.CloseUis(Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.UserInterfaceComponent})">
            <summary>
            Closes all Uis for the entity.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedUserInterfaceSystem.CloseUis(Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.UserInterfaceComponent},Robust.Shared.GameObjects.EntityUid)">
            <summary>
            Closes all Uis for the entity that the specified actor has open.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedUserInterfaceSystem.CloseUis(Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.UserInterfaceComponent},Robust.Shared.Player.ICommonSession)">
            <summary>
            Closes all Uis for the entity that the specified actor has open.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedUserInterfaceSystem.TryGetOpenUi(Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.UserInterfaceComponent},System.Enum,Robust.Shared.GameObjects.BoundUserInterface@)">
            <summary>
            Tries to get the BUI if it is currently open.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedUserInterfaceSystem.TryGetOpenUi``1(Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.UserInterfaceComponent},System.Enum,``0@)">
            <summary>
            Tries to get the BUI if it is currently open.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedUserInterfaceSystem.TryToggleUi(Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.UserInterfaceComponent},System.Enum,Robust.Shared.GameObjects.EntityUid)">
            <summary>
            Switches between closed and open for a specific client.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedUserInterfaceSystem.SendPredictedUiMessage(Robust.Shared.GameObjects.BoundUserInterface,Robust.Shared.GameObjects.BoundUserInterfaceMessage)">
            <summary>
            Raised by client-side UIs to send predicted messages to server.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedUserInterfaceSystem.Update(System.Single)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedUserInterfaceSystem.SetUi(Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.UserInterfaceComponent},System.Enum,Robust.Shared.GameObjects.InterfaceData)">
            <summary>
            Set a UI after an entity has been created.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedUserInterfaceSystem.CheckRange(Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.TransformComponent},System.Enum,Robust.Shared.GameObjects.InterfaceData,Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.TransformComponent})">
            <summary>
                Verify that the subscribed clients are still in range of the interface.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.SharedUserInterfaceSystem.ActorRangeCheckJob">
            <summary>
            Used for running UI raycast checks in parallel.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedUserInterfaceSystem.ActorRangeCheckJob.#ctor">
            <summary>
            Used for running UI raycast checks in parallel.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.BoundUserInterfaceCheckRangeEvent">
            <summary>
            Raised by <see cref="!:UserInterfaceSystem"/> to check whether an interface is still accessible by its user.
            The event is raised directed at the entity that owns the interface.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.BoundUserInterfaceCheckRangeEvent.#ctor(Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.TransformComponent},System.Enum,Robust.Shared.GameObjects.InterfaceData,Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.TransformComponent})">
            <summary>
            Raised by <see cref="!:UserInterfaceSystem"/> to check whether an interface is still accessible by its user.
            The event is raised directed at the entity that owns the interface.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.BoundUserInterfaceCheckRangeEvent.Target">
            <summary>
            The entity owning the UI being checked for.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.BoundUserInterfaceCheckRangeEvent.UiKey">
            <summary>
            The UI itself.
            </summary>
            <returns></returns>
        </member>
        <member name="F:Robust.Shared.GameObjects.BoundUserInterfaceCheckRangeEvent.Actor">
            <summary>
            The player for which the UI is being checked.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.BoundUserInterfaceCheckRangeEvent.Result">
            <summary>
            The result of the range check.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameObjects.BoundUserInterfaceRangeResult">
            <summary>
            Possible results for a <see cref="T:Robust.Shared.GameObjects.BoundUserInterfaceCheckRangeEvent"/>.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.BoundUserInterfaceRangeResult.Default">
            <summary>
            Run built-in range check.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.BoundUserInterfaceRangeResult.Pass">
            <summary>
            Range check passed, UI is accessible.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameObjects.BoundUserInterfaceRangeResult.Fail">
            <summary>
            Range check failed, UI is inaccessible.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedViewSubscriberSystem.AddViewSubscriber(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Player.ICommonSession)">
            <summary>
                Subscribes the session to get PVS updates from the point of view of the specified entity.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameObjects.SharedViewSubscriberSystem.RemoveViewSubscriber(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Player.ICommonSession)">
            <summary>
                Unsubscribes the session from getting PVS updates from the point of view of the specified entity.
            </summary>
        </member>
        <member name="T:Robust.Shared.GameStates.ComponentGetState">
            <summary>
                Component event for getting the component state for a specific player.
            </summary>
        </member>
        <member name="P:Robust.Shared.GameStates.ComponentGetState.State">
            <summary>
                Output parameter. Set this to the component's state for the player.
            </summary>
        </member>
        <member name="P:Robust.Shared.GameStates.ComponentGetState.ReplayState">
            <summary>
                If true, this state is intended for replays or some other server spectator entity, not for specific
                clients.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameStates.ComponentGetState.Player">
            <summary>
                The player the state is being sent to. Null implies the state is for a replay or some spectator entity.
            </summary>
        </member>
        <member name="F:Robust.Shared.GameStates.ComponentGetStateAttemptEvent.Player">
            <summary>
                Input parameter. The player the state is being sent to. This may be null if the state is for replay recordings.
            </summary>
        </member>
        <member name="P:Robust.Shared.GameStates.GameState.PayloadSize">
            <summary>
                The serialized size in bytes of this game state.
            </summary>
        </member>
        <member name="M:Robust.Shared.GameStates.GameState.#ctor(Robust.Shared.Timing.GameTick,Robust.Shared.Timing.GameTick,System.UInt32,NetSerializer.NetListAsArray{Robust.Shared.GameObjects.EntityState},NetSerializer.NetListAsArray{Robust.Shared.GameStates.SessionState},NetSerializer.NetListAsArray{Robust.Shared.GameObjects.NetEntity})">
            <summary>
            Constructor!
            </summary>
        </member>
        <member name="M:Robust.Shared.GameStates.GameState.Clone">
            <summary>
            Clone the game state's collections. Required for integration tests, to avoid the server/client referencing
            the same objects
            </summary>
        </member>
        <member name="T:Robust.Shared.GameStates.NetworkedComponentAttribute">
            <summary>
            This attribute marks a component as networked, so that it is replicated to clients.
            </summary>
        </member>
        <member name="T:Robust.Shared.Graphics.Eye">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Graphics.Eye.DrawFov">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Graphics.Eye.DrawLight">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Graphics.Eye.Position">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Graphics.Eye.Offset">
            <summary>
            Eye offset, relative to the map, and not affected by <see cref="P:Robust.Shared.Graphics.Eye.Rotation"/>
            </summary>
        </member>
        <member name="P:Robust.Shared.Graphics.Eye.Rotation">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Graphics.Eye.Zoom">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Graphics.Eye.Scale">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Graphics.Eye.GetViewMatrix(System.Numerics.Matrix3x2@,System.Numerics.Vector2)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Graphics.Eye.GetViewMatrixInv(System.Numerics.Matrix3x2@,System.Numerics.Vector2)">
            <inheritdoc />
        </member>
        <member name="T:Robust.Shared.Graphics.IEye">
            <summary>
            An Eye is a point through which the player can view the world.
            It's a 2D camera in other game dev lingo basically.
            </summary>
        </member>
        <member name="P:Robust.Shared.Graphics.IEye.DrawFov">
            <summary>
            Should the black FoV effect be drawn for this eye?
            </summary>
        </member>
        <member name="P:Robust.Shared.Graphics.IEye.DrawLight">
            <summary>
            Whether to draw lights for this eye.
            </summary>
        </member>
        <member name="P:Robust.Shared.Graphics.IEye.Position">
            <summary>
            Current position of the center of the eye in the game world.
            </summary>
        </member>
        <member name="P:Robust.Shared.Graphics.IEye.Offset">
            <summary>
            Translation offset from <see cref="P:Robust.Shared.Graphics.IEye.Position"/>. Does not influence the center of FOV.
            </summary>
        </member>
        <member name="P:Robust.Shared.Graphics.IEye.Rotation">
            <summary>
            Rotation of the camera around the Z axis.
            </summary>
        </member>
        <member name="P:Robust.Shared.Graphics.IEye.Zoom">
            <summary>
            Current zoom level of this eye. Zoom is the inverse of Scale (Zoom = 1 / Scale).
            </summary>
        </member>
        <member name="P:Robust.Shared.Graphics.IEye.Scale">
            <summary>
            Current view scale of this eye. Scale is the inverse of Zoom (Scale = 1 / Zoom).
            </summary>
        </member>
        <member name="M:Robust.Shared.Graphics.IEye.GetViewMatrix(System.Numerics.Matrix3x2@,System.Numerics.Vector2)">
            <summary>
            Returns the view matrix for this eye, used to convert a point from
            world space to camera space.
            </summary>
            <param name="viewMatrix">View matrix for this camera.</param>
            <param name="renderScale"></param>
        </member>
        <member name="M:Robust.Shared.Graphics.IEye.GetViewMatrixInv(System.Numerics.Matrix3x2@,System.Numerics.Vector2)">
            <summary>
            Returns the inverted view matrix for this eye, used to convert a point from
            camera space to world space.
            </summary>
            <param name="viewMatrixInv">Inverted view matrix for this camera.</param>
            <param name="renderScale"></param>
        </member>
        <member name="T:Robust.Shared.Graphics.RSI.RsiDirection">
            <summary>
                Specifies a direction in an RSI state.
            </summary>
            <remarks>
                Value of the enum here matches the index used to store it in the icons array. If this ever changes, then
                <see cref="!:Robust.Client.GameObjects.SpriteComponent.Layer._rsiDirectionMatrices"/> also needs to be updated.
            </remarks>
        </member>
        <member name="T:Robust.Shared.Graphics.RSI.RsiDirectionType">
            <summary>
                Specifies which types of directions an RSI state has.
            </summary>
        </member>
        <member name="F:Robust.Shared.Graphics.RSI.RsiDirectionType.Dir1">
            <summary>
                A single direction, namely South.
            </summary>
        </member>
        <member name="F:Robust.Shared.Graphics.RSI.RsiDirectionType.Dir4">
            <summary>
                4 cardinal directions.
            </summary>
        </member>
        <member name="F:Robust.Shared.Graphics.RSI.RsiDirectionType.Dir8">
            <summary>
                4 cardinal + 4 diagonal directions.
            </summary>
        </member>
        <member name="T:Robust.Shared.Graphics.TextureLoadParameters">
            <summary>
                Flags for loading of textures.
            </summary>
        </member>
        <member name="P:Robust.Shared.Graphics.TextureLoadParameters.SampleParameters">
            <summary>
                The default sampling parameters for the texture.
            </summary>
        </member>
        <member name="P:Robust.Shared.Graphics.TextureLoadParameters.Srgb">
            <summary>
                If true, the image data will be treated as sRGB.
            </summary>
        </member>
        <member name="T:Robust.Shared.Graphics.TextureSampleParameters">
            <summary>
                Sample flags for textures.
                These are separate from <see cref="T:Robust.Shared.Graphics.TextureLoadParameters"/>,
                because it is possible to create "proxies" to existing textures
                with different sampling parameters than the base texture.
            </summary>
        </member>
        <member name="P:Robust.Shared.Graphics.TextureSampleParameters.Filter">
            <summary>
                If true, use bi-linear texture filtering if the texture cannot be rendered 1:1
            </summary>
        </member>
        <member name="P:Robust.Shared.Graphics.TextureSampleParameters.WrapMode">
            <summary>
                Controls how to wrap the texture if texture coordinates outside 0-1 are accessed.
            </summary>
        </member>
        <member name="T:Robust.Shared.Graphics.TextureWrapMode">
            <summary>
                Controls behavior when reading texture coordinates outside 0-1, which usually wraps the texture somehow.
            </summary>
        </member>
        <member name="F:Robust.Shared.Graphics.TextureWrapMode.None">
            <summary>
                Do not wrap, instead clamp to edge.
            </summary>
        </member>
        <member name="F:Robust.Shared.Graphics.TextureWrapMode.Repeat">
            <summary>
                Repeat the texture.
            </summary>
        </member>
        <member name="F:Robust.Shared.Graphics.TextureWrapMode.MirroredRepeat">
            <summary>
                Repeat the texture mirrored.
            </summary>
        </member>
        <member name="T:Robust.Shared.Input.Binding.CommandBind">
            <summary>
            An individual binding of a given handler to a given key function, with associated
            dependency information to resolve handlers bound to the same key function from different types.
            </summary>
        </member>
        <member name="P:Robust.Shared.Input.Binding.CommandBind.BoundKeyFunction">
            <summary>
            Key function the handler should be triggered on
            </summary>
        </member>
        <member name="P:Robust.Shared.Input.Binding.CommandBind.After">
            <summary>
            If other types register bindings for this key function, this handler will always fire
            after them if they appear in this list.
            </summary>
        </member>
        <member name="P:Robust.Shared.Input.Binding.CommandBind.Before">
            <summary>
            If other types register bindings for this key function, this handler will always fire
            before them if they appear in this list.
            </summary>
        </member>
        <member name="P:Robust.Shared.Input.Binding.CommandBind.Handler">
            <summary>
            Handler which should handle inputs for the key function
            </summary>
        </member>
        <member name="M:Robust.Shared.Input.Binding.CommandBind.#ctor(Robust.Shared.Input.BoundKeyFunction,Robust.Shared.Input.Binding.InputCmdHandler,System.Collections.Generic.IEnumerable{System.Type},System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            A binding of a handler to the indicated key function, with the indicated dependencies.
            </summary>
            <param name="boundKeyFunction">key function this handler should handle</param>
            <param name="handler">handler to handle the input</param>
            <param name="before">If other types register bindings for this key function, this handler will always fire
            before them if they appear in this list.</param>
            <param name="after">If other types register bindings for this key function, this handler will always fire
            after them if they appear in this list.</param>
        </member>
        <member name="T:Robust.Shared.Input.Binding.CommandBindRegistry">
            <inheritdoc cref="T:Robust.Shared.Input.Binding.ICommandBindRegistry"/>
        </member>
        <member name="M:Robust.Shared.Input.Binding.CommandBindRegistry.Register``1(Robust.Shared.Input.Binding.CommandBinds)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Input.Binding.CommandBindRegistry.Register(Robust.Shared.Input.Binding.CommandBinds,System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Input.Binding.CommandBindRegistry.GetHandlers(Robust.Shared.Input.BoundKeyFunction)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Input.Binding.CommandBindRegistry.Unregister(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Input.Binding.CommandBindRegistry.Unregister``1">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Input.Binding.CommandBindRegistry.ResolveDependencies(Robust.Shared.Input.BoundKeyFunction,System.Collections.Generic.List{Robust.Shared.Input.Binding.CommandBindRegistry.TypedCommandBind})">
            <summary>
            Determines the order in which the indicated bindings handlers should be resolved for a
            particular bound key function
            </summary>
        </member>
        <member name="T:Robust.Shared.Input.Binding.CommandBindRegistry.TypedCommandBind">
            <summary>
            Command bind which has an associated type.
            The only time a client should need to think about the type for a binding is when they are
            registering a set of bindings, so we don't include this information in CommandBind
            </summary>
        </member>
        <member name="T:Robust.Shared.Input.Binding.CommandBinds">
             <summary>
             Represents a set of bindings from BoundKeyFunctions to InputCmdHandlers
            
             Immutable. Use Bindings.Builder() to create.
             </summary>
        </member>
        <member name="P:Robust.Shared.Input.Binding.CommandBinds.Builder">
            <summary>
            Builder to build a new set of Bindings
            </summary>
            <returns></returns>
        </member>
        <member name="M:Robust.Shared.Input.Binding.CommandBinds.Unregister``1">
            <summary>
            Unregisters from the current InputSystem's BindRegistry all bindings currently registered under
            indicated owner type so they will no longer receive / handle inputs. No effect if input system
            no longer exists.
            </summary>
            <typeparam name="TOwner">owner type whose bindings should be unregistered, typically a system / manager,
            should usually be typeof(this) - same type as the calling class.</typeparam>
        </member>
        <member name="M:Robust.Shared.Input.Binding.CommandBinds.Unregister``1(Robust.Shared.Input.Binding.ICommandBindRegistry)">
            <summary>
            Unregisters from the given BindRegistry all bindings currently registered under
            indicated owner type so they will no longer receive / handle inputs. No effect if input system
            no longer exists.
            </summary>
            <typeparam name="TOwner">owner type whose bindings should be unregistered, typically a system / manager,
            should usually be typeof(this) - same type as the calling class.</typeparam>
        </member>
        <member name="T:Robust.Shared.Input.Binding.CommandBinds.BindingsBuilder">
            <summary>
            For creating Bindings.
            </summary>
        </member>
        <member name="M:Robust.Shared.Input.Binding.CommandBinds.BindingsBuilder.Bind(Robust.Shared.Input.BoundKeyFunction,Robust.Shared.Input.Binding.InputCmdHandler)">
            <summary>
            Bind the indicated handler to the indicated function, with no
            particular dependency on bindings from other owner types. If multiple
            handlers in this builder are registered to the same key function,
            the handlers will fire in the order in which they were added to this builder.
            </summary>
        </member>
        <member name="M:Robust.Shared.Input.Binding.CommandBinds.BindingsBuilder.Bind(Robust.Shared.Input.BoundKeyFunction,System.Collections.Generic.IEnumerable{Robust.Shared.Input.Binding.InputCmdHandler})">
             <summary>
             Bind the indicated handlers to the indicated function, with no
             particular dependency on bindings from other owner types.
            
             If multiple
             handlers in this builder are registered to the same key function,
             the handlers will fire in the order in which they were added to this builder.
             </summary>
        </member>
        <member name="M:Robust.Shared.Input.Binding.CommandBinds.BindingsBuilder.BindAfter(Robust.Shared.Input.BoundKeyFunction,Robust.Shared.Input.Binding.InputCmdHandler,System.Type[])">
             <summary>
             Bind the indicated handler to the indicated function. If other owner types register bindings for this key
             function, this handler will always fire after them if they appear in the "after" list.
            
             If multiple handlers in this builder are registered to the same key function,
             the handlers will fire in the order in which they were added to this builder.
             </summary>
             <param name="after">If other owner types register bindings for this key
             function, this handler will always fire after them if they appear in this list</param>
        </member>
        <member name="M:Robust.Shared.Input.Binding.CommandBinds.BindingsBuilder.BindBefore(Robust.Shared.Input.BoundKeyFunction,Robust.Shared.Input.Binding.InputCmdHandler,System.Type[])">
             <summary>
             Bind the indicated handler to the indicated function. If other owner types register bindings for this key
             function, this handler will always fire before them if they appear in the "before" list.
            
             If multiple handlers in this builder are registered to the same key function,
             the handlers will fire in the order in which they were added to this builder.
             </summary>
             <param name="before">If other owner types register bindings for this key
             function, this handler will always fire before them if they appear in this list</param>
        </member>
        <member name="M:Robust.Shared.Input.Binding.CommandBinds.BindingsBuilder.Bind(Robust.Shared.Input.Binding.CommandBind)">
            <summary>
            Add the binding to this set of bindings. If other bindings in this set
            are bound to the same key function, they will be resolved in the order they were added
            to this builder.
            </summary>
        </member>
        <member name="M:Robust.Shared.Input.Binding.CommandBinds.BindingsBuilder.Build">
            <summary>
            Create the Bindings based on the current configuration.
            </summary>
        </member>
        <member name="M:Robust.Shared.Input.Binding.CommandBinds.BindingsBuilder.Register``1(Robust.Shared.Input.Binding.ICommandBindRegistry)">
            <summary>
            Create the Bindings based on the current configuration and register
            with the indicated mappings so they will be allowed to handle inputs.
            </summary>
            <typeparam name="TOwner">type that owns these bindings, typically a system / manager,
            should usually be typeof(this) - same type as the calling class.</typeparam>
            <param name="registry">mappings to register these bindings with</param>
        </member>
        <member name="M:Robust.Shared.Input.Binding.CommandBinds.BindingsBuilder.Register``1">
            <summary>
            Create the Bindings based on the current configuration and register
            with the indicated mappings to the active InputSystem's BindRegistry
            so they will be allowed to handle inputs.
            </summary>
            <typeparam name="TOwner">type that owns these bindings, typically a system / manager,
            should usually be typeof(this) - same type as the calling class.</typeparam>
        </member>
        <member name="T:Robust.Shared.Input.Binding.ICommandBindRegistry">
             <summary>
             Allows registering bindings so that they will receive and handle inputs. Each set of bindings
             is registered to a particular owner Type, which is typically a system or a manager.
            
             This association of bindings with owner types allows allows the bindings to declare
             dependencies on each other - for example to ensure that one system's handlers will always
             fire after another system's handlers. This also allows easy unregistering of all bindings
             for a given system / manager.
             </summary>
        </member>
        <member name="M:Robust.Shared.Input.Binding.ICommandBindRegistry.Register``1(Robust.Shared.Input.Binding.CommandBinds)">
            <summary>CO
            Registers the indicated bindings, under the given owner type.
            The handlers in the bindings will receive input events.
            </summary>
            <param name="commandBinds">Bindings to register.</param>
            <typeparam name="TOwner">type that owns these bindings, typically a system / manager,
            should usually be typeof(this) - same type as the calling class.</typeparam>
        </member>
        <member name="M:Robust.Shared.Input.Binding.ICommandBindRegistry.Register(Robust.Shared.Input.Binding.CommandBinds,System.Type)">
            <summary>
            Registers the indicated bindings, under the given type.
            The handlers in the bindings will receive input events.
            </summary>
            <param name="commandBinds">Bindings to register.</param>
            <param name="owner">type that owns these bindings, typically a system / manager,
            should usually be typeof(this) - same type as the calling class.</param>
        </member>
        <member name="M:Robust.Shared.Input.Binding.ICommandBindRegistry.GetHandlers(Robust.Shared.Input.BoundKeyFunction)">
            <summary>
            Gets the command handlers bound to the indicated function, in the order
            in which they should be fired based on the dependency graph. Empty enumerable
            if no handlers are bound.
            </summary>
            <param name="function">Key function to get the input handlers of.</param>
        </member>
        <member name="M:Robust.Shared.Input.Binding.ICommandBindRegistry.Unregister(System.Type)">
            <summary>
            Unregisters all bindings currently registered under indicated type so they will
            no longer receive / handle inputs.
            </summary>
            <param name="owner">owner type whose bindings should be unregistered, typically a system / manager,
            should usually be typeof(this) - same type as the calling class.</param>
        </member>
        <member name="M:Robust.Shared.Input.Binding.ICommandBindRegistry.Unregister``1">
            <summary>
            Unregisters all bindings currently registered under indicated type so they will
            no longer receive / handle inputs.
            </summary>
            <typeparam name="TOwner">owner type whose bindings should be unregistered, typically a system / manager,
            should usually be typeof(this) - same type as the calling class.</typeparam>
        </member>
        <member name="M:Robust.Shared.Input.Binding.InputCmdHandler.FromDelegate(Robust.Shared.Input.Binding.StateInputCmdDelegate,Robust.Shared.Input.Binding.StateInputCmdDelegate,System.Boolean,System.Boolean)">
            <summary>
                Makes a quick input command from enabled and disabled delegates.
            </summary>
            <param name="enabled">The delegate to be ran when this command is enabled.</param>
            <param name="disabled">The delegate to be ran when this command is disabled.</param>
            <returns>The new input command.</returns>
        </member>
        <member name="M:Robust.Shared.Input.Binding.PointerInputCmdHandler.#ctor(Robust.Shared.Input.Binding.PointerInputCmdDelegate,System.Boolean,System.Boolean)">
            <summary>
            Handler which will handle the command using the indicated callback
            </summary>
            <param name="callback">callback to handle the command</param>
            <param name="ignoreUp">whether keyup actions will be ignored by this handler (like lifting a key or releasing
            mouse button)</param>
        </member>
        <member name="M:Robust.Shared.Input.Binding.PointerInputCmdHandler.#ctor(Robust.Shared.Input.Binding.PointerInputCmdDelegate2,System.Boolean,System.Boolean)">
            <summary>
            Handler which will handle the command using the indicated callback
            </summary>
            <param name="callback">callback to handle the command</param>
            <param name="ignoreUp">whether keyup actions will be ignored by this handler (like lifting a key or releasing
            mouse button)</param>
        </member>
        <member name="M:Robust.Shared.Input.Binding.PointerStateInputCmdHandler.HandleCmdMessage(Robust.Shared.GameObjects.IEntityManager,Robust.Shared.Player.ICommonSession,Robust.Shared.Input.IFullInputCmdMessage)">
            <inheritdoc />
        </member>
        <member name="T:Robust.Shared.Input.Binding.NullInputCmdHandler">
            <summary>
            Consumes both up and down states without calling any handler delegates. Primarily used on the client to
            prevent an input message from being sent to the server.
            </summary>
        </member>
        <member name="M:Robust.Shared.Input.Binding.NullInputCmdHandler.HandleCmdMessage(Robust.Shared.GameObjects.IEntityManager,Robust.Shared.Player.ICommonSession,Robust.Shared.Input.IFullInputCmdMessage)">
            <inheritdoc />
        </member>
        <member name="T:Robust.Shared.Input.BoundKeyEventArgs">
            <summary>
                Event data values for a bound key state change.
            </summary>
        </member>
        <member name="P:Robust.Shared.Input.BoundKeyEventArgs.Function">
            <summary>
                Bound key that that is changing.
            </summary>
        </member>
        <member name="P:Robust.Shared.Input.BoundKeyEventArgs.State">
            <summary>
                New state of the <see cref="T:Robust.Shared.Input.BoundKeyFunction"/>.
            </summary>
        </member>
        <member name="P:Robust.Shared.Input.BoundKeyEventArgs.PointerLocation">
            <summary>
                Current Pointer location in screen coordinates.
            </summary>
        </member>
        <member name="P:Robust.Shared.Input.BoundKeyEventArgs.CanFocus">
            <summary>
                Whether the Bound key can change the focused control.
            </summary>
        </member>
        <member name="F:Robust.Shared.Input.BoundKeyEventArgs.IsRepeat">
            <summary>
            Is this a repeated keypress (i.e., are they holding down the key)?
            </summary>
        </member>
        <member name="M:Robust.Shared.Input.BoundKeyEventArgs.#ctor(Robust.Shared.Input.BoundKeyFunction,Robust.Shared.Input.BoundKeyState,Robust.Shared.Map.ScreenCoordinates,System.Boolean)">
            <summary>
                Constructs a new instance of <see cref="T:Robust.Shared.Input.BoundKeyEventArgs"/>.
            </summary>
            <param name="function">Bound key that that is changing.</param>
            <param name="state">New state of the function.</param>
            <param name="pointerLocation">Current Pointer location in screen coordinates.</param>
        </member>
        <member name="M:Robust.Shared.Input.BoundKeyEventArgs.#ctor(Robust.Shared.Input.BoundKeyFunction,Robust.Shared.Input.BoundKeyState,Robust.Shared.Map.ScreenCoordinates,System.Boolean,System.Boolean)">
            <summary>
                Constructs a new instance of <see cref="T:Robust.Shared.Input.BoundKeyEventArgs"/>.
            </summary>
            <param name="function">Bound key that that is changing.</param>
            <param name="state">New state of the function.</param>
            <param name="pointerLocation">Current Pointer location in screen coordinates.</param>
            <param name="isRepeat"></param>
        </member>
        <member name="M:Robust.Shared.Input.BoundKeyEventArgs.Handle">
            <summary>
                Mark this event as handled.
            </summary>
        </member>
        <member name="T:Robust.Shared.Input.KeyFunctionId">
            <summary>
                A networked identifier for a <see cref="T:Robust.Shared.Input.BoundKeyFunction"/>.
            </summary>
        </member>
        <member name="T:Robust.Shared.Input.BoundKeyMap">
            <summary>
                Sets up a mapping of <see cref="T:Robust.Shared.Input.BoundKeyFunction"/> to <see cref="T:Robust.Shared.Input.KeyFunctionId"/> for network messages.
            </summary>
        </member>
        <member name="T:Robust.Shared.Input.IInputCmdContext">
            <summary>
                An Input Context to determine which key binds are currently available to the player.
            </summary>
        </member>
        <member name="M:Robust.Shared.Input.IInputCmdContext.AddFunction(Robust.Shared.Input.BoundKeyFunction)">
            <summary>
                Adds a key function to the set of available functions.
            </summary>
            <param name="function"></param>
        </member>
        <member name="M:Robust.Shared.Input.IInputCmdContext.FunctionExists(Robust.Shared.Input.BoundKeyFunction)">
            <summary>
                Checks if a key function is available in THIS context (DOES NOT CHECK PARENTS).
            </summary>
            <param name="function">Function to look for.</param>
            <returns>If the function is available.</returns>
        </member>
        <member name="M:Robust.Shared.Input.IInputCmdContext.FunctionExistsHierarchy(Robust.Shared.Input.BoundKeyFunction)">
            <summary>
                Checks if a key function is available in this and ALL parent contexts.
            </summary>
            <param name="function">Function to look for.</param>
            <returns>If the function is available.</returns>
        </member>
        <member name="M:Robust.Shared.Input.IInputCmdContext.RemoveFunction(Robust.Shared.Input.BoundKeyFunction)">
            <summary>
                Removes a function from THIS context.
            </summary>
            <param name="function">Function to remove.</param>
        </member>
        <member name="T:Robust.Shared.Input.InputCmdContext">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Input.InputCmdContext.#ctor(Robust.Shared.Input.IInputCmdContext,System.String)">
            <summary>
                Creates a new instance of <see cref="T:Robust.Shared.Input.InputCmdContext"/>.
            </summary>
            <param name="parent">Parent context.</param>
        </member>
        <member name="M:Robust.Shared.Input.InputCmdContext.#ctor(System.String)">
            <summary>
                Creates a instance of <see cref="T:Robust.Shared.Input.InputCmdContext"/> with no parent.
            </summary>
        </member>
        <member name="M:Robust.Shared.Input.InputCmdContext.AddFunction(Robust.Shared.Input.BoundKeyFunction)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Input.InputCmdContext.FunctionExists(Robust.Shared.Input.BoundKeyFunction)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Input.InputCmdContext.FunctionExistsHierarchy(Robust.Shared.Input.BoundKeyFunction)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Input.InputCmdContext.RemoveFunction(Robust.Shared.Input.BoundKeyFunction)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Input.InputCmdContext.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:Robust.Shared.Input.InputCmdMessage">
            <summary>
                Abstract class that all Input Commands derive from.
            </summary>
        </member>
        <member name="P:Robust.Shared.Input.InputCmdMessage.Tick">
            <summary>
                Client tick this was created.
            </summary>
        </member>
        <member name="P:Robust.Shared.Input.InputCmdMessage.SubTick">
            <summary>
                How far into the tick this event was fired.
            </summary>
            <seealso cref="P:Robust.Shared.Timing.IGameTiming.TickFraction"/>
        </member>
        <member name="P:Robust.Shared.Input.InputCmdMessage.InputFunctionId">
            <summary>
                The function this command is changing.
            </summary>
        </member>
        <member name="P:Robust.Shared.Input.InputCmdMessage.InputSequence">
            <summary>
            Sequence number of this input command.
            </summary>
        </member>
        <member name="M:Robust.Shared.Input.InputCmdMessage.#ctor(Robust.Shared.Timing.GameTick,System.UInt16,Robust.Shared.Input.KeyFunctionId)">
            <summary>
                Creates an instance of <see cref="T:Robust.Shared.Input.InputCmdMessage"/>.
            </summary>
            <param name="tick">Client tick this was created.</param>
            <param name="inputFunctionId">Function this command is changing.</param>
        </member>
        <member name="M:Robust.Shared.Input.InputCmdMessage.ToString">
            <inheritdoc />
        </member>
        <member name="T:Robust.Shared.Input.StateInputCmdMessage">
            <summary>
                An Input Command for a function that has a state.
            </summary>
        </member>
        <member name="P:Robust.Shared.Input.StateInputCmdMessage.State">
            <summary>
                New state of the Input Function.
            </summary>
        </member>
        <member name="M:Robust.Shared.Input.StateInputCmdMessage.#ctor(Robust.Shared.Timing.GameTick,System.UInt16,Robust.Shared.Input.KeyFunctionId,Robust.Shared.Input.BoundKeyState)">
            <summary>
                Creates an instance of <see cref="T:Robust.Shared.Input.StateInputCmdMessage"/>.
            </summary>
            <param name="tick">Client tick this was created.</param>
            <param name="inputFunctionId">Function this command is changing.</param>
            <param name="state">New state of the Input Function.</param>
        </member>
        <member name="T:Robust.Shared.Input.EventInputCmdMessage">
            <summary>
                A OneShot Input Command that does not have a state.
            </summary>
        </member>
        <member name="M:Robust.Shared.Input.EventInputCmdMessage.#ctor(Robust.Shared.Timing.GameTick,System.UInt16,Robust.Shared.Input.KeyFunctionId)">
            <summary>
                Creates an instance of <see cref="T:Robust.Shared.Input.EventInputCmdMessage"/>.
            </summary>
            <param name="tick">Client tick this was created.</param>
            <param name="inputFunctionId">Function this command is changing.</param>
        </member>
        <member name="T:Robust.Shared.Input.PointerInputCmdMessage">
            <summary>
                A OneShot Input Command that also contains pointer info.
            </summary>
        </member>
        <member name="P:Robust.Shared.Input.PointerInputCmdMessage.Coordinates">
            <summary>
                Local Coordinates of the pointer when the command was created.
            </summary>
        </member>
        <member name="P:Robust.Shared.Input.PointerInputCmdMessage.Uid">
            <summary>
                Entity that was under the pointer when the command was created (if any).
            </summary>
        </member>
        <member name="M:Robust.Shared.Input.PointerInputCmdMessage.#ctor(Robust.Shared.Timing.GameTick,System.UInt16,Robust.Shared.Input.KeyFunctionId,Robust.Shared.Map.NetCoordinates)">
            <summary>
                Creates an instance of <see cref="T:Robust.Shared.Input.PointerInputCmdMessage"/>.
            </summary>
            <param name="tick">Client tick this was created.</param>
            <param name="inputFunctionId">Function this command is changing.</param>
            <param name="coordinates">Local Coordinates of the pointer when the command was created.</param>
        </member>
        <member name="M:Robust.Shared.Input.PointerInputCmdMessage.#ctor(Robust.Shared.Timing.GameTick,System.UInt16,Robust.Shared.Input.KeyFunctionId,Robust.Shared.Map.NetCoordinates,Robust.Shared.GameObjects.NetEntity)">
            <summary>
                Creates an instance of <see cref="T:Robust.Shared.Input.PointerInputCmdMessage"/> with an optional Entity reference.
            </summary>
            <param name="tick">Client tick this was created.</param>
            <param name="inputFunctionId">Function this command is changing.</param>
            <param name="coordinates">Local Coordinates of the pointer when the command was created.</param>
            <param name="uid">Entity that was under the pointer when the command was created.</param>
        </member>
        <member name="T:Robust.Shared.Input.ClientFullInputCmdMessage">
            <summary>
            Handles inputs clientside. This is used so the client can still interact with client-only entities without relying on
            <see cref="T:Robust.Shared.GameObjects.NetEntity"/>.
            </summary>
        </member>
        <member name="P:Robust.Shared.Input.ClientFullInputCmdMessage.State">
            <summary>
                New state of the Input Function.
            </summary>
        </member>
        <member name="P:Robust.Shared.Input.ClientFullInputCmdMessage.Coordinates">
            <summary>
                Local Coordinates of the pointer when the command was created.
            </summary>
        </member>
        <member name="P:Robust.Shared.Input.ClientFullInputCmdMessage.ScreenCoordinates">
            <summary>
                Screen Coordinates of the pointer when the command was created.
            </summary>
        </member>
        <member name="P:Robust.Shared.Input.ClientFullInputCmdMessage.Uid">
            <summary>
                Entity that was under the pointer when the command was created (if any).
            </summary>
        </member>
        <member name="T:Robust.Shared.Input.FullInputCmdMessage">
            <summary>
                An input command that has both state and pointer info.
            </summary>
        </member>
        <member name="P:Robust.Shared.Input.FullInputCmdMessage.State">
            <summary>
                New state of the Input Function.
            </summary>
        </member>
        <member name="P:Robust.Shared.Input.FullInputCmdMessage.Coordinates">
            <summary>
                Local Coordinates of the pointer when the command was created.
            </summary>
        </member>
        <member name="P:Robust.Shared.Input.FullInputCmdMessage.ScreenCoordinates">
            <summary>
                Screen Coordinates of the pointer when the command was created.
            </summary>
        </member>
        <member name="P:Robust.Shared.Input.FullInputCmdMessage.Uid">
            <summary>
                Entity that was under the pointer when the command was created (if any).
            </summary>
        </member>
        <member name="M:Robust.Shared.Input.FullInputCmdMessage.#ctor(Robust.Shared.Timing.GameTick,System.UInt16,System.Int32,Robust.Shared.Input.KeyFunctionId,Robust.Shared.Input.BoundKeyState,Robust.Shared.Map.NetCoordinates,Robust.Shared.Map.ScreenCoordinates)">
            <summary>
                Creates an instance of <see cref="T:Robust.Shared.Input.FullInputCmdMessage"/>.
            </summary>
            <param name="tick">Client tick this was created.</param>
            <param name="inputSequence"></param>
            <param name="inputFunctionId">Function this command is changing.</param>
            <param name="state">New state of the Input Function.</param>
            <param name="coordinates">Local Coordinates of the pointer when the command was created.</param>
            <param name="screenCoordinates"></param>
        </member>
        <member name="M:Robust.Shared.Input.FullInputCmdMessage.#ctor(Robust.Shared.Timing.GameTick,System.UInt16,Robust.Shared.Input.KeyFunctionId,Robust.Shared.Input.BoundKeyState,Robust.Shared.Map.NetCoordinates,Robust.Shared.Map.ScreenCoordinates,Robust.Shared.GameObjects.NetEntity)">
            <summary>
                Creates an instance of <see cref="T:Robust.Shared.Input.FullInputCmdMessage"/> with an optional Entity reference.
            </summary>
            <param name="tick">Client tick this was created.</param>
            <param name="inputFunctionId">Function this command is changing.</param>
            <param name="state">New state of the Input Function.</param>
            <param name="coordinates">Local Coordinates of the pointer when the command was created.</param>
            <param name="screenCoordinates"></param>
            <param name="uid">Entity that was under the pointer when the command was created.</param>
        </member>
        <member name="T:Robust.Shared.Input.IInputContextContainer">
            <summary>
                Contains a set of created <see cref="T:Robust.Shared.Input.InputCmdContext"/>s.
            </summary>
        </member>
        <member name="P:Robust.Shared.Input.IInputContextContainer.ActiveContext">
            <summary>
                The current "active" context that should be used for filtering key binds.
            </summary>
        </member>
        <member name="P:Robust.Shared.Input.IInputContextContainer.DeferringEnabled">
            <summary>
                Puts context switches 'on hold'. When set to false, the last deferred context switch is executed, if any.
            </summary>
        </member>
        <member name="E:Robust.Shared.Input.IInputContextContainer.ContextChanged">
            <summary>
                This event is raised when ever the Active Context is changed.
            </summary>
        </member>
        <member name="M:Robust.Shared.Input.IInputContextContainer.New(System.String,System.String)">
            <summary>
                Adds a new unique context to the set.
            </summary>
            <param name="uniqueName">Unique name of the new context.</param>
            <param name="parentName">Unique name of the parent context. Tee parent context must already exist in the set.</param>
            <returns>Instance of the newly created context.</returns>
        </member>
        <member name="M:Robust.Shared.Input.IInputContextContainer.New(System.String,Robust.Shared.Input.IInputCmdContext)">
            <summary>
                Adds a new unique context to the set.
            </summary>
            <param name="uniqueName">Unique name of the new context.</param>
            <param name="parent">Context to set, as the parent context, of the newly created context.</param>
            <returns>Instance of the newly created context.</returns>
        </member>
        <member name="M:Robust.Shared.Input.IInputContextContainer.Exists(System.String)">
            <summary>
                Checks if a context with a unique name exists in the set.
            </summary>
            <param name="uniqueName">Unique Name to search for.</param>
            <returns>If a context exists with the given unique name in the set.</returns>
        </member>
        <member name="M:Robust.Shared.Input.IInputContextContainer.GetContext(System.String)">
            <summary>
                Returns the context with the given unique name from the set.
            </summary>
            <param name="uniqueName">Unique name of the context to search for.</param>
            <returns>Context with the given unique name in the set.</returns>
        </member>
        <member name="M:Robust.Shared.Input.IInputContextContainer.TryGetContext(System.String,Robust.Shared.Input.IInputCmdContext@)">
            <summary>
                Tries to find a context with a given unique name.
            </summary>
            <param name="uniqueName">Unique name of the context to search for.</param>
            <param name="context">The context with the given unique name (if any).</param>
            <returns>If a context with a given unique name exists in the set.</returns>
        </member>
        <member name="M:Robust.Shared.Input.IInputContextContainer.Remove(System.String)">
            <summary>
                Removes the context with the given unique name.
            </summary>
            <param name="uniqueName">Unique name of context to remove.</param>
        </member>
        <member name="M:Robust.Shared.Input.IInputContextContainer.SetActiveContext(System.String)">
            <summary>
                Sets the context with the given unique name as the Active context.
                This *may* be deferred if during input handling, and if multiple context switches are deferred, only the last 'counts'.
            </summary>
            <param name="uniqueName">Unique name of the context to set as active.</param>
        </member>
        <member name="T:Robust.Shared.Input.InputContextContainer">
            <inheritdoc />
        </member>
        <member name="F:Robust.Shared.Input.InputContextContainer.DefaultContextName">
            <summary>
                Default 'root' context unique name that always exists in the set.
            </summary>
        </member>
        <member name="E:Robust.Shared.Input.InputContextContainer.ContextChanged">
            <inheritdoc />
        </member>
        <member name="F:Robust.Shared.Input.InputContextContainer._deferredContextSwitch">
            <summary>
                This is used to hold a pending context switch, because someone decided that:
                 + Reentrant input events were illegal
                  and
                 + Context switches ought to generate input events
                This prevents the inevitable errors this caused from input events that switch contexts,
                 by deferring the context switches until we're definitely out of input event code.
            </summary>
        </member>
        <member name="P:Robust.Shared.Input.InputContextContainer.ActiveContext">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Input.InputContextContainer.DeferringEnabled">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Input.InputContextContainer.#ctor">
            <summary>
                Creates a new instance of <see cref="T:Robust.Shared.Input.InputCmdContext"/>.
            </summary>
        </member>
        <member name="M:Robust.Shared.Input.InputContextContainer.New(System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Input.InputContextContainer.New(System.String,Robust.Shared.Input.IInputCmdContext)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Input.InputContextContainer.Exists(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Input.InputContextContainer.GetContext(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Input.InputContextContainer.TryGetContext(System.String,Robust.Shared.Input.IInputCmdContext@)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Input.InputContextContainer.Remove(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Input.InputContextContainer.SetActiveContext(System.String)">
            <inheritdoc />
        </member>
        <member name="T:Robust.Shared.Input.ContextChangedEventArgs">
            <summary>
                Event arguments for an input context change.
            </summary>
        </member>
        <member name="P:Robust.Shared.Input.ContextChangedEventArgs.NewContext">
            <summary>
                The new context that became active.
            </summary>
        </member>
        <member name="P:Robust.Shared.Input.ContextChangedEventArgs.OldContext">
            <summary>
                The old context that used to be active.
            </summary>
        </member>
        <member name="M:Robust.Shared.Input.ContextChangedEventArgs.#ctor(Robust.Shared.Input.IInputCmdContext,Robust.Shared.Input.IInputCmdContext)">
            <summary>
                Constructs a new instance of <see cref="T:Robust.Shared.Input.ContextChangedEventArgs"/>/
            </summary>
            <param name="oldContext">The old context that used to be active.</param>
            <param name="newContext">The new context that became active.</param>
        </member>
        <member name="T:Robust.Shared.Input.KeyFunctionsAttribute">
            <summary>
                Makes all constant strings on this static class be added as input functions.
            </summary>
        </member>
        <member name="T:Robust.Shared.Input.IPlayerCommandStates">
            <summary>
                Contains a mapping of <see cref="T:Robust.Shared.Input.BoundKeyFunction"/> to their current <see cref="T:Robust.Shared.Input.BoundKeyState"/>.
            </summary>
        </member>
        <member name="P:Robust.Shared.Input.IPlayerCommandStates.Item(Robust.Shared.Input.BoundKeyFunction)">
            <summary>
                Indexer access to the Get/Set functions.
            </summary>
        </member>
        <member name="M:Robust.Shared.Input.IPlayerCommandStates.GetState(Robust.Shared.Input.BoundKeyFunction)">
            <summary>
                Gets the current state of a function.
            </summary>
            <param name="function">Function to get the state of.</param>
            <returns>Current state of the function.</returns>
        </member>
        <member name="M:Robust.Shared.Input.IPlayerCommandStates.SetState(Robust.Shared.Input.BoundKeyFunction,Robust.Shared.Input.BoundKeyState)">
            <summary>
                Sets the current state of a function.
            </summary>
            <param name="function">Function to change.</param>
            <param name="state">State value to set.</param>
        </member>
        <member name="T:Robust.Shared.Input.PlayerCommandStates">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Input.PlayerCommandStates.Item(Robust.Shared.Input.BoundKeyFunction)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Input.PlayerCommandStates.GetState(Robust.Shared.Input.BoundKeyFunction)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Input.PlayerCommandStates.SetState(Robust.Shared.Input.BoundKeyFunction,Robust.Shared.Input.BoundKeyState)">
            <inheritdoc />
        </member>
        <member name="T:Robust.Shared.IoC.DependencyAttribute">
            <summary>
            Specifies that the field this is applied to is a dependency,
            which will be resolved by <see cref="T:Robust.Shared.IoC.IoCManager" /> when the containing class is instantiated.
            </summary>
            <remarks>
            <para>
            The dependency is resolved as if <see cref="M:Robust.Shared.IoC.IoCManager.Resolve``1" /> were to be called,
            but it avoids circular references and init order issues due to internal code in the <see cref="T:Robust.Shared.IoC.IoCManager" />.
            </para>
            <para>
            The dependency can be injected into read only fields without issues,
            and as a matter of fact it is recommended to use read only fields.
            </para>
            <para>
            If you would like to run code after the dependencies have been injected, use <see cref="T:Robust.Shared.IoC.IPostInjectInit" />
            </para>
            </remarks>
        </member>
        <member name="T:Robust.Shared.IoC.DependencyCollection">
            <inheritdoc />
        </member>
        <member name="F:Robust.Shared.IoC.DependencyCollection._services">
            <summary>
            Dictionary that maps the types passed to <see cref="M:Robust.Shared.IoC.DependencyCollection.Resolve``1"/> to their implementation.
            This is the first dictionary to get hit on a resolve.
            </summary>
            <remarks>
            Immutable and atomically swapped to provide thread safety guarantees.
            </remarks>
        </member>
        <member name="F:Robust.Shared.IoC.DependencyCollection._resolveTypes">
            <summary>
            The types interface types mapping to their registered implementations.
            This is pulled from to make a service if it doesn't exist yet.
            </summary>
        </member>
        <member name="M:Robust.Shared.IoC.DependencyCollection.GetRegisteredTypes">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.IoC.DependencyCollection.TryResolveType``1(``0@)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.IoC.DependencyCollection.TryResolveType(System.Type,System.Object@)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.IoC.DependencyCollection.Register``2(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.IoC.DependencyCollection.Register``2(Robust.Shared.IoC.DependencyFactoryDelegate{``1},System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.IoC.DependencyCollection.Register(System.Type,Robust.Shared.IoC.DependencyFactoryDelegate{System.Object},System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.IoC.DependencyCollection.RegisterInstance(System.Type,System.Object,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.IoC.DependencyCollection.Clear">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.IoC.DependencyCollection.Resolve``1">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.IoC.DependencyCollection.ResolveType(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.IoC.DependencyCollection.BuildGraph">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.IoC.DependencyCollection.InjectDependencies(System.Object,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="T:Robust.Shared.IoC.DependencyCollectionExt">
            <summary>
            Extension methods for <see cref="T:Robust.Shared.IoC.IDependencyCollection"/>.
            </summary>
        </member>
        <member name="M:Robust.Shared.IoC.DependencyCollectionExt.Register``1(Robust.Shared.IoC.IDependencyCollection)">
            <summary>
            Register a type as both implementation and interface.
            This is equivalent to calling <see cref="M:Robust.Shared.IoC.IDependencyCollection.Register``2(System.Boolean)"/> with both type args set to <typeparamref name="T"/>.
            </summary>
            <param name="deps">The dependency collection to register into.</param>
        </member>
        <member name="T:Robust.Shared.IoC.IDynamicTypeFactory">
            <summary>
                The sole purpose of this factory is to create arbitrary objects that have their
                dependencies resolved. If you think you need Activator.CreateInstance(), use this
                factory instead.
            </summary>
            <seealso cref="T:Robust.Shared.IoC.DynamicTypeFactoryExt"/>
        </member>
        <member name="M:Robust.Shared.IoC.IDynamicTypeFactory.CreateInstance(System.Type,System.Boolean,System.Boolean)">
            <summary>
                Constructs a new instance of the given type with Dependencies resolved.
                The type MUST have a parameterless constructor.
            </summary>
            <param name="type">Type of object to instantiate.</param>
            <param name="oneOff">If true, do not cache injector delegates.</param>
            <param name="inject">If false, will not inject dependencies.</param>
            <returns>Newly created object.</returns>
        </member>
        <member name="M:Robust.Shared.IoC.IDynamicTypeFactory.CreateInstance(System.Type,System.Object[],System.Boolean,System.Boolean)">
            <summary>
                Constructs a new instance of the given type with Dependencies resolved.
            </summary>
            <param name="type">Type of object to instantiate.</param>
            <param name="args">The arguments to be passed to the constructor.</param>
            <param name="oneOff">If true, do not cache injector delegates.</param>
            <param name="inject">If false, will not inject dependencies.</param>
            <returns>Newly created object.</returns>
        </member>
        <member name="M:Robust.Shared.IoC.IDynamicTypeFactory.CreateInstance``1(System.Boolean,System.Boolean)">
            <summary>
                Constructs a new instance of the given type with Dependencies resolved.
            </summary>
            <param name="oneOff">If true, do not cache injector delegates.</param>
            <param name="inject">If false, will not inject dependencies.</param>
            <typeparam name="T">Type of object to instantiate.</typeparam>
            <returns>Newly created object.</returns>
        </member>
        <member name="M:Robust.Shared.IoC.IDynamicTypeFactoryInternal.CreateInstanceUnchecked(System.Type,System.Boolean,System.Boolean)">
            <summary>
                Constructs a new instance of the given type with Dependencies resolved.
                The type MUST have a parameterless constructor.
            </summary>
            <param name="type">Type of object to instantiate.</param>
            <param name="oneOff">If true, do not cache injector delegates.</param>
            <param name="inject">If false, will not inject dependencies.</param>
            <returns>Newly created object.</returns>
        </member>
        <member name="M:Robust.Shared.IoC.IDynamicTypeFactoryInternal.CreateInstanceUnchecked(System.Type,System.Object[],System.Boolean,System.Boolean)">
            <summary>
                Constructs a new instance of the given type with Dependencies resolved.
            </summary>
            <param name="type">Type of object to instantiate.</param>
            <param name="args">The arguments to be passed to the constructor.</param>
            <param name="oneOff">If true, do not cache injector delegates.</param>
            <param name="inject">If false, will not inject dependencies.</param>
            <returns>Newly created object.</returns>
        </member>
        <member name="M:Robust.Shared.IoC.IDynamicTypeFactoryInternal.CreateInstanceUnchecked``1(System.Boolean,System.Boolean)">
            <summary>
                Constructs a new instance of the given type with Dependencies resolved.
            </summary>
            <param name="oneOff">If true, do not cache injector delegates.</param>
            <param name="inject">If false, will not inject dependencies.</param>
            <typeparam name="T">Type of object to instantiate.</typeparam>
            <returns>Newly created object.</returns>
        </member>
        <member name="T:Robust.Shared.IoC.DynamicTypeFactoryExt">
            <summary>
                Extension methods for <see cref="T:Robust.Shared.IoC.IDynamicTypeFactory"/>.
            </summary>
        </member>
        <member name="M:Robust.Shared.IoC.DynamicTypeFactoryExt.CreateInstance``1(Robust.Shared.IoC.IDynamicTypeFactory,System.Type,System.Boolean,System.Boolean)">
            <summary>
                Constructs a new instance of the given type, and return it cast to the specified type.
            </summary>
            <param name="dynamicTypeFactory">The dynamic type factory to use.</param>
            <param name="type">The type to instantiate.</param>
            <param name="oneOff">If true, do not cache injector delegates.</param>
            <param name="inject">If false, will not inject dependencies.</param>
            <typeparam name="T">The type that the instance will be cast to.</typeparam>
            <returns>Newly created object, cast to <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:Robust.Shared.IoC.DynamicTypeFactoryExt.CreateInstance``1(Robust.Shared.IoC.IDynamicTypeFactory,System.Type,System.Object[],System.Boolean,System.Boolean)">
            <summary>
                Constructs a new instance of the given type, and return it cast to the specified type.
            </summary>
            <param name="dynamicTypeFactory">The dynamic type factory to use.</param>
            <param name="type">The type to instantiate.</param>
            <param name="args">The arguments to pass to the constructor.</param>
            <param name="oneOff">If true, do not cache injector delegates.</param>
            <param name="inject">If false, will not inject dependencies.</param>
            <typeparam name="T">The type that the instance will be cast to.</typeparam>
            <returns>Newly created object, cast to <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:Robust.Shared.IoC.DynamicTypeFactoryExt.CreateInstanceUnchecked``1(Robust.Shared.IoC.IDynamicTypeFactoryInternal,System.Type,System.Boolean,System.Boolean)">
            <summary>
                Constructs a new instance of the given type, and return it cast to the specified type.
            </summary>
            <param name="dynamicTypeFactory">The dynamic type factory to use.</param>
            <param name="type">The type to instantiate.</param>
            <param name="oneOff">If true, do not cache injector delegates.</param>
            <param name="inject">If false, will not inject dependencies.</param>
            <typeparam name="T">The type that the instance will be cast to.</typeparam>
            <returns>Newly created object, cast to <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:Robust.Shared.IoC.DynamicTypeFactoryExt.CreateInstanceUnchecked``1(Robust.Shared.IoC.IDynamicTypeFactoryInternal,System.Type,System.Object[],System.Boolean,System.Boolean)">
            <summary>
                Constructs a new instance of the given type, and return it cast to the specified type.
            </summary>
            <param name="dynamicTypeFactory">The dynamic type factory to use.</param>
            <param name="type">The type to instantiate.</param>
            <param name="oneOff">If true, do not cache injector delegates.</param>
            <param name="inject">If false, will not inject dependencies.</param>
            <param name="args">The arguments to pass to the constructor.</param>
            <typeparam name="T">The type that the instance will be cast to.</typeparam>
            <returns>Newly created object, cast to <typeparamref name="T"/>.</returns>
        </member>
        <member name="T:Robust.Shared.IoC.DynamicTypeFactory">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.IoC.DynamicTypeFactory.CreateInstance(System.Type,System.Boolean,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.IoC.DynamicTypeFactory.CreateInstance``1(System.Boolean,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="T:Robust.Shared.IoC.Exceptions.ImplementationConstructorException">
            <summary>
            Signifies that a type threw an exception from its constructor while IoC was trying to build it.
            </summary>
        </member>
        <member name="F:Robust.Shared.IoC.Exceptions.ImplementationConstructorException.typeName">
            <summary>
            The <see cref="P:System.Type.AssemblyQualifiedName" /> of the type that threw the exception inside its constructor.
            </summary>
        </member>
        <member name="T:Robust.Shared.IoC.Exceptions.InvalidImplementationException">
            <summary>
            An exception for when a type doesn't correctly implement an interface, but is still IoC or reflection accessible..
            Such as missing an attribute.
            </summary>
            <seealso cref="T:Robust.Shared.IoC.IoCManager" />
            <seealso cref="T:Robust.Shared.Reflection.IReflectionManager" />
        </member>
        <member name="M:Robust.Shared.IoC.Exceptions.InvalidImplementationException.#ctor(System.Type,System.Type,System.String)">
            <param name="type">The implementation incorrectly implementing something.</param>
            <param name="parent">The interface incorrectly being implemented.</param>
            <param name="message">Additionally info.</param>
        </member>
        <member name="T:Robust.Shared.IoC.Exceptions.UnregisteredDependencyException">
            <summary>
            Like <see cref="T:Robust.Shared.IoC.Exceptions.UnregisteredTypeException"/>,
            except that this is thrown when using field injection via <see cref="T:Robust.Shared.IoC.DependencyAttribute"/> and includes extra metadata.
            </summary>
        </member>
        <member name="F:Robust.Shared.IoC.Exceptions.UnregisteredDependencyException.OwnerType">
            <summary>
            The type name of the type requesting the unregistered dependency.
            </summary>
        </member>
        <member name="F:Robust.Shared.IoC.Exceptions.UnregisteredDependencyException.TargetType">
            <summary>
            The type name of the type that was requested and unregistered.
            </summary>
        </member>
        <member name="F:Robust.Shared.IoC.Exceptions.UnregisteredDependencyException.FieldName">
            <summary>
            The name of the field that was marked as dependency.
            </summary>
        </member>
        <member name="T:Robust.Shared.IoC.Exceptions.UnregisteredTypeException">
            <summary>
            Thrown by <see cref="M:Robust.Shared.IoC.IoCManager.Resolve``1"/> if one attempts to resolve an interface that isn't registered.
            </summary>
        </member>
        <member name="F:Robust.Shared.IoC.Exceptions.UnregisteredTypeException.TypeName">
            <summary>
            The actual type that was attempted to be resolved, but wasn't registered. This is the <see cref="P:System.Type.AssemblyQualifiedName"/>.
            </summary>
        </member>
        <member name="T:Robust.Shared.IoC.IDependencyCollection">
            <summary>
            The IoCManager handles Dependency Injection in the project.
            </summary>
            <remarks>
            <para>
            Dependency Injection is a concept where instead of saying "I need the <c>EntityManager</c>",
            you say "I need something that implements <c>IEntityManager</c>".
            This decouples the various systems into swappable components that have standardized interfaces.
            </para>
            <para>
            This is useful for a couple of things.
            Firstly, it allows the shared code to request the client or server code implicitly, without hacks.
            Secondly, it's very useful for unit tests as we can replace components to test things.
            </para>
            <para>
            To use the IoCManager, it first needs some types registered through <see cref="M:Robust.Shared.IoC.IDependencyCollection.Register``2(System.Boolean)"/>.
            These implementations can then be fetched with <see cref="M:Robust.Shared.IoC.IDependencyCollection.Resolve``1"/>, or through field injection with <see cref="T:Robust.Shared.IoC.DependencyAttribute" />.
            </para>
            <para>
            This type is thread safe: registration and <see cref="M:Robust.Shared.IoC.IDependencyCollection.BuildGraph"/> can run concurrently with resolves.
            </para>
            </remarks>
            <seealso cref="T:Robust.Shared.Reflection.IReflectionManager"/>
        </member>
        <member name="M:Robust.Shared.IoC.IDependencyCollection.GetRegisteredTypes">
            <summary>
            Enumerates over all registered types.
            </summary>
        </member>
        <member name="M:Robust.Shared.IoC.IDependencyCollection.Register``2(System.Boolean)">
            <summary>
            Registers an interface to an implementation, to make it accessible to <see cref="M:Robust.Shared.IoC.DependencyCollection.Resolve``1"/>
            <see cref="M:Robust.Shared.IoC.IDependencyCollection.BuildGraph"/> MUST be called after this method to make the new interface available.
            </summary>
            <typeparam name="TInterface">The type that will be resolvable.</typeparam>
            <typeparam name="TImplementation">The type that will be constructed as implementation.</typeparam>
            <param name="overwrite">
            If true, do not throw an <see cref="T:System.InvalidOperationException"/> if an interface is already registered,
            replace the current implementation instead.
            </param>
            <exception cref="T:System.InvalidOperationException">
            Thrown if <paramref name="overwrite"/> is false and <typeparamref name="TInterface"/> has been registered before,
            or if an already instantiated interface (by <see cref="M:Robust.Shared.IoC.DependencyCollection.BuildGraph"/>) is attempting to be overwritten.
            </exception>
        </member>
        <member name="M:Robust.Shared.IoC.IDependencyCollection.Register``2(Robust.Shared.IoC.DependencyFactoryDelegate{``1},System.Boolean)">
            <summary>
            Registers an interface to an implementation, to make it accessible to <see cref="M:Robust.Shared.IoC.DependencyCollection.Resolve``1"/>
            <see cref="M:Robust.Shared.IoC.IDependencyCollection.BuildGraph"/> MUST be called after this method to make the new interface available.
            </summary>
            <typeparam name="TInterface">The type that will be resolvable.</typeparam>
            <typeparam name="TImplementation">The type that will be constructed as implementation.</typeparam>
            <param name="factory">A factory method to construct the instance of the implementation.</param>
            <param name="overwrite">
            If true, do not throw an <see cref="T:System.InvalidOperationException"/> if an interface is already registered,
            replace the current implementation instead.
            </param>
            <exception cref="T:System.InvalidOperationException">
            Thrown if <paramref name="overwrite"/> is false and <typeparamref name="TInterface"/> has been registered before,
            or if an already instantiated interface (by <see cref="M:Robust.Shared.IoC.DependencyCollection.BuildGraph"/>) is attempting to be overwritten.
            </exception>
        </member>
        <member name="M:Robust.Shared.IoC.IDependencyCollection.Register(System.Type,Robust.Shared.IoC.DependencyFactoryDelegate{System.Object},System.Boolean)">
            <summary>
            Registers a simple implementation without an interface.
            </summary>
            <param name="implementation">The type that will be resolvable.</param>
            <param name="factory">A factory method to construct the instance of the implementation.</param>
            <param name="overwrite">
            If true, do not throw an <see cref="T:System.InvalidOperationException"/> if an interface is already registered,
            replace the current implementation instead.
            </param>
        </member>
        <member name="M:Robust.Shared.IoC.IDependencyCollection.Register(System.Type,System.Type,Robust.Shared.IoC.DependencyFactoryDelegate{System.Object},System.Boolean)">
            <summary>
            Registers a simple implementation without an interface.
            </summary>
            <param name="interfaceType">The type that will be resolvable.</param>
            <param name="implementation">The type that will be resolvable.</param>
            <param name="factory">A factory method to construct the instance of the implementation.</param>
            <param name="overwrite">
            If true, do not throw an <see cref="T:System.InvalidOperationException"/> if an interface is already registered,
            replace the current implementation instead.
            </param>
        </member>
        <member name="M:Robust.Shared.IoC.IDependencyCollection.RegisterInstance``1(System.Object,System.Boolean)">
            <summary>
                Registers an interface to an existing instance of an implementation,
                making it accessible to <see cref="M:Robust.Shared.IoC.IDependencyCollection.Resolve``1"/>.
                Unlike <see cref="M:Robust.Shared.IoC.IDependencyCollection.Register``2(System.Boolean)"/>,
                <see cref="M:Robust.Shared.IoC.IDependencyCollection.BuildGraph"/> does not need to be called after registering an instance
                if deferredInject is false.
            </summary>
            <typeparam name="TInterface">The type that will be resolvable.</typeparam>
            <param name="implementation">The existing instance to use as the implementation.</param>
            <param name="overwrite">
                If true, do not throw an <see cref="T:System.InvalidOperationException"/> if an interface is already registered,
                replace the current implementation instead.
            </param>
        </member>
        <member name="M:Robust.Shared.IoC.IDependencyCollection.RegisterInstance(System.Type,System.Object,System.Boolean)">
            <summary>
                Registers an interface to an existing instance of an implementation,
                making it accessible to <see cref="M:Robust.Shared.IoC.IDependencyCollection.Resolve``1"/>.
                Unlike <see cref="M:Robust.Shared.IoC.IDependencyCollection.Register``2(System.Boolean)"/>,
                <see cref="M:Robust.Shared.IoC.IDependencyCollection.BuildGraph"/> does not need to be called after registering an instance.
            </summary>
            <param name="type">The type that will be resolvable.</param>
            <param name="implementation">The existing instance to use as the implementation.</param>
            <param name="overwrite">
                If true, do not throw an <see cref="T:System.InvalidOperationException"/> if an interface is already registered,
                replace the current implementation instead.
            </param>
        </member>
        <member name="M:Robust.Shared.IoC.IDependencyCollection.Clear">
            <summary>
            Clear all services and types.
            Use this between unit tests and on program shutdown.
            If a service implements <see cref="T:System.IDisposable"/>, <see cref="M:System.IDisposable.Dispose"/> will be called on it.
            </summary>
        </member>
        <member name="M:Robust.Shared.IoC.IDependencyCollection.Resolve``1">
            <summary>
            Resolve a dependency manually.
            </summary>
            <exception cref="T:Robust.Shared.IoC.Exceptions.UnregisteredTypeException">Thrown if the interface is not registered.</exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown if the resolved type hasn't been created yet
            because the object graph still needs to be constructed for it.
            </exception>
        </member>
        <member name="M:Robust.Shared.IoC.IDependencyCollection.Resolve``1(``0@)">
            <inheritdoc cref="M:Robust.Shared.IoC.IDependencyCollection.Resolve``1"/>
        </member>
        <member name="M:Robust.Shared.IoC.IDependencyCollection.Resolve``2(``0@,``1@)">
            <inheritdoc cref="!:Resolve&lt;T&gt;(ref T?)"/>
            <summary>
            Resolve two dependencies manually.
            </summary>
        </member>
        <member name="M:Robust.Shared.IoC.IDependencyCollection.Resolve``3(``0@,``1@,``2@)">
            <inheritdoc cref="!:Resolve&lt;T1, T2&gt;(ref T1?, ref T2?)"/>
            <summary>
            Resolve three dependencies manually.
            </summary>
        </member>
        <member name="M:Robust.Shared.IoC.IDependencyCollection.Resolve``4(``0@,``1@,``2@,``3@)">
            <inheritdoc cref="!:Resolve&lt;T1, T2, T3&gt;(ref T1?, ref T2?, ref T3?)"/>
            <summary>
            Resolve four dependencies manually.
            </summary>
        </member>
        <member name="M:Robust.Shared.IoC.IDependencyCollection.ResolveType(System.Type)">
            <summary>
            Resolve a dependency manually.
            </summary>
            <exception cref="T:Robust.Shared.IoC.Exceptions.UnregisteredTypeException">Thrown if the interface is not registered.</exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown if the resolved type hasn't been created yet
            because the object graph still needs to be constructed for it.
            </exception>
        </member>
        <member name="M:Robust.Shared.IoC.IDependencyCollection.TryResolveType``1(``0@)">
            <summary>
            Resolve a dependency manually.
            </summary>
        </member>
        <member name="M:Robust.Shared.IoC.IDependencyCollection.TryResolveType(System.Type,System.Object@)">
            <summary>
            Resolve a dependency manually.
            </summary>
        </member>
        <member name="M:Robust.Shared.IoC.IDependencyCollection.BuildGraph">
            <summary>
            Initializes the object graph by building every object and resolving all dependencies.
            </summary>
            <seealso cref="M:Robust.Shared.IoC.DependencyCollection.InjectDependencies(System.Object,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.IoC.IDependencyCollection.InjectDependencies(System.Object,System.Boolean)">
            <summary>
                Injects dependencies into all fields with <see cref="T:Robust.Shared.IoC.DependencyAttribute"/> on the provided object.
                This is useful for objects that are not IoC created, and want to avoid tons of IoC.Resolve() calls.
            </summary>
            <remarks>
                This does NOT initialize IPostInjectInit objects!
            </remarks>
            <param name="obj">The object to inject into.</param>
            <param name="oneOff">If true, this object type is not expected to be injected commonly.</param>
            <exception cref="T:Robust.Shared.IoC.Exceptions.UnregisteredDependencyException">
                Thrown if a dependency field on the object is not registered.
            </exception>
            <seealso cref="M:Robust.Shared.IoC.DependencyCollection.BuildGraph"/>
        </member>
        <member name="T:Robust.Shared.IoC.IoCManager">
            <summary>
            The IoCManager handles Dependency Injection in the project.
            </summary>
            <remarks>
            <para>
            Dependency Injection is a concept where instead of saying "I need the <c>EntityManager</c>",
            you say "I need something that implements <c>IEntityManager</c>".
            This decouples the various systems into swappable components that have standardized interfaces.
            </para>
            <para>
            This is useful for a couple of things.
            Firstly, it allows the shared code to request the client or server code implicitly, without hacks.
            Secondly, it's very useful for unit tests as we can replace components to test things.
            </para>
            <para>
            To use the IoCManager, it first needs some types registered through <see cref="M:Robust.Shared.IoC.IoCManager.Register``2(System.Boolean)"/>.
            These implementations can then be fetched with <see cref="M:Robust.Shared.IoC.IoCManager.Resolve``1"/>, or through field injection with <see cref="T:Robust.Shared.IoC.DependencyAttribute" />.
            </para>
            <para>
            <c>IoCManager</c> is actually a static wrapper class around a thread local <see cref="T:Robust.Shared.IoC.IDependencyCollection"/>.
            As such, <c>IoCManager</c> will not work in other threads,
            unless they have first been initialized with <see cref="M:Robust.Shared.IoC.IoCManager.InitThread"/> or <see cref="M:Robust.Shared.IoC.IoCManager.InitThread(Robust.Shared.IoC.IDependencyCollection,System.Boolean)"/>.
            You should not initialize IoC in thread pools like that of <see cref="M:System.Threading.Tasks.Task.Run(System.Action)"/>,
            since said thread pool might be used by different running instances
            (for example, server and client running in the same process, they have a different IoC instance).
            </para>
            </remarks>
            <seealso cref="T:Robust.Shared.Reflection.IReflectionManager"/>
        </member>
        <member name="P:Robust.Shared.IoC.IoCManager.Instance">
            <summary>
            Returns the singleton thread-local instance of the IoCManager's dependency collection.
            </summary>
            <remarks>
            This property will be null if <see cref="M:Robust.Shared.IoC.IoCManager.InitThread"/> has not been called on this thread yet.
            </remarks>
        </member>
        <member name="M:Robust.Shared.IoC.IoCManager.InitThread">
            <summary>
            Ensures that the <see cref="T:Robust.Shared.IoC.IDependencyCollection"/> instance exists for this thread.
            </summary>
            <remarks>
            This will create a new instance of a <see cref="T:Robust.Shared.IoC.IDependencyCollection"/> for this thread,
            otherwise it will do nothing if one already exists.
            </remarks>
            <returns>The dependency collection for this thread.</returns>
        </member>
        <member name="M:Robust.Shared.IoC.IoCManager.InitThread(Robust.Shared.IoC.IDependencyCollection,System.Boolean)">
            <summary>
            Sets an existing <see cref="T:Robust.Shared.IoC.IDependencyCollection"/> as the instance for this thread.
            </summary>
            <exception cref="T:System.InvalidOperationException">Will be thrown if a <see cref="T:Robust.Shared.IoC.IDependencyCollection"/> instance is already set for this thread,
            and replaceExisting is set to false.</exception>
            <param name="collection">Collection to set as the instance for this thread.</param>
            <param name="replaceExisting">If this is true, replaces the existing collection, if one is set for this thread.</param>
        </member>
        <member name="M:Robust.Shared.IoC.IoCManager.Register``2(System.Boolean)">
            <summary>
            Registers an interface to an implementation, to make it accessible to <see cref="M:Robust.Shared.IoC.IoCManager.Resolve``1"/>
            </summary>
            <typeparam name="TInterface">The type that will be resolvable.</typeparam>
            <typeparam name="TImplementation">The type that will be constructed as implementation.</typeparam>
            <param name="overwrite">
            If true, do not throw an <see cref="T:System.InvalidOperationException"/> if an interface is already registered,
            replace the current implementation instead.
            </param>
            <exception cref="T:System.InvalidOperationException">
            Thrown if <paramref name="overwrite"/> is false and <typeparamref name="TInterface"/> has been registered before,
            or if an already instantiated interface (by <see cref="M:Robust.Shared.IoC.IoCManager.BuildGraph"/>) is attempting to be overwritten.
            </exception>
        </member>
        <member name="M:Robust.Shared.IoC.IoCManager.Register``1(System.Boolean)">
            <summary>
            Register an implementation, to make it accessible to <see cref="M:Robust.Shared.IoC.IoCManager.Resolve``1"/>
            </summary>
            <typeparam name="T">The type that will be resolvable and implementation.</typeparam>
            <param name="overwrite">
            If true, do not throw an <see cref="T:System.InvalidOperationException"/> if an interface is already registered,
            replace the current implementation instead.
            </param>
            <exception cref="T:System.InvalidOperationException">
            Thrown if <paramref name="overwrite"/> is false and <typeparamref name="T"/> has been registered before,
            or if an already instantiated interface (by <see cref="M:Robust.Shared.IoC.IoCManager.BuildGraph"/>) is attempting to be overwritten.
            </exception>
        </member>
        <member name="M:Robust.Shared.IoC.IoCManager.Register``2(Robust.Shared.IoC.DependencyFactoryDelegate{``1},System.Boolean)">
            <summary>
            Registers an interface to an implementation, to make it accessible to <see cref="M:Robust.Shared.IoC.IoCManager.Resolve``1"/>
            <see cref="M:Robust.Shared.IoC.IoCManager.BuildGraph"/> MUST be called after this method to make the new interface available.
            </summary>
            <typeparam name="TInterface">The type that will be resolvable.</typeparam>
            <typeparam name="TImplementation">The type that will be constructed as implementation.</typeparam>
            <param name="factory">A factory method to construct the instance of the implementation.</param>
            <param name="overwrite">
            If true, do not throw an <see cref="T:System.InvalidOperationException"/> if an interface is already registered,
            replace the current implementation instead.
            </param>
            <exception cref="T:System.InvalidOperationException">
            Thrown if <paramref name="overwrite"/> is false and <typeparamref name="TInterface"/> has been registered before,
            or if an already instantiated interface (by <see cref="M:Robust.Shared.IoC.IoCManager.BuildGraph"/>) is attempting to be overwritten.
            </exception>
        </member>
        <member name="M:Robust.Shared.IoC.IoCManager.RegisterInstance``1(System.Object,System.Boolean)">
            <summary>
                Registers an interface to an existing instance of an implementation,
                making it accessible to <see cref="M:Robust.Shared.IoC.IDependencyCollection.Resolve``1"/>.
                Unlike <see cref="M:Robust.Shared.IoC.IDependencyCollection.Register``2(System.Boolean)"/>,
                <see cref="M:Robust.Shared.IoC.IDependencyCollection.BuildGraph"/> does not need to be called after registering an instance
                if deferredInject is false.
            </summary>
            <typeparam name="TInterface">The type that will be resolvable.</typeparam>
            <param name="implementation">The existing instance to use as the implementation.</param>
            <param name="overwrite">
                If true, do not throw an <see cref="T:System.InvalidOperationException"/> if an interface is already registered,
                replace the current implementation instead.
            </param>
        </member>
        <member name="M:Robust.Shared.IoC.IoCManager.Clear">
            <summary>
            Clear all services and types.
            Use this between unit tests and on program shutdown.
            If a service implements <see cref="T:System.IDisposable"/>, <see cref="M:System.IDisposable.Dispose"/> will be called on it.
            </summary>
        </member>
        <member name="M:Robust.Shared.IoC.IoCManager.Resolve``1">
            <summary>
            Resolve a dependency manually.
            </summary>
            <exception cref="T:Robust.Shared.IoC.Exceptions.UnregisteredTypeException">Thrown if the interface is not registered.</exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown if the resolved type hasn't been created yet
            because the object graph still needs to be constructed for it.
            </exception>
        </member>
        <member name="M:Robust.Shared.IoC.IoCManager.Resolve``1(``0@)">
            <inheritdoc cref="M:Robust.Shared.IoC.IoCManager.Resolve``1"/>
        </member>
        <member name="M:Robust.Shared.IoC.IoCManager.Resolve``2(``0@,``1@)">
            <inheritdoc cref="!:Resolve&lt;T&gt;(ref T?)"/>
            <summary>
            Resolve two dependencies manually.
            </summary>
        </member>
        <member name="M:Robust.Shared.IoC.IoCManager.Resolve``3(``0@,``1@,``2@)">
            <inheritdoc cref="!:Resolve&lt;T1, T2&gt;(ref T1?, ref T2?)"/>
            <summary>
            Resolve three dependencies manually.
            </summary>
        </member>
        <member name="M:Robust.Shared.IoC.IoCManager.Resolve``4(``0@,``1@,``2@,``3@)">
            <inheritdoc cref="!:Resolve&lt;T1, T2, T3&gt;(ref T1?, ref T2?, ref T3?)"/>
            <summary>
            Resolve four dependencies manually.
            </summary>
        </member>
        <member name="M:Robust.Shared.IoC.IoCManager.ResolveType(System.Type)">
            <summary>
            Resolve a dependency manually.
            </summary>
            <exception cref="T:Robust.Shared.IoC.Exceptions.UnregisteredTypeException">Thrown if the interface is not registered.</exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown if the resolved type hasn't been created yet
            because the object graph still needs to be constructed for it.
            </exception>
        </member>
        <member name="M:Robust.Shared.IoC.IoCManager.BuildGraph">
            <summary>
            Initializes the object graph by building every object and resolving all dependencies.
            </summary>
            <seealso cref="M:Robust.Shared.IoC.IoCManager.InjectDependencies``1(``0)"/>
        </member>
        <member name="M:Robust.Shared.IoC.IoCManager.InjectDependencies``1(``0)">
            <summary>
                Injects dependencies into all fields with <see cref="T:Robust.Shared.IoC.DependencyAttribute"/> on the provided object.
                This is useful for objects that are not IoC created, and want to avoid tons of IoC.Resolve() calls.
            </summary>
            <remarks>
                This does NOT initialize IPostInjectInit objects!
            </remarks>
            <param name="obj">The object to inject into.</param>
            <exception cref="T:Robust.Shared.IoC.Exceptions.UnregisteredDependencyException">
                Thrown if a dependency field on the object is not registered.
            </exception>
            <seealso cref="M:Robust.Shared.IoC.IoCManager.BuildGraph"/>
        </member>
        <member name="T:Robust.Shared.IoC.IPostInjectInit">
            <summary>
            If implemented on a type instantiated by IoC,
            <see cref="M:Robust.Shared.IoC.IPostInjectInit.PostInject" /> will be called after all dependencies have been injected.
            Do not assume any order in the initialization of other managers,
            Or the availability of things through <see cref="M:Robust.Shared.IoC.IoCManager.Resolve``1" />
            </summary>
            <seealso cref="T:Robust.Shared.IoC.IoCManager" />
            <seealso cref="T:Robust.Shared.IoC.DependencyAttribute" />
        </member>
        <member name="M:Robust.Shared.IoC.IPostInjectInit.PostInject">
            <summary>
            Essentially functions as a constructor after dependencies have been injected.
            </summary>
        </member>
        <member name="T:Robust.Shared.Localization.EntityLocData">
            <summary>
                Contains based localized entity prototype data.
            </summary>
            <param name="Name">The localized name of the entity prototype.</param>
            <param name="Desc">The localized description of the entity prototype.</param>
            <param name="Suffix">Editor-visible suffix of this entity prototype.</param>
            <param name="Attributes">Any extra attributes that can be used for localization, such as gender, proper, ...</param>
        </member>
        <member name="M:Robust.Shared.Localization.EntityLocData.#ctor(System.String,System.String,System.String,System.Collections.Immutable.ImmutableDictionary{System.String,System.String})">
            <summary>
                Contains based localized entity prototype data.
            </summary>
            <param name="Name">The localized name of the entity prototype.</param>
            <param name="Desc">The localized description of the entity prototype.</param>
            <param name="Suffix">Editor-visible suffix of this entity prototype.</param>
            <param name="Attributes">Any extra attributes that can be used for localization, such as gender, proper, ...</param>
        </member>
        <member name="P:Robust.Shared.Localization.EntityLocData.Name">
            <summary>The localized name of the entity prototype.</summary>
        </member>
        <member name="P:Robust.Shared.Localization.EntityLocData.Desc">
            <summary>The localized description of the entity prototype.</summary>
        </member>
        <member name="P:Robust.Shared.Localization.EntityLocData.Suffix">
            <summary>Editor-visible suffix of this entity prototype.</summary>
        </member>
        <member name="P:Robust.Shared.Localization.EntityLocData.Attributes">
            <summary>Any extra attributes that can be used for localization, such as gender, proper, ...</summary>
        </member>
        <member name="T:Robust.Shared.Localization.ILocalizationManager">
            <summary>
                Provides facilities to obtain language appropriate in-game text.
            </summary>
            <remarks>
                <para>
                Translation is handled using Project Fluent (https://www.projectfluent.org/)
                You pass a Fluent 'identifier' as a string and the localization manager will fetch the message
                matching that identifier from the currently loaded language's Fluent files.
                </para>
            </remarks>
            <seealso cref="T:Robust.Shared.Localization.Loc"/>
        </member>
        <member name="M:Robust.Shared.Localization.ILocalizationManager.GetString(System.String)">
            <summary>
                Gets a language appropriate string represented by the supplied messageId.
            </summary>
            <param name="messageId">Unique Identifier for a translated message.</param>
            <returns>
                The language appropriate message if available, otherwise the messageId is returned.
            </returns>
        </member>
        <member name="M:Robust.Shared.Localization.ILocalizationManager.HasString(System.String)">
            <summary>
                Checks if the specified id has been registered, without checking its arguments.
            </summary>
            <param name="messageId">Unique Identifier for a translated message.</param>
            <returns>true if it exists, even if it requires any parameters to be passed.</returns>
        </member>
        <member name="M:Robust.Shared.Localization.ILocalizationManager.TryGetString(System.String,System.String@)">
            <summary>
                Try- version of <see cref="M:Robust.Shared.Localization.ILocalizationManager.GetString(System.String)"/>
            </summary>
            <remarks>
                Does not log a warning if the message does not exist.
                Does however log errors if any occur while formatting.
            </remarks>
        </member>
        <member name="M:Robust.Shared.Localization.ILocalizationManager.GetString(System.String,System.ValueTuple{System.String,System.Object}[])">
            <summary>
                Version of <see cref="M:Robust.Shared.Localization.ILocalizationManager.GetString(System.String)"/> that supports arguments.
            </summary>
        </member>
        <member name="M:Robust.Shared.Localization.ILocalizationManager.GetString(System.String,System.ValueTuple{System.String,System.Object})">
            <summary>
                Version of <see cref="M:Robust.Shared.Localization.ILocalizationManager.GetString(System.String)"/> that supports arguments.
            </summary>
        </member>
        <member name="M:Robust.Shared.Localization.ILocalizationManager.GetString(System.String,System.ValueTuple{System.String,System.Object},System.ValueTuple{System.String,System.Object})">
            <summary>
                Version of <see cref="M:Robust.Shared.Localization.ILocalizationManager.GetString(System.String)"/> that supports arguments.
            </summary>
        </member>
        <member name="M:Robust.Shared.Localization.ILocalizationManager.TryGetString(System.String,System.String@,System.ValueTuple{System.String,System.Object})">
            <summary>
                Try- version of <see cref="!:GetString(string, (string, object)[])"/>
            </summary>
            <remarks>
                Does not log a warning if the message does not exist.
                Does however log errors if any occur while formatting.
            </remarks>
        </member>
        <member name="M:Robust.Shared.Localization.ILocalizationManager.TryGetString(System.String,System.String@,System.ValueTuple{System.String,System.Object},System.ValueTuple{System.String,System.Object})">
            <summary>
                Try- version of <see cref="!:GetString(string, (string, object)[])"/>
            </summary>
            <remarks>
                Does not log a warning if the message does not exist.
                Does however log errors if any occur while formatting.
            </remarks>
        </member>
        <member name="M:Robust.Shared.Localization.ILocalizationManager.TryGetString(System.String,System.String@,System.ValueTuple{System.String,System.Object}[])">
            <summary>
                Try- version of <see cref="!:GetString(string, (string, object)[])"/>
            </summary>
            <remarks>
                Does not log a warning if the message does not exist.
                Does however log errors if any occur while formatting.
            </remarks>
        </member>
        <member name="P:Robust.Shared.Localization.ILocalizationManager.DefaultCulture">
            <summary>
                Default culture used by other methods when no culture is explicitly specified.
                Changing this also changes the current thread's culture.
            </summary>
        </member>
        <member name="M:Robust.Shared.Localization.ILocalizationManager.LoadCulture(System.Globalization.CultureInfo)">
            <summary>
                Load data for a culture.
            </summary>
            <param name="culture"></param>
        </member>
        <member name="M:Robust.Shared.Localization.ILocalizationManager.SetFallbackCluture(System.Globalization.CultureInfo[])">
            <summary>
                Sets culture to be used in the absence of the main one.
            </summary>
        </member>
        <member name="M:Robust.Shared.Localization.ILocalizationManager.ReloadLocalizations">
            <summary>
                Immediately reload ALL localizations from resources.
            </summary>
        </member>
        <member name="M:Robust.Shared.Localization.ILocalizationManager.AddFunction(System.Globalization.CultureInfo,System.String,Robust.Shared.Localization.LocFunction)">
            <summary>
                Add a function that can be called from Fluent localizations.
            </summary>
            <param name="culture">The culture to add the function instance for.</param>
            <param name="name">The name of the function.</param>
            <param name="function">The function itself.</param>
        </member>
        <member name="M:Robust.Shared.Localization.ILocalizationManager.GetEntityData(System.String)">
            <summary>
                Gets localization data for an entity prototype.
            </summary>
        </member>
        <member name="T:Robust.Shared.Localization.Loc">
            <summary>
            Static convenience wrapper for the <see cref="T:Robust.Shared.Localization.ILocalizationManager"/>.
            </summary>
            <remarks>
            <para>
            Mirrors the API of <see cref="T:Robust.Shared.Localization.ILocalizationManager"/>, but statically.
            This makes it more convenient to use.
            </para>
            <para>
            This API follows the same thread locality requirements as <see cref="T:Robust.Shared.IoC.IoCManager"/>
            </para>
            </remarks>
        </member>
        <member name="M:Robust.Shared.Localization.Loc.GetString(System.String)">
            <summary>
                Gets a language appropriate string represented by the supplied messageId.
            </summary>
            <param name="messageId">Unique Identifier for a translated message.</param>
            <returns>
                The language appropriate message if available, otherwise the messageId is returned.
            </returns>
        </member>
        <member name="M:Robust.Shared.Localization.Loc.GetString(System.String,System.ValueTuple{System.String,System.Object}[])">
            <summary>
                Version of <see cref="M:Robust.Shared.Localization.Loc.GetString(System.String)"/> that supports arguments.
            </summary>
        </member>
        <member name="M:Robust.Shared.Localization.LocalizationManager.FuncThe(Robust.Shared.Localization.LocArgs)">
            <summary>
            Returns the name of the entity passed in, prepended with "the" if it is not a proper noun.
            </summary>
        </member>
        <member name="M:Robust.Shared.Localization.LocalizationManager.FuncCapitalize(Robust.Shared.Localization.LocArgs)">
            <summary>
            Returns the string passed in, with the first letter capitalized.
            </summary>
        </member>
        <member name="M:Robust.Shared.Localization.LocalizationManager.FuncGender(Robust.Shared.Localization.LocArgs)">
            <summary>
            Returns the gender of the entity passed in; either Male, Female, Neuter or Epicene.
            </summary>
        </member>
        <member name="M:Robust.Shared.Localization.LocalizationManager.FuncSubject(Robust.Shared.Localization.LocArgs)">
            <summary>
            Returns the respective subject pronoun (he, she, they, it) for the entity's gender.
            </summary>
        </member>
        <member name="M:Robust.Shared.Localization.LocalizationManager.FuncObject(Robust.Shared.Localization.LocArgs)">
            <summary>
            Returns the respective object pronoun (him, her, them, it) for the entity's gender.
            </summary>
        </member>
        <member name="M:Robust.Shared.Localization.LocalizationManager.FuncPossAdj(Robust.Shared.Localization.LocArgs)">
            <summary>
            Returns the respective possessive adjective (his, her, their, its) for the entity's gender.
            </summary>
        </member>
        <member name="M:Robust.Shared.Localization.LocalizationManager.FuncPossPronoun(Robust.Shared.Localization.LocArgs)">
            <summary>
            Returns the respective possessive pronoun (his, hers, theirs, its) for the entity's gender.
            </summary>
        </member>
        <member name="M:Robust.Shared.Localization.LocalizationManager.FuncReflexive(Robust.Shared.Localization.LocArgs)">
            <summary>
            Returns the respective reflexive pronoun (himself, herself, themselves, itself) for the entity's gender.
            </summary>
        </member>
        <member name="M:Robust.Shared.Localization.LocalizationManager.FuncCounter(Robust.Shared.Localization.LocArgs)">
            <summary>
            Returns the counter or measure word for the entity. Not used in English, common in East Asian languages.
            </summary>
        </member>
        <member name="M:Robust.Shared.Localization.LocalizationManager.FuncConjugateBe(Robust.Shared.Localization.LocArgs)">
            <summary>
            Returns the respective conjugated form of "to be" (is for male/female/neuter, are for epicene) for the entity's gender.
            </summary>
        </member>
        <member name="M:Robust.Shared.Localization.LocalizationManager.FuncConjugateHave(Robust.Shared.Localization.LocArgs)">
            <summary>
            Returns the respective conjugated form of "to have" (has for male/female/neuter, have for epicene) for the entity's gender.
            </summary>
        </member>
        <member name="M:Robust.Shared.Localization.LocalizationManager.FuncConjugateBasic(Robust.Shared.Localization.LocArgs)">
            <summary>
            Returns the basic conjugated form of a verb. The first string argument is the base verb, the second string argument is the form
            for he/she/it.
            e.g. run -> he runs/she runs/they run/it runs
            </summary>
        </member>
        <member name="M:Robust.Shared.Localization.LocalizationManager.FuncProper(Robust.Shared.Localization.LocArgs)">
            <summary>
            Returns whether the passed in entity's name is proper or not.
            </summary>
        </member>
        <member name="T:Robust.Shared.Localization.LocFunction">
            <summary>
                Function signature runnable by localizations.
            </summary>
            <param name="args">Contains arguments and options passed to the function by the calling localization.</param>
        </member>
        <member name="T:Robust.Shared.Localization.LocArgs">
            <summary>
                Arguments and options passed to a localization function.
            </summary>
        </member>
        <member name="P:Robust.Shared.Localization.LocArgs.Args">
            <summary>
                Positional arguments passed to the function, in order.
            </summary>
        </member>
        <member name="P:Robust.Shared.Localization.LocArgs.Options">
            <summary>
                Key-value options passed to the function.
            </summary>
        </member>
        <member name="T:Robust.Shared.Localization.ILocValue">
            <summary>
                A value passed around in the localization system.
            </summary>
            <seealso cref="T:Robust.Shared.Localization.LocValue`1"/>
        </member>
        <member name="M:Robust.Shared.Localization.ILocValue.Format(Robust.Shared.Localization.LocContext)">
            <summary>
                Format this value to a string.
            </summary>
            <remarks>
                Used when this value is interpolated directly in localizations.
            </remarks>
            <param name="ctx">Context containing data like culture used.</param>
            <returns>The formatted string.</returns>
        </member>
        <member name="P:Robust.Shared.Localization.ILocValue.Value">
            <summary>
                Boxed value stored by this instance.
            </summary>
        </member>
        <member name="T:Robust.Shared.Localization.LocValue`1">
            <summary>
                Default implementation of a localization value.
            </summary>
            <remarks>
                The idea is that inheritors could add extra data like formatting parameters
                and then use those by overriding <see cref="M:Robust.Shared.Localization.LocValue`1.Format(Robust.Shared.Localization.LocContext)"/>.
            </remarks>
            <typeparam name="T">The type of value stored.</typeparam>
        </member>
        <member name="P:Robust.Shared.Localization.LocValue`1.Value">
            <summary>
                The stored value.
            </summary>
        </member>
        <member name="T:Robust.Shared.Localization.LocValueNone">
            <summary>
                Stores an "invalid" string value. Produced by e.g. unresolved variable references.
            </summary>
        </member>
        <member name="M:Robust.Shared.Localization.LocValueNone.#ctor(System.String)">
            <summary>
                Stores an "invalid" string value. Produced by e.g. unresolved variable references.
            </summary>
        </member>
        <member name="T:Robust.Shared.Localization.LocError">
            <summary>
             Wrapper around Fluent Error, that adds path to the list of values.
             Work in progress, FluentErrors need to be modified to be more accessible.
            </summary>
        </member>
        <member name="M:Robust.Shared.Localization.LocError.#ctor(Robust.Shared.Utility.ResPath,Linguini.Bundle.Errors.FluentError)">
            <summary>
            Basic constructor.
            </summary>
            <param name="path">path of resource being added.</param>
            <param name="fluentError">FluentError encountered.</param>
        </member>
        <member name="T:Robust.Shared.Localization.LocId">
            <summary>
                Wrapper type for a localization string id.
            </summary>
            <param name="Id">The id of the localization string.</param>
            <remarks>
                This will be automatically validated by <see cref="T:Robust.Shared.Serialization.TypeSerializers.Implementations.LocIdSerializer"/> if used in data fields.</remarks>
            <seealso cref="M:Robust.Shared.Localization.Loc.GetString(System.String)"/>
        </member>
        <member name="M:Robust.Shared.Localization.LocId.#ctor(System.String)">
            <summary>
                Wrapper type for a localization string id.
            </summary>
            <param name="Id">The id of the localization string.</param>
            <remarks>
                This will be automatically validated by <see cref="T:Robust.Shared.Serialization.TypeSerializers.Implementations.LocIdSerializer"/> if used in data fields.</remarks>
            <seealso cref="M:Robust.Shared.Localization.Loc.GetString(System.String)"/>
        </member>
        <member name="P:Robust.Shared.Localization.LocId.Id">
            <summary>The id of the localization string.</summary>
        </member>
        <member name="T:Robust.Shared.Log.ConsoleLogHandler">
            <summary>
                Log handler that prints to console.
            </summary>
        </member>
        <member name="T:Robust.Shared.Log.ILogHandler">
            <summary>
                Formats and prints a log message to an output source.
            </summary>
        </member>
        <member name="M:Robust.Shared.Log.ILogHandler.Log(System.String,Serilog.Events.LogEvent)">
            <summary>
                Logs a message to.. somewhere.
                You choose that somewhere.
            </summary>
            <remarks>
                This method can be called from multiple threads so make sure it's thread safe!
            </remarks>
            <param name="sawmillName">The name of the sawmill that this message was raised on.</param>
            <param name="message">The message to log.</param>
        </member>
        <member name="T:Robust.Shared.Log.ILogManager">
            <summary>
                Manages logging sawmills.
            </summary>
            <seealso cref="T:Robust.Shared.Log.ISawmill"/>
        </member>
        <member name="P:Robust.Shared.Log.ILogManager.RootSawmill">
            <summary>
                The "root" sawmill every other sawmill is parented to.
            </summary>
        </member>
        <member name="M:Robust.Shared.Log.ILogManager.GetSawmill(System.String)">
            <summary>
                Gets the sawmill with the specified name. Creates a new one if necessary.
            </summary>
        </member>
        <member name="P:Robust.Shared.Log.ILogManager.AllSawmills">
            <summary>
            Gets a list of all currently created sawmills.
            </summary>
        </member>
        <member name="T:Robust.Shared.Log.ISawmill">
            <summary>
                A sawmill is an object-oriented logging "category".
            </summary>
            <seealso cref="T:Robust.Shared.Log.ILogManager"/>
        </member>
        <member name="P:Robust.Shared.Log.ISawmill.Name">
            <summary>
                The name of this sawmill. This determines its parent(s) and is printed with logs.
            </summary>
        </member>
        <member name="P:Robust.Shared.Log.ISawmill.Level">
            <summary>
                The level of messages to allow through. If null, the value from the parent is used.
                If a value, a message's level must be greater or equal to the level to pass.
            </summary>
        </member>
        <member name="M:Robust.Shared.Log.ISawmill.AddHandler(Robust.Shared.Log.ILogHandler)">
            <summary>
                Adds a handler to handle incoming messages.
            </summary>
            <param name="handler">The handler to add.</param>
        </member>
        <member name="M:Robust.Shared.Log.ISawmill.RemoveHandler(Robust.Shared.Log.ILogHandler)">
            <summary>
                Adds a handler from handling incoming messages.
            </summary>
            <param name="handler">The haandler to remove.</param>
        </member>
        <member name="M:Robust.Shared.Log.ISawmill.Log(Robust.Shared.Log.LogLevel,System.String,System.Object[])">
            <summary>
                Log a message, taking in a format string and format list using the regular <see cref="!:Format" /> syntax.
            </summary>
        </member>
        <member name="M:Robust.Shared.Log.ISawmill.Log(Robust.Shared.Log.LogLevel,System.String)">
            <summary>
                Log a message.
            </summary>
        </member>
        <member name="M:Robust.Shared.Log.ISawmill.Verbose(System.String,System.Object[])">
            <summary>
                Log a message as <see cref="F:Robust.Shared.Log.LogLevel.Verbose"/>, taking in a format string and format list using the regular <see cref="!:Format" /> syntax.
            </summary>
            <seealso cref="T:Serilog.Log" />
        </member>
        <member name="M:Robust.Shared.Log.ISawmill.Verbose(System.String)">
            <summary>
                Log a message as <see cref="F:Robust.Shared.Log.LogLevel.Verbose"/>.
            </summary>
            <seealso cref="T:Serilog.Log" />
        </member>
        <member name="M:Robust.Shared.Log.ISawmill.Debug(System.String,System.Object[])">
            <summary>
                Log a message as debug, taking in a format string and format list using the regular <see cref="!:Format" /> syntax.
            </summary>
            <seealso cref="T:Serilog.Log" />
        </member>
        <member name="M:Robust.Shared.Log.ISawmill.Debug(System.String)">
            <summary>
                Log a message as debug.
            </summary>
            <seealso cref="T:Serilog.Log" />
        </member>
        <member name="M:Robust.Shared.Log.ISawmill.Info(System.String,System.Object[])">
            <summary>
                Log a message as info, taking in a format string and format list using the regular <see cref="!:Format" /> syntax.
            </summary>
            <seealso cref="T:Serilog.Log" />
        </member>
        <member name="M:Robust.Shared.Log.ISawmill.Info(System.String)">
            <summary>
                Log a message as info.
            </summary>
            <seealso cref="T:Serilog.Log" />
        </member>
        <member name="M:Robust.Shared.Log.ISawmill.Warning(System.String,System.Object[])">
            <summary>
                Log a message as warning, taking in a format string and format list using the regular <see cref="!:Format" /> syntax.
            </summary>
            <seealso cref="T:Serilog.Log" />
        </member>
        <member name="M:Robust.Shared.Log.ISawmill.Warning(System.String)">
            <summary>
                Log a message as warning, taking in a format string and format list using the regular <see cref="!:Format" /> syntax.
            </summary>
            <seealso cref="T:Serilog.Log" />
        </member>
        <member name="M:Robust.Shared.Log.ISawmill.Error(System.String,System.Object[])">
            <summary>
                Log a message as error, taking in a format string and format list using the regular <see cref="!:Format" /> syntax.
            </summary>
            <seealso cref="T:Serilog.Log" />
        </member>
        <member name="M:Robust.Shared.Log.ISawmill.Error(System.String)">
            <summary>
                Log a message as error.
            </summary>
            <seealso cref="T:Serilog.Log" />
        </member>
        <member name="M:Robust.Shared.Log.ISawmill.Fatal(System.String,System.Object[])">
            <summary>
                Log a message as fatal, taking in a format string and format list using the regular <see cref="!:Format" /> syntax.
            </summary>
            <seealso cref="T:Serilog.Log" />
        </member>
        <member name="M:Robust.Shared.Log.ISawmill.Fatal(System.String)">
            <summary>
                Log a message as fatal.
            </summary>
            <seealso cref="T:Serilog.Log" />
        </member>
        <member name="T:Robust.Shared.Log.Logger">
            <summary>
                Static logging API front end.
                This is here as a convenience to prevent the need to resolve the manager manually.
            </summary>
            <remarks>
                This type is simply a proxy to an IoC based <see cref="T:Robust.Shared.Log.ILogManager"/> and its sawmills.
                As such, no methods or properties will work if IoC has not been initialized yet.
            </remarks>
            <seealso cref="T:Robust.Shared.Log.ILogManager"/>
            <seealso cref="T:Robust.Shared.Log.ISawmill"/>
        </member>
        <member name="P:Robust.Shared.Log.Logger.LogManagerSingleton">
            <summary>
                The instance we're using.
                As it's a direct proxy to IoC this will not work if IoC is not functional.
            </summary>
        </member>
        <member name="M:Robust.Shared.Log.Logger.GetSawmill(System.String)">
            <summary>
                Gets a sawmill by name. Equivalent to <see cref="M:Robust.Shared.Log.ILogManager.GetSawmill(System.String)"/>.
            </summary>
            <param name="name">The name of the sawmill to get.</param>
            <returns>The sawmill with specified name. Creates a new one if it does not exist.</returns>
        </member>
        <member name="M:Robust.Shared.Log.Logger.LogS(Robust.Shared.Log.LogLevel,System.String,System.String,System.Object[])">
            <summary>
                Log a message, taking in a format string and format list using the regular <see cref="!:Format" /> syntax.
            </summary>
        </member>
        <member name="M:Robust.Shared.Log.Logger.LogS(Robust.Shared.Log.LogLevel,System.String,System.Exception,System.String,System.Object[])">
            <summary>
                Log a message, taking in a format string and format list using the regular <see cref="!:Format" /> syntax.
            </summary>
        </member>
        <member name="M:Robust.Shared.Log.Logger.LogS(Robust.Shared.Log.LogLevel,System.String,System.String)">
            <summary>
                Log a message.
            </summary>
        </member>
        <member name="M:Robust.Shared.Log.Logger.Log(Robust.Shared.Log.LogLevel,System.String,System.Object[])">
            <summary>
            Log a message, taking in a format string and format list using the regular <see cref="!:Format" /> syntax.
            </summary>
        </member>
        <member name="M:Robust.Shared.Log.Logger.Log(Robust.Shared.Log.LogLevel,System.String)">
            <summary>
            Log a message.
            </summary>
        </member>
        <member name="M:Robust.Shared.Log.Logger.DebugS(System.String,System.String,System.Object[])">
            <summary>
            Log a message as debug, taking in a format string and format list using the regular <see cref="!:Format" /> syntax.
            </summary>
            <seealso cref="M:Robust.Shared.Log.Logger.Log(Robust.Shared.Log.LogLevel,System.String,System.Object[])" />
        </member>
        <member name="M:Robust.Shared.Log.Logger.DebugS(System.String,System.String)">
            <summary>
            Log a message as debug.
            </summary>
            <seealso cref="M:Robust.Shared.Log.Logger.Log(Robust.Shared.Log.LogLevel,System.String,System.Object[])" />
        </member>
        <member name="M:Robust.Shared.Log.Logger.Debug(System.String,System.Object[])">
            <summary>
            Log a message as debug, taking in a format string and format list using the regular <see cref="!:Format" /> syntax.
            </summary>
            <seealso cref="M:Robust.Shared.Log.Logger.Log(Robust.Shared.Log.LogLevel,System.String,System.Object[])" />
        </member>
        <member name="M:Robust.Shared.Log.Logger.Debug(System.String)">
            <summary>
            Log a message as debug.
            </summary>
            <seealso cref="M:Robust.Shared.Log.Logger.Log(Robust.Shared.Log.LogLevel,System.String,System.Object[])" />
        </member>
        <member name="M:Robust.Shared.Log.Logger.InfoS(System.String,System.String,System.Object[])">
            <summary>
            Log a message as info, taking in a format string and format list using the regular <see cref="!:Format" /> syntax.
            </summary>
            <seealso cref="M:Robust.Shared.Log.Logger.Log(Robust.Shared.Log.LogLevel,System.String,System.Object[])" />
        </member>
        <member name="M:Robust.Shared.Log.Logger.InfoS(System.String,System.String)">
            <summary>
            Log a message as info.
            </summary>
            <seealso cref="M:Robust.Shared.Log.Logger.Log(Robust.Shared.Log.LogLevel,System.String,System.Object[])" />
        </member>
        <member name="M:Robust.Shared.Log.Logger.Info(System.String,System.Object[])">
            <summary>
            Log a message as info, taking in a format string and format list using the regular <see cref="!:Format" /> syntax.
            </summary>
            <seealso cref="M:Robust.Shared.Log.Logger.Log(Robust.Shared.Log.LogLevel,System.String,System.Object[])" />
        </member>
        <member name="M:Robust.Shared.Log.Logger.Info(System.String)">
            <summary>
            Log a message as info.
            </summary>
            <seealso cref="M:Robust.Shared.Log.Logger.Log(Robust.Shared.Log.LogLevel,System.String,System.Object[])" />
        </member>
        <member name="M:Robust.Shared.Log.Logger.WarningS(System.String,System.String,System.Object[])">
            <summary>
            Log a message as warning, taking in a format string and format list using the regular <see cref="!:Format" /> syntax.
            </summary>
            <seealso cref="M:Robust.Shared.Log.Logger.Log(Robust.Shared.Log.LogLevel,System.String,System.Object[])" />
        </member>
        <member name="M:Robust.Shared.Log.Logger.WarningS(System.String,System.String)">
            <summary>
            Log a message as warning.
            </summary>
            <seealso cref="M:Robust.Shared.Log.Logger.Log(Robust.Shared.Log.LogLevel,System.String,System.Object[])" />
        </member>
        <member name="M:Robust.Shared.Log.Logger.Warning(System.String,System.Object[])">
            <summary>
            Log a message as warning, taking in a format string and format list using the regular <see cref="!:Format" /> syntax.
            </summary>
            <seealso cref="M:Robust.Shared.Log.Logger.Log(Robust.Shared.Log.LogLevel,System.String,System.Object[])" />
        </member>
        <member name="M:Robust.Shared.Log.Logger.Warning(System.String)">
            <summary>
            Log a message as warning.
            </summary>
            <seealso cref="M:Robust.Shared.Log.Logger.Log(Robust.Shared.Log.LogLevel,System.String,System.Object[])" />
        </member>
        <member name="M:Robust.Shared.Log.Logger.ErrorS(System.String,System.String,System.Object[])">
            <summary>
            Log a message as error, taking in a format string and format list using the regular <see cref="!:Format" /> syntax.
            </summary>
            <seealso cref="M:Robust.Shared.Log.Logger.Log(Robust.Shared.Log.LogLevel,System.String,System.Object[])" />
        </member>
        <member name="M:Robust.Shared.Log.Logger.ErrorS(System.String,System.Exception,System.String,System.Object[])">
            <summary>
            Log a message as error, taking in a format string and format list using the regular <see cref="!:Format" /> syntax.
            </summary>
            <seealso cref="M:Robust.Shared.Log.Logger.Log(Robust.Shared.Log.LogLevel,System.String,System.Object[])" />
        </member>
        <member name="M:Robust.Shared.Log.Logger.ErrorS(System.String,System.String)">
            <summary>
            Log a message as error.
            </summary>
            <seealso cref="M:Robust.Shared.Log.Logger.Log(Robust.Shared.Log.LogLevel,System.String,System.Object[])" />
        </member>
        <member name="M:Robust.Shared.Log.Logger.Error(System.String,System.Object[])">
            <summary>
            Log a message as error, taking in a format string and format list using the regular <see cref="!:Format" /> syntax.
            </summary>
            <seealso cref="M:Robust.Shared.Log.Logger.Log(Robust.Shared.Log.LogLevel,System.String,System.Object[])" />
        </member>
        <member name="M:Robust.Shared.Log.Logger.Error(System.String)">
            <summary>
            Log a message as error.
            </summary>
            <seealso cref="M:Robust.Shared.Log.Logger.Log(Robust.Shared.Log.LogLevel,System.String,System.Object[])" />
        </member>
        <member name="M:Robust.Shared.Log.Logger.FatalS(System.String,System.String,System.Object[])">
            <summary>
            Log a message as fatal, taking in a format string and format list using the regular <see cref="!:Format" /> syntax.
            </summary>
            <seealso cref="M:Robust.Shared.Log.Logger.Log(Robust.Shared.Log.LogLevel,System.String,System.Object[])" />
        </member>
        <member name="M:Robust.Shared.Log.Logger.FatalS(System.String,System.String)">
            <summary>
            Log a message as fatal.
            </summary>
            <seealso cref="M:Robust.Shared.Log.Logger.Log(Robust.Shared.Log.LogLevel,System.String,System.Object[])" />
        </member>
        <member name="M:Robust.Shared.Log.Logger.Fatal(System.String,System.Object[])">
            <summary>
            Log a message as fatal, taking in a format string and format list using the regular <see cref="!:Format" /> syntax.
            </summary>
            <seealso cref="M:Robust.Shared.Log.Logger.Log(Robust.Shared.Log.LogLevel,System.String,System.Object[])" />
        </member>
        <member name="M:Robust.Shared.Log.Logger.Fatal(System.String)">
            <summary>
            Log a message as fatal.
            </summary>
            <seealso cref="M:Robust.Shared.Log.Logger.Log(Robust.Shared.Log.LogLevel,System.String,System.Object[])" />
        </member>
        <member name="T:Robust.Shared.Log.LogLevel">
            <remarks>
                The value associated with the level determines the order in which they are filtered,
                Under the default <see cref="T:Robust.Shared.Log.LogManager"/>.
            </remarks>
        </member>
        <member name="F:Robust.Shared.Log.LogLevel.Verbose">
            <summary>
                When you're *really* trying to track down that bug.
            </summary>
        </member>
        <member name="F:Robust.Shared.Log.LogLevel.Debug">
            <summary>
                Diagnostic information usually only necessary when something broke.
            </summary>
        </member>
        <member name="F:Robust.Shared.Log.LogLevel.Info">
            <summary>
                General info that can confirm that something is working.
            </summary>
        </member>
        <member name="F:Robust.Shared.Log.LogLevel.Warning">
            <summary>
                Issues that can easily be worked around but should still be fixed.
            </summary>
        </member>
        <member name="F:Robust.Shared.Log.LogLevel.Error">
            <summary>
                Errors that need fixing and are probably gonna break something.
            </summary>
        </member>
        <member name="F:Robust.Shared.Log.LogLevel.Fatal">
            <summary>
                Errors that are REALLY BAD and break EVERYTHING.
            </summary>
        </member>
        <member name="T:Robust.Shared.Map.Commands.AmbientLightCommand">
            <summary>
            Sets the ambient light for a particular map
            </summary>
        </member>
        <member name="M:Robust.Shared.Map.Components.GridTreeComponent.InternalCopy(Robust.Shared.Map.Components.GridTreeComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Map.Components.GridTreeComponent.Copy(Robust.Shared.Map.Components.GridTreeComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Map.Components.GridTreeComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Map.Components.GridTreeComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Map.Components.GridTreeComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Map.Components.GridTreeComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Map.Components.GridTreeComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Map.Components.MapComponent.InternalCopy(Robust.Shared.Map.Components.MapComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Map.Components.MapComponent.Copy(Robust.Shared.Map.Components.MapComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Map.Components.MapComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Map.Components.MapComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Map.Components.MapComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Map.Components.MapComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Map.Components.MapComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Shared.Map.Components.MapComponentState">
            <summary>
                Serialized state of a <see cref="T:Robust.Shared.Map.Components.MapGridComponentState"/>.
            </summary>
        </member>
        <member name="M:Robust.Shared.Map.Components.MapComponentState.#ctor(Robust.Shared.Map.MapId,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
                Serialized state of a <see cref="T:Robust.Shared.Map.Components.MapGridComponentState"/>.
            </summary>
        </member>
        <member name="P:Robust.Shared.Map.Components.MapGridComponent.TileSize">
            <summary>
                The length of the side of a square tile in world units.
            </summary>
        </member>
        <member name="P:Robust.Shared.Map.Components.MapGridComponent.LastTileModifiedTick">
            <summary>
                Last game tick that the map was modified.
            </summary>
        </member>
        <member name="F:Robust.Shared.Map.Components.MapGridComponent.MapProxy">
            <summary>
            Map DynamicTree proxy to lookup for grid intersection.
            </summary>
        </member>
        <member name="F:Robust.Shared.Map.Components.MapGridComponent.Chunks">
            <summary>
                Grid chunks than make up this grid.
            </summary>
        </member>
        <member name="F:Robust.Shared.Map.Components.MapGridComponent.CanSplit">
            <summary>
            Set to enable or disable grid splitting.
            You must ensure you handle this properly and check for splits afterwards if relevant!
            </summary>
        </member>
        <member name="M:Robust.Shared.Map.Components.MapGridComponent.InternalCopy(Robust.Shared.Map.Components.MapGridComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Map.Components.MapGridComponent.Copy(Robust.Shared.Map.Components.MapGridComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Map.Components.MapGridComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Map.Components.MapGridComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Map.Components.MapGridComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Map.Components.MapGridComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Map.Components.MapGridComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Shared.Map.Components.MapGridComponentState">
            <summary>
                Serialized state of a <see cref="T:Robust.Shared.Map.Components.MapGridComponentState"/>.
            </summary>
        </member>
        <member name="M:Robust.Shared.Map.Components.MapGridComponentState.#ctor(System.UInt16,System.Collections.Generic.Dictionary{Robust.Shared.Maths.Vector2i,Robust.Shared.Map.Tile[]},Robust.Shared.Timing.GameTick)">
            <summary>
                Serialized state of a <see cref="T:Robust.Shared.Map.Components.MapGridComponentState"/>.
            </summary>
        </member>
        <member name="F:Robust.Shared.Map.Components.MapGridComponentState.ChunkSize">
            <summary>
                The size of the chunks in the map grid.
            </summary>
        </member>
        <member name="F:Robust.Shared.Map.Components.MapGridComponentState.FullGridData">
            <summary>
            Networked chunk data containing the full grid state.
            </summary>
        </member>
        <member name="F:Robust.Shared.Map.Components.MapGridComponentState.LastTileModifiedTick">
            <summary>
            Last game tick that the tile on the grid was modified.
            </summary>
        </member>
        <member name="T:Robust.Shared.Map.Components.MapGridComponentDeltaState">
            <summary>
                Serialized state of a <see cref="T:Robust.Shared.Map.Components.MapGridComponentState"/>.
            </summary>
        </member>
        <member name="M:Robust.Shared.Map.Components.MapGridComponentDeltaState.#ctor(System.UInt16,System.Collections.Generic.List{Robust.Shared.GameStates.ChunkDatum},Robust.Shared.Timing.GameTick)">
            <summary>
                Serialized state of a <see cref="T:Robust.Shared.Map.Components.MapGridComponentState"/>.
            </summary>
        </member>
        <member name="F:Robust.Shared.Map.Components.MapGridComponentDeltaState.ChunkSize">
            <summary>
                The size of the chunks in the map grid.
            </summary>
        </member>
        <member name="F:Robust.Shared.Map.Components.MapGridComponentDeltaState.ChunkData">
            <summary>
            Networked chunk data.
            </summary>
        </member>
        <member name="F:Robust.Shared.Map.Components.MapGridComponentDeltaState.LastTileModifiedTick">
            <summary>
            Last game tick that the tile on the grid was modified.
            </summary>
        </member>
        <member name="T:Robust.Shared.Map.Components.MapLightComponent">
            <summary>
            Controls per-map lighting values.
            </summary>
        </member>
        <member name="P:Robust.Shared.Map.Components.MapLightComponent.AmbientLightColor">
            <summary>
            Ambient light. This is in linear-light, i.e. when providing a fixed colour, you must use Color.FromSrgb(Color.Black)!
            </summary>
        </member>
        <member name="M:Robust.Shared.Map.Components.MapLightComponent.InternalCopy(Robust.Shared.Map.Components.MapLightComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Map.Components.MapLightComponent.Copy(Robust.Shared.Map.Components.MapLightComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Map.Components.MapLightComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Map.Components.MapLightComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Map.Components.MapLightComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Map.Components.MapLightComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Map.Components.MapLightComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Shared.Map.Components.MovedGridsComponent">
            <summary>
            Stores what grids moved in a tick.
            </summary>
        </member>
        <member name="M:Robust.Shared.Map.Components.MovedGridsComponent.InternalCopy(Robust.Shared.Map.Components.MovedGridsComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Map.Components.MovedGridsComponent.Copy(Robust.Shared.Map.Components.MovedGridsComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Map.Components.MovedGridsComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Map.Components.MovedGridsComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Map.Components.MovedGridsComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Map.Components.MovedGridsComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Map.Components.MovedGridsComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Shared.Map.EntityCoordinates">
            <summary>
                A set of coordinates relative to another entity.
            </summary>
        </member>
        <member name="F:Robust.Shared.Map.EntityCoordinates.EntityId">
            <summary>
                ID of the entity that this position is relative to.
            </summary>
        </member>
        <member name="F:Robust.Shared.Map.EntityCoordinates.Position">
            <summary>
                Position in the entity's local space.
            </summary>
        </member>
        <member name="P:Robust.Shared.Map.EntityCoordinates.X">
            <summary>
                Location of the X axis local to the entity.
            </summary>
        </member>
        <member name="P:Robust.Shared.Map.EntityCoordinates.Y">
            <summary>
                Location of the Y axis local to the entity.
            </summary>
        </member>
        <member name="M:Robust.Shared.Map.EntityCoordinates.#ctor(Robust.Shared.GameObjects.EntityUid,System.Numerics.Vector2)">
            <summary>
                Constructs a new instance of <see cref="T:Robust.Shared.Map.EntityCoordinates"/>.
            </summary>
            <param name="entityId">ID of the entity that this position is relative to.</param>
            <param name="position">Position in the entity's local space.</param>
        </member>
        <member name="M:Robust.Shared.Map.EntityCoordinates.IsValid(Robust.Shared.GameObjects.IEntityManager)">
            <summary>
                Verifies that this set of coordinates can be currently resolved to a location.
            </summary>
            <param name="entityManager">Entity Manager containing the entity Id.</param>
            <returns><see langword="true" /> if this set of coordinates can be currently resolved to a location, otherwise <see langword="false" />.</returns>
        </member>
        <member name="M:Robust.Shared.Map.EntityCoordinates.ToVector2i(Robust.Shared.GameObjects.IEntityManager,Robust.Shared.Map.IMapManager,Robust.Shared.GameObjects.SharedTransformSystem)">
            <summary>
                Converts this set of coordinates to Vector2i.
            </summary>
        </member>
        <member name="M:Robust.Shared.Map.EntityCoordinates.WithPosition(System.Numerics.Vector2)">
            <summary>
                Returns an new set of EntityCoordinates with the same <see cref="F:Robust.Shared.Map.EntityCoordinates.EntityId"/>
                but on a different position.
            </summary>
            <param name="newPosition">The position the new EntityCoordinates will be in</param>
            <returns>A new set of EntityCoordinates with the specified position and same <see cref="F:Robust.Shared.Map.EntityCoordinates.EntityId"/> as this one.</returns>
        </member>
        <member name="M:Robust.Shared.Map.EntityCoordinates.WithEntityId(Robust.Shared.GameObjects.IEntityManager,Robust.Shared.GameObjects.EntityUid)">
            <summary>
                Returns a new set of EntityCoordinates local to a new entity.
            </summary>
            <param name="entityManager">The Entity Manager holding this entity</param>
            <param name="entityId">The entity that the new coordinates will be local to</param>
            <returns>A new set of EntityCoordinates local to a new entity.</returns>
        </member>
        <member name="M:Robust.Shared.Map.EntityCoordinates.WithEntityId(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.IEntityManager)">
            <summary>
                Returns a new set of EntityCoordinates local to a new entity.
            </summary>
            <param name="entity">The entity that the new coordinates will be local to</param>
            <returns>A new set of EntityCoordinates local to a new entity.</returns>
        </member>
        <member name="M:Robust.Shared.Map.EntityCoordinates.WithEntityId(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.SharedTransformSystem,Robust.Shared.GameObjects.IEntityManager)">
            <summary>
                Returns a new set of EntityCoordinates local to a new entity.
            </summary>
            <param name="entity">The entity that the new coordinates will be local to</param>
            <returns>A new set of EntityCoordinates local to a new entity.</returns>
        </member>
        <member name="M:Robust.Shared.Map.EntityCoordinates.GetGridUid(Robust.Shared.GameObjects.IEntityManager)">
            <summary>
                Returns the Grid EntityUid these coordinates are on.
                If none of the ancestors are a grid, returns null instead.
            </summary>
            <param name="entityManager"></param>
            <returns>Grid EntityUid this entity is on or null</returns>
        </member>
        <member name="M:Robust.Shared.Map.EntityCoordinates.GetMapId(Robust.Shared.GameObjects.IEntityManager)">
            <summary>
                Returns the Map Id these coordinates are on.
                If the relative entity is not valid, returns <see cref="F:Robust.Shared.Map.MapId.Nullspace"/> instead.
            </summary>
            <param name="entityManager"></param>
            <returns>Map Id these coordinates are on or <see cref="F:Robust.Shared.Map.MapId.Nullspace"/></returns>
        </member>
        <member name="M:Robust.Shared.Map.EntityCoordinates.GetMapUid(Robust.Shared.GameObjects.IEntityManager)">
            <summary>
                Returns the Map Id these coordinates are on.
                If the relative entity is not valid, returns null instead.
            </summary>
            <param name="entityManager"></param>
            <returns>Map Id these coordinates are on or null</returns>
        </member>
        <member name="M:Robust.Shared.Map.EntityCoordinates.Offset(System.Numerics.Vector2)">
            <summary>
            Offsets the position by a given vector. This happens in local space.
            </summary>
            <param name="position">The vector to offset by local to the entity.</param>
            <returns>Newly offset coordinates.</returns>
        </member>
        <member name="M:Robust.Shared.Map.EntityCoordinates.InRange(Robust.Shared.GameObjects.IEntityManager,Robust.Shared.Map.EntityCoordinates,System.Single)">
            <summary>
                Compares two sets of coordinates to see if they are in range of each other.
            </summary>
            <param name="entityManager">Entity Manager containing the two entity Ids.</param>
            <param name="otherCoordinates">Other set of coordinates to use.</param>
            <param name="range">maximum distance between the two sets of coordinates.</param>
            <returns>True if the two points are within a given range.</returns>
        </member>
        <member name="M:Robust.Shared.Map.EntityCoordinates.TryDistance(Robust.Shared.GameObjects.IEntityManager,Robust.Shared.Map.EntityCoordinates,System.Single@)">
            <summary>
                Tries to calculate the distance between two sets of coordinates.
            </summary>
            <param name="entityManager"></param>
            <param name="otherCoordinates"></param>
            <param name="distance"></param>
            <returns>True if it was possible to calculate the distance</returns>
        </member>
        <member name="M:Robust.Shared.Map.EntityCoordinates.TryDistance(Robust.Shared.GameObjects.IEntityManager,Robust.Shared.GameObjects.SharedTransformSystem,Robust.Shared.Map.EntityCoordinates,System.Single@)">
            <summary>
                Tries to calculate the distance between two sets of coordinates.
            </summary>
            <returns>True if it was possible to calculate the distance</returns>
        </member>
        <member name="M:Robust.Shared.Map.EntityCoordinates.TryDelta(Robust.Shared.GameObjects.IEntityManager,Robust.Shared.GameObjects.SharedTransformSystem,Robust.Shared.Map.EntityCoordinates,System.Numerics.Vector2@)">
            <summary>
                Tries to calculate the distance vector between two sets of coordinates.
            </summary>
            <returns>True if it was possible to calculate the distance</returns>
        </member>
        <member name="M:Robust.Shared.Map.EntityCoordinates.Equals(Robust.Shared.Map.EntityCoordinates)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Map.EntityCoordinates.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Map.EntityCoordinates.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Map.EntityCoordinates.op_Equality(Robust.Shared.Map.EntityCoordinates,Robust.Shared.Map.EntityCoordinates)">
            <summary>
                Check for equality by value between two objects.
            </summary>
        </member>
        <member name="M:Robust.Shared.Map.EntityCoordinates.op_Inequality(Robust.Shared.Map.EntityCoordinates,Robust.Shared.Map.EntityCoordinates)">
            <summary>
                Check for inequality by value between two objects.
            </summary>
        </member>
        <member name="M:Robust.Shared.Map.EntityCoordinates.op_Addition(Robust.Shared.Map.EntityCoordinates,Robust.Shared.Map.EntityCoordinates)">
            <summary>
                Returns the sum for both coordinates but only if they have the same relative entity.
            </summary>
            <exception cref="T:System.ArgumentException">Thrown when the relative entities aren't the same</exception>
        </member>
        <member name="M:Robust.Shared.Map.EntityCoordinates.op_Subtraction(Robust.Shared.Map.EntityCoordinates,Robust.Shared.Map.EntityCoordinates)">
            <summary>
                Returns the difference for both coordinates but only if they have the same relative entity.
            </summary>
            <exception cref="T:System.ArgumentException">Thrown when the relative entities aren't the same</exception>
        </member>
        <member name="M:Robust.Shared.Map.EntityCoordinates.op_Multiply(Robust.Shared.Map.EntityCoordinates,Robust.Shared.Map.EntityCoordinates)">
            <summary>
                Returns the multiplication of both coordinates but only if they have the same relative entity.
            </summary>
            <exception cref="T:System.ArgumentException">When the relative entities aren't the same</exception>
        </member>
        <member name="M:Robust.Shared.Map.EntityCoordinates.op_Multiply(Robust.Shared.Map.EntityCoordinates,System.Single)">
            <summary>
                Scales the coordinates by a given factor.
            </summary>
            <exception cref="T:System.ArgumentException">When the relative entities aren't the same</exception>
        </member>
        <member name="M:Robust.Shared.Map.EntityCoordinates.op_Multiply(Robust.Shared.Map.EntityCoordinates,System.Int32)">
            <summary>
                Scales the coordinates by a given factor.
            </summary>
            <exception cref="T:System.ArgumentException">When the relative entities aren't the same</exception>
        </member>
        <member name="M:Robust.Shared.Map.EntityCoordinates.Deconstruct(Robust.Shared.GameObjects.EntityUid@,System.Numerics.Vector2@)">
            <summary>
            Deconstructs the object into it's fields.
            </summary>
            <param name="entId">ID of the entity that this position is relative to.</param>
            <param name="localPos">Position in the entity's local space.</param>
        </member>
        <member name="M:Robust.Shared.Map.EntityCoordinates.ToString">
            <inheritdoc />
        </member>
        <member name="T:Robust.Shared.Map.Enumerators.ChunkIndicesEnumerator">
            <summary>
            Generic iterator for chunk indices for the specified bounds with the specified chunk size.
            </summary>
        </member>
        <member name="T:Robust.Shared.Map.Enumerators.GridTileEnumerator">
            <summary>
            Returns all tiles on a grid.
            </summary>
        </member>
        <member name="T:Robust.Shared.Map.Events.EmptyGridEvent">
            <summary>
            Raised whenever a grid becomes empty due to no more tiles with data.
            </summary>
        </member>
        <member name="T:Robust.Shared.Map.Events.BeforeEntityReadEvent">
            <summary>
            This event is broadcast just before the map loader reads the entity section. It can be used to somewhat modify
            how the map data is read, as a super basic kind of map migration tool.
            </summary>
        </member>
        <member name="F:Robust.Shared.Map.Events.BeforeEntityReadEvent.DeletedPrototypes">
            <summary>
            Set of deleted entity prototypes.
            </summary>
            <remarks>
            While reading the map, these entities will be treated as if they have no prototype. After the map has been
            loaded, these entities will get deleted. This is so that entities parented to this entity (e.g., stored in
            containers) also get deleted, instead of just causing errors. Note that this has not been properly tested is
            quite likely to cause unexpected errors and should be used with care.
            </remarks>
        </member>
        <member name="F:Robust.Shared.Map.Events.BeforeEntityReadEvent.RenamedPrototypes">
            <summary>
            This dictionary maps old entity prototype IDs to some new value. As with <see cref="F:Robust.Shared.Map.Events.BeforeEntityReadEvent.DeletedPrototypes"/>, this
            might cause unexpected errors, user beware.
            </summary>
        </member>
        <member name="T:Robust.Shared.Map.Events.BeforeSaveEvent">
            <summary>
            This event is broadcast just before the map loader reads the entity section. It can be used to somewhat modify
            how the map data is read, as a super basic kind of map migration tool.
            </summary>
        </member>
        <member name="F:Robust.Shared.Map.Events.BeforeSaveEvent.Entity">
            <summary>
            The entity that is going to be saved. usually a map or grid.
            </summary>
        </member>
        <member name="F:Robust.Shared.Map.Events.BeforeSaveEvent.Map">
            <summary>
            The map that the <see cref="F:Robust.Shared.Map.Events.BeforeSaveEvent.Entity"/> is on.
            </summary>
        </member>
        <member name="T:Robust.Shared.Map.Events.RegenerateGridBoundsEvent">
            <summary>
            Raised directed on a grid to get its bounds.
            </summary>
            <remarks>
            Really this exists to get around test dependency creeping.
            </remarks>
        </member>
        <member name="M:Robust.Shared.Map.Events.RegenerateGridBoundsEvent.#ctor(Robust.Shared.GameObjects.EntityUid,System.Collections.Generic.Dictionary{Robust.Shared.Map.MapChunk,System.Collections.Generic.List{Robust.Shared.Maths.Box2i}},System.Collections.Generic.List{Robust.Shared.Map.MapChunk})">
            <summary>
            Raised directed on a grid to get its bounds.
            </summary>
            <remarks>
            Really this exists to get around test dependency creeping.
            </remarks>
        </member>
        <member name="T:Robust.Shared.Map.GridChunkPartition">
            <summary>
            Partitions a grid chunk into a set of non-overlapping rectangles.
            </summary>
        </member>
        <member name="M:Robust.Shared.Map.GridChunkPartition.PartitionChunk(Robust.Shared.Map.MapChunk,Robust.Shared.Maths.Box2i@,System.Collections.Generic.List{Robust.Shared.Maths.Box2i}@)">
             <summary>
            
             </summary>
             <param name="chunk"></param>
             <param name="bounds">The overall bounds that covers every rectangle.</param>
             <param name="rectangles">Each individual rectangle comprising the chunk's bounds</param>
        </member>
        <member name="T:Robust.Shared.Map.GridEventHandler">
            <summary>
            Invoked when a grid is altered.
            </summary>
            <param name="mapId">Passed to the delegate given it may no longer be retrievable.</param>
            <param name="gridId">The index of the grid being changed.</param>
        </member>
        <member name="T:Robust.Shared.Map.IMapManager">
            <summary>
                This manages all of the grids in the world.
            </summary>
        </member>
        <member name="P:Robust.Shared.Map.IMapManager.SuppressOnTileChanged">
            <summary>
                Should the OnTileChanged event be suppressed? This is useful for initially loading the map
                so that you don't spam an event for each of the million station tiles.
            </summary>
        </member>
        <member name="M:Robust.Shared.Map.IMapManager.Initialize">
            <summary>
                Starts up the map system.
            </summary>
        </member>
        <member name="M:Robust.Shared.Map.IMapManager.MapExists(System.Nullable{Robust.Shared.Map.MapId})">
            <summary>
                Check whether a map with specified ID exists.
            </summary>
            <param name="mapId">The map ID to check existence of.</param>
            <returns>True if the map exists, false otherwise.</returns>
        </member>
        <member name="M:Robust.Shared.Map.IMapManager.GetMapEntityId(Robust.Shared.Map.MapId)">
            <summary>
            Returns the map entity ID for a given map, or an invalid entity Id if the map does not exist.
            </summary>
        </member>
        <member name="M:Robust.Shared.Map.IMapManager.GetMapEntityIdOrThrow(Robust.Shared.Map.MapId)">
            <summary>
            Replaces GetMapEntity()'s throw-on-failure semantics.
            </summary>
        </member>
        <member name="M:Robust.Shared.Map.IMapManager.FindGridsIntersecting(Robust.Shared.GameObjects.EntityUid,System.Collections.Generic.List{Robust.Shared.Physics.Collision.Shapes.IPhysShape},Robust.Shared.Physics.Transform,System.Collections.Generic.List{Robust.Shared.GameObjects.Entity{Robust.Shared.Map.Components.MapGridComponent}}@,System.Boolean,System.Boolean)">
            <summary>
            Returns true if any grids overlap the specified shapes.
            </summary>
        </member>
        <member name="M:Robust.Shared.Map.IMapManager.TryFindGridAt(Robust.Shared.Map.MapId,System.Numerics.Vector2,Robust.Shared.GameObjects.EntityUid@,Robust.Shared.Map.Components.MapGridComponent@)">
            <summary>
            Attempts to find the map grid under the map location.
            </summary>
        </member>
        <member name="M:Robust.Shared.Map.IMapManager.TryFindGridAt(Robust.Shared.Map.MapCoordinates,Robust.Shared.GameObjects.EntityUid@,Robust.Shared.Map.Components.MapGridComponent@)">
            <summary>
            Attempts to find the map grid under the map location.
            </summary>
        </member>
        <member name="T:Robust.Shared.Map.IMapManagerInternal">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Map.IMapManagerInternal.RaiseOnTileChanged(Robust.Shared.Map.TileRef,Robust.Shared.Map.Tile,Robust.Shared.Maths.Vector2i)">
            <summary>
                Raises the OnTileChanged event.
            </summary>
            <param name="tileRef">A reference to the new tile.</param>
            <param name="oldTile">The old tile that got replaced.</param>
        </member>
        <member name="T:Robust.Shared.Map.ITileDefinition">
            <summary>
                The definition (template) for a grid tile.
            </summary>
        </member>
        <member name="P:Robust.Shared.Map.ITileDefinition.TileId">
            <summary>
                The numeric tile ID used to refer to this tile inside the map datastructure.
            </summary>
        </member>
        <member name="P:Robust.Shared.Map.ITileDefinition.Name">
            <summary>
                The name of the definition. This is user facing.
            </summary>
        </member>
        <member name="P:Robust.Shared.Map.ITileDefinition.ID">
            <summary>
                Internal name of the definition.
            </summary>
        </member>
        <member name="P:Robust.Shared.Map.ITileDefinition.Sprite">
            <summary>
                The path of the sprite to draw.
            </summary>
        </member>
        <member name="P:Robust.Shared.Map.ITileDefinition.EdgeSprites">
            <summary>
                Possible sprites to use if we're neighboring another tile.
            </summary>
        </member>
        <member name="P:Robust.Shared.Map.ITileDefinition.EdgeSpritePriority">
            <summary>
                When drawing adjacent tiles that both specify edge sprites, the one with the higher priority
                is always solely drawn.
            </summary>
        </member>
        <member name="P:Robust.Shared.Map.ITileDefinition.Friction">
            <summary>
                Physics objects that are interacting on this tile are slowed down by this float.
            </summary>
        </member>
        <member name="P:Robust.Shared.Map.ITileDefinition.Variants">
            <summary>
                Number of variants this tile has. ALSO DETERMINES THE EXPECTED INPUT TEXTURE SIZE.
            </summary>
        </member>
        <member name="M:Robust.Shared.Map.ITileDefinition.AssignTileId(System.UInt16)">
            <summary>
                Assign a new value to <see cref="P:Robust.Shared.Map.ITileDefinition.TileId"/>, used when registering the tile definition.
            </summary>
            <param name="id">The new tile ID for this tile definition.</param>
        </member>
        <member name="P:Robust.Shared.Map.ITileDefinition.EditorHidden">
            <summary>
                Allows you to hide tiles from the tile spawn menu.
            </summary>
        </member>
        <member name="T:Robust.Shared.Map.ITileDefinitionManager">
            <summary>
                This manages tile definitions for grid tiles.
            </summary>
        </member>
        <member name="P:Robust.Shared.Map.ITileDefinitionManager.Item(System.String)">
            <summary>
                Indexer to retrieve a tile definition by name.
                Note: In the presence of tile aliases, this[A].ID does not necessarily equal A.
            </summary>
            <param name="name">The name of the tile definition.</param>
            <returns>The named tile definition.</returns>
            <seealso cref="M:Robust.Shared.Map.ITileDefinitionManager.TryGetDefinition(System.String,Robust.Shared.Map.ITileDefinition@)"/>
        </member>
        <member name="P:Robust.Shared.Map.ITileDefinitionManager.Item(System.Int32)">
            <summary>
                Indexer to retrieve a tile definition by internal ID.
            </summary>
            <param name="id">The ID of the tile definition.</param>
            <returns>The tile definition.</returns>
            <seealso cref="M:Robust.Shared.Map.ITileDefinitionManager.TryGetDefinition(System.Int32,Robust.Shared.Map.ITileDefinition@)"/>
        </member>
        <member name="M:Robust.Shared.Map.ITileDefinitionManager.TryGetDefinition(System.String,Robust.Shared.Map.ITileDefinition@)">
            <summary>
            Try to retrieve a tile definition by name.
            </summary>
            <remarks>
            Note: In the presence of tile aliases, this[A].ID does not necessarily equal A.
            </remarks>
            <param name="name">The name of the tile definition to look up.</param>
            <param name="definition">The found tile definition, if it exists.</param>
            <returns>True if a tile definition was resolved, false otherwise.</returns>
            <seealso cref="P:Robust.Shared.Map.ITileDefinitionManager.Item(System.String)"/>
        </member>
        <member name="M:Robust.Shared.Map.ITileDefinitionManager.TryGetDefinition(System.Int32,Robust.Shared.Map.ITileDefinition@)">
            <summary>
            Try to retrieve a tile definition by tile ID.
            </summary>
            <param name="id">The ID of the tile definition to look up.</param>
            <param name="definition">The found tile definition, if it exists.</param>
            <returns>True if a tile definition was resolved, false otherwise.</returns>
            <seealso cref="P:Robust.Shared.Map.ITileDefinitionManager.Item(System.Int32)"/>
        </member>
        <member name="P:Robust.Shared.Map.ITileDefinitionManager.Count">
            <summary>
                The number of tile definitions contained inside of this manager.
            </summary>
        </member>
        <member name="M:Robust.Shared.Map.ITileDefinitionManager.Register(Robust.Shared.Map.ITileDefinition)">
            <summary>
                Register a definition with this manager.
            </summary>
            <param name="tileDef">THe definition to register.</param>
        </member>
        <member name="M:Robust.Shared.Map.ITileDefinitionManager.AssignAlias(System.String,System.String)">
            <summary>
                Register a tile alias with this manager.
                The tile need not exist yet - the alias's creation will be deferred until it exists.
                Tile aliases do not have IDs of their own and do not show up in enumeration.
                Their main utility is for easier map migration.
            </summary>
            <param name="src">The source tile (i.e. name of the alias).</param>
            <param name="dst">The destination tile (i.e. the actual concrete tile).</param>
        </member>
        <member name="T:Robust.Shared.Map.MapChunk">
            <summary>
                A square section of a <see cref="T:Robust.Shared.Map.Components.MapGridComponent"/>.
            </summary>
        </member>
        <member name="F:Robust.Shared.Map.MapChunk.SnapCellStartingCapacity">
            <summary>
            New SnapGrid cells are allocated with this capacity.
            </summary>
        </member>
        <member name="P:Robust.Shared.Map.MapChunk.FilledTiles">
            <summary>
            Keeps a running count of the number of filled tiles in this chunk.
            </summary>
            <remarks>
            This will always be between 1 and <see cref="P:Robust.Shared.Map.MapChunk.ChunkSize"/>^2.
            </remarks>
        </member>
        <member name="P:Robust.Shared.Map.MapChunk.CachedBounds">
            <summary>
            Chunk-local AABB of this chunk.
            </summary>
        </member>
        <member name="P:Robust.Shared.Map.MapChunk.Fixtures">
            <summary>
            Physics fixtures that make up this grid chunk.
            </summary>
        </member>
        <member name="P:Robust.Shared.Map.MapChunk.LastTileModifiedTick">
            <summary>
            The last game simulation tick that a tile on this chunk was modified.
            </summary>
        </member>
        <member name="P:Robust.Shared.Map.MapChunk.SuppressCollisionRegeneration">
            <summary>
            Setting this property to <see langword="true"/> suppresses collision regeneration on the chunk until the
            property is set to <see langword="false"/>.
            </summary>
        </member>
        <member name="M:Robust.Shared.Map.MapChunk.#ctor(System.Int32,System.Int32,System.UInt16)">
            <summary>
                Constructs an instance of a MapChunk.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="chunkSize"></param>
        </member>
        <member name="P:Robust.Shared.Map.MapChunk.ChunkSize">
            <summary>
                The number of tiles per side of the square chunk.
            </summary>
        </member>
        <member name="P:Robust.Shared.Map.MapChunk.X">
            <summary>
                The X index of this chunk inside the <see cref="T:Robust.Shared.Map.Components.MapGridComponent"/>.
            </summary>
        </member>
        <member name="P:Robust.Shared.Map.MapChunk.Y">
            <summary>
                The Y index of this chunk inside the <see cref="T:Robust.Shared.Map.Components.MapGridComponent"/>.
            </summary>
        </member>
        <member name="P:Robust.Shared.Map.MapChunk.Indices">
            <summary>
                The positional indices of this chunk in the <see cref="T:Robust.Shared.Map.Components.MapGridComponent"/>.
            </summary>
        </member>
        <member name="M:Robust.Shared.Map.MapChunk.GetTile(System.UInt16,System.UInt16)">
            <summary>
            Returns the tile at the given chunk indices.
            </summary>
            <param name="xIndex">The X tile index relative to the chunk origin.</param>
            <param name="yIndex">The Y tile index relative to the chunk origin.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The index is less than or greater than the size of the chunk.</exception>
        </member>
        <member name="M:Robust.Shared.Map.MapChunk.GridTileToChunkTile(Robust.Shared.Maths.Vector2i)">
            <summary>
                Transforms Tile indices relative to the grid into tile indices relative to this chunk.
            </summary>
            <param name="gridTile">Tile indices relative to the grid.</param>
            <returns>Tile indices relative to this chunk.</returns>
        </member>
        <member name="M:Robust.Shared.Map.MapChunk.ChunkTileToGridTile(Robust.Shared.Maths.Vector2i)">
            <summary>
                Translates chunk tile indices to grid tile indices.
            </summary>
            <param name="chunkTile">The indices relative to the chunk origin.</param>
            <returns>The indices relative to the grid origin.</returns>
        </member>
        <member name="M:Robust.Shared.Map.MapChunk.GetSnapGridCell(System.UInt16,System.UInt16)">
            <summary>
            Returns the anchored cell at the given tile indices.
            </summary>
        </member>
        <member name="M:Robust.Shared.Map.MapChunk.AddToSnapGridCell(System.UInt16,System.UInt16,Robust.Shared.GameObjects.EntityUid)">
            <summary>
            Adds an entity to the anchor cell at the given tile indices.
            </summary>
        </member>
        <member name="M:Robust.Shared.Map.MapChunk.RemoveFromSnapGridCell(System.UInt16,System.UInt16,Robust.Shared.GameObjects.EntityUid)">
            <summary>
            Removes an entity from the anchor cell at the given tile indices.
            </summary>
        </member>
        <member name="M:Robust.Shared.Map.MapChunk.ToString">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Map.MapChunk.TrySetTile(System.UInt16,System.UInt16,Robust.Shared.Map.Tile,Robust.Shared.Map.Tile@,System.Boolean@)">
            <summary>
            Sets the tile without any callbacks.
            Do not call this unless you know what you are doing.
            </summary>
        </member>
        <member name="T:Robust.Shared.Map.TileModifiedDelegate">
            <summary>
            Event delegate for <see cref="!:MapChunk.TileModified"/>.
            </summary>
            <param name="mapChunk">Chunk that the tile was on.</param>
            <param name="tileIndices">hunk Indices of the tile that was modified.</param>
            <param name="newTile">New version of the tile.</param>
            <param name="oldTile">Old version of the tile.</param>
            <param name="chunkShapeChanged">If changing this tile changed the shape of the chunk.</param>
        </member>
        <member name="T:Robust.Shared.Map.MapCoordinates">
            <summary>
                Coordinates relative to a specific map.
            </summary>
        </member>
        <member name="F:Robust.Shared.Map.MapCoordinates.Position">
            <summary>
                World Position coordinates.
            </summary>
        </member>
        <member name="F:Robust.Shared.Map.MapCoordinates.MapId">
            <summary>
                Map identifier relevant to this position.
            </summary>
        </member>
        <member name="P:Robust.Shared.Map.MapCoordinates.X">
            <summary>
                World position on the X axis.
            </summary>
        </member>
        <member name="P:Robust.Shared.Map.MapCoordinates.Y">
            <summary>
                World position on the Y axis.
            </summary>
        </member>
        <member name="M:Robust.Shared.Map.MapCoordinates.#ctor(System.Numerics.Vector2,Robust.Shared.Map.MapId)">
            <summary>
                Constructs a new instance of <c>MapCoordinates</c>.
            </summary>
            <param name="position">World position coordinates.</param>
            <param name="mapId">Map identifier relevant to this position.</param>
        </member>
        <member name="M:Robust.Shared.Map.MapCoordinates.#ctor(System.Single,System.Single,Robust.Shared.Map.MapId)">
            <summary>
                Constructs a new instance of <c>MapCoordinates</c>.
            </summary>
            <param name="x">World position coordinate on the X axis.</param>
            <param name="y">World position coordinate on the Y axis.</param>
            <param name="mapId">Map identifier relevant to this position.</param>
        </member>
        <member name="M:Robust.Shared.Map.MapCoordinates.ToString">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Map.MapCoordinates.InRange(Robust.Shared.Map.MapCoordinates,System.Single)">
            <summary>
                Checks that these coordinates are within a certain distance of another set.
            </summary>
            <param name="otherCoords">Other set of coordinates to use.</param>
            <param name="range">maximum distance between the two sets of coordinates.</param>
            <returns>True if the two points are within a given range.</returns>
        </member>
        <member name="M:Robust.Shared.Map.MapCoordinates.Equals(Robust.Shared.Map.MapCoordinates)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Map.MapCoordinates.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Map.MapCoordinates.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Map.MapCoordinates.op_Equality(Robust.Shared.Map.MapCoordinates,Robust.Shared.Map.MapCoordinates)">
            <summary>
                Check for equality by value between two objects.
            </summary>
        </member>
        <member name="M:Robust.Shared.Map.MapCoordinates.op_Inequality(Robust.Shared.Map.MapCoordinates,Robust.Shared.Map.MapCoordinates)">
            <summary>
                Check for inequality by value between two objects.
            </summary>
        </member>
        <member name="M:Robust.Shared.Map.MapCoordinates.Deconstruct(System.Single@,System.Single@)">
            <summary>
            Used to deconstruct this object into a tuple.
            </summary>
            <param name="x">World position coordinate on the X axis.</param>
            <param name="y">World position coordinate on the Y axis.</param>
        </member>
        <member name="M:Robust.Shared.Map.MapCoordinates.Deconstruct(Robust.Shared.Map.MapId@,System.Single@,System.Single@)">
            <summary>
            Used to deconstruct this object into a tuple.
            </summary>
            <param name="mapId">Map identifier relevant to this position.</param>
            <param name="x">World position coordinate on the X axis.</param>
            <param name="y">World position coordinate on the Y axis.</param>
        </member>
        <member name="M:Robust.Shared.Map.MapCoordinates.Offset(System.Numerics.Vector2)">
            <summary>
            Used to get a copy of the coordinates with an offset.
            </summary>
            <param name="offset">Offset to apply to these coordinates</param>
            <returns>A copy of these coordinates, but offset.</returns>
        </member>
        <member name="M:Robust.Shared.Map.MapCoordinates.Offset(System.Single,System.Single)">
            <summary>
            Used to get a copy of the coordinates with an offset.
            </summary>
            <param name="x">X axis offset to apply to these coordinates</param>
            <param name="y">Y axis offset to apply to these coordinates</param>
            <returns>A copy of these coordinates, but offset.</returns>
        </member>
        <member name="T:Robust.Shared.Map.MapGridHelpers">
            <summary>
            Various helper constants and functions for map grids.
            </summary>
        </member>
        <member name="F:Robust.Shared.Map.MapGridHelpers.CollisionGroup">
            <summary>
            The fixed collision group of a map grid.
            </summary>
        </member>
        <member name="M:Robust.Shared.Map.MapId.Equals(Robust.Shared.Map.MapId)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Map.MapId.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Map.MapId.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:Robust.Shared.Map.MapManager">
            <inheritdoc cref="T:Robust.Shared.Map.IMapManager" />
        </member>
        <member name="M:Robust.Shared.Map.MapManager.Initialize">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Map.MapManager.Startup">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Map.MapManager.Shutdown">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Map.MapManager.Restart">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Map.MapManager.SuppressOnTileChanged">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Map.MapManager.RaiseOnTileChanged(Robust.Shared.Map.TileRef,Robust.Shared.Map.Tile,Robust.Shared.Maths.Vector2i)">
            <summary>
                Raises the OnTileChanged event.
            </summary>
            <param name="tileRef">A reference to the new tile.</param>
            <param name="oldTile">The old tile that got replaced.</param>
        </member>
        <member name="M:Robust.Shared.Map.MapManager.DeleteMap(Robust.Shared.Map.MapId)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Map.MapManager.CreateMap(System.Nullable{Robust.Shared.Map.MapId})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Map.MapManager.MapExists(System.Nullable{Robust.Shared.Map.MapId})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Map.MapManager.GetMapEntityId(Robust.Shared.Map.MapId)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Map.MapManager.GetMapEntityIdOrThrow(Robust.Shared.Map.MapId)">
            <summary>
                Replaces GetMapEntity()'s throw-on-failure semantics.
            </summary>
        </member>
        <member name="M:Robust.Shared.Map.MapManager.GetAllMapIds">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Map.MapManager.IsMap(Robust.Shared.GameObjects.EntityUid)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Map.MapManager.IsMapPaused(Robust.Shared.Map.MapId)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Map.MapManager.IsMapPaused(Robust.Shared.GameObjects.EntityUid)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Map.MapManager.InitializeMapPausing">
            <summary>
            Initializes the map pausing system.
            </summary>
        </member>
        <member name="M:Robust.Shared.Map.MapManager.FindGridsIntersecting(Robust.Shared.GameObjects.EntityUid,System.Collections.Generic.List{Robust.Shared.Physics.Collision.Shapes.IPhysShape},Robust.Shared.Physics.Transform,System.Collections.Generic.List{Robust.Shared.GameObjects.Entity{Robust.Shared.Map.Components.MapGridComponent}}@,System.Boolean,System.Boolean)">
            <summary>
            Returns true if any grids overlap the specified shapes.
            </summary>
        </member>
        <member name="M:Robust.Shared.Map.MapManager.TryFindGridAt(Robust.Shared.Map.MapId,System.Numerics.Vector2,Robust.Shared.GameObjects.EntityUid@,Robust.Shared.Map.Components.MapGridComponent@)">
            <summary>
            Attempts to find the map grid under the map location.
            </summary>
        </member>
        <member name="M:Robust.Shared.Map.MapManager.TryFindGridAt(Robust.Shared.Map.MapCoordinates,Robust.Shared.GameObjects.EntityUid@,Robust.Shared.Map.Components.MapGridComponent@)">
            <summary>
            Attempts to find the map grid under the map location.
            </summary>
        </member>
        <member name="T:Robust.Shared.Map.MapEventArgs">
            <summary>
                Arguments for when a map is created or deleted locally ore remotely.
            </summary>
        </member>
        <member name="M:Robust.Shared.Map.MapEventArgs.#ctor(Robust.Shared.Map.MapId)">
            <summary>
                Creates a new instance of this class.
            </summary>
        </member>
        <member name="P:Robust.Shared.Map.MapEventArgs.Map">
            <summary>
                Map that is being modified.
            </summary>
        </member>
        <member name="P:Robust.Shared.Map.MapSerializationContext.WritingReadingPrototypes">
            <summary>
            Are we currently iterating prototypes or entities for writing.
            </summary>
        </member>
        <member name="F:Robust.Shared.Map.MapSerializationContext.MapInitialized">
            <summary>
            Whether the map has been MapInitialized or not.
            </summary>
        </member>
        <member name="F:Robust.Shared.Map.MapSerializationContext.PauseTime">
            <summary>
            How long the target map has been paused. Used for time offsets.
            </summary>
        </member>
        <member name="F:Robust.Shared.Map.MapSerializationContext._parentUid">
            <summary>
            The parent of the entity being saved, This entity is not itself getting saved.
            </summary>
        </member>
        <member name="T:Robust.Shared.Map.NetCoordinates">
            <summary>
                A networked version of <see cref="T:Robust.Shared.Map.EntityCoordinates"/>
            </summary>
        </member>
        <member name="F:Robust.Shared.Map.NetCoordinates.NetEntity">
            <summary>
                Networked ID of the entity that this position is relative to.
            </summary>
        </member>
        <member name="F:Robust.Shared.Map.NetCoordinates.Position">
            <summary>
                Position in the entity's local space.
            </summary>
        </member>
        <member name="P:Robust.Shared.Map.NetCoordinates.X">
            <summary>
                Location of the X axis local to the entity.
            </summary>
        </member>
        <member name="P:Robust.Shared.Map.NetCoordinates.Y">
            <summary>
                Location of the Y axis local to the entity.
            </summary>
        </member>
        <member name="M:Robust.Shared.Map.NetCoordinates.Equals(Robust.Shared.Map.NetCoordinates)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Map.NetCoordinates.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Map.NetCoordinates.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Map.NetCoordinates.Deconstruct(Robust.Shared.GameObjects.NetEntity@,System.Numerics.Vector2@)">
            <summary>
            Deconstructs the object into it's fields.
            </summary>
            <param name="entId">ID of the entity that this position is relative to.</param>
            <param name="localPos">Position in the entity's local space.</param>
        </member>
        <member name="M:Robust.Shared.Map.NetCoordinates.ToString">
            <inheritdoc />
        </member>
        <member name="T:Robust.Shared.Map.ScreenCoordinates">
            <summary>
                Contains the coordinates of a position on the rendering screen.
            </summary>
        </member>
        <member name="F:Robust.Shared.Map.ScreenCoordinates.Position">
            <summary>
                Position on the rendering screen.
            </summary>
        </member>
        <member name="P:Robust.Shared.Map.ScreenCoordinates.X">
            <summary>
                Screen position on the X axis.
            </summary>
        </member>
        <member name="P:Robust.Shared.Map.ScreenCoordinates.Y">
            <summary>
                Screen position on the Y axis.
            </summary>
        </member>
        <member name="F:Robust.Shared.Map.ScreenCoordinates.Window">
            <summary>
                The window which the coordinates are on.
            </summary>
        </member>
        <member name="M:Robust.Shared.Map.ScreenCoordinates.#ctor(System.Numerics.Vector2,Robust.Shared.Map.WindowId)">
            <summary>
                Constructs a new instance of <c>ScreenCoordinates</c>.
            </summary>
            <param name="position">Position on the rendering screen.</param>
            <param name="window">Window for the coordinates.</param>
        </member>
        <member name="M:Robust.Shared.Map.ScreenCoordinates.#ctor(System.Single,System.Single,Robust.Shared.Map.WindowId)">
            <summary>
                Constructs a new instance of <c>ScreenCoordinates</c>.
            </summary>
            <param name="x">X axis of a position on the screen.</param>
            <param name="y">Y axis of a position on the screen.</param>
            <param name="window">Window for the coordinates.</param>
        </member>
        <member name="M:Robust.Shared.Map.ScreenCoordinates.ToString">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Map.ScreenCoordinates.Equals(Robust.Shared.Map.ScreenCoordinates)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Map.ScreenCoordinates.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Map.ScreenCoordinates.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Map.ScreenCoordinates.op_Equality(Robust.Shared.Map.ScreenCoordinates,Robust.Shared.Map.ScreenCoordinates)">
            <summary>
                Check for equality by value between two objects.
            </summary>
        </member>
        <member name="M:Robust.Shared.Map.ScreenCoordinates.op_Inequality(Robust.Shared.Map.ScreenCoordinates,Robust.Shared.Map.ScreenCoordinates)">
            <summary>
                Check for inequality by value between two objects.
            </summary>
        </member>
        <member name="T:Robust.Shared.Map.Tile">
            <summary>
                This structure contains the data for an individual Tile in a <c>MapGrid</c>.
            </summary>
        </member>
        <member name="F:Robust.Shared.Map.Tile.TypeId">
            <summary>
                Internal type ID of this tile.
            </summary>
        </member>
        <member name="F:Robust.Shared.Map.Tile.Flags">
            <summary>
                Rendering flags.
            </summary>
        </member>
        <member name="F:Robust.Shared.Map.Tile.Variant">
            <summary>
            Variant of this tile to render.
            </summary>
        </member>
        <member name="F:Robust.Shared.Map.Tile.Empty">
            <summary>
                An empty tile that can be compared against.
            </summary>
        </member>
        <member name="P:Robust.Shared.Map.Tile.IsEmpty">
            <summary>
                Is this tile space (empty)?
            </summary>
        </member>
        <member name="M:Robust.Shared.Map.Tile.#ctor(System.Int32,Robust.Shared.Map.TileRenderFlag,System.Byte)">
            <summary>
                Creates a new instance of a grid tile.
            </summary>
            <param name="typeId">Internal type ID.</param>
            <param name="flags">Flags used by toolbox's rendering.</param>
            <param name="variant">The visual variant this tile is using.</param>
        </member>
        <member name="M:Robust.Shared.Map.Tile.op_Equality(Robust.Shared.Map.Tile,Robust.Shared.Map.Tile)">
            <summary>
                Check for equality by value between two objects.
            </summary>
        </member>
        <member name="M:Robust.Shared.Map.Tile.op_Inequality(Robust.Shared.Map.Tile,Robust.Shared.Map.Tile)">
            <summary>
                Check for inequality by value between two objects.
            </summary>
        </member>
        <member name="M:Robust.Shared.Map.Tile.ToString">
            <summary>
            Generates String representation of this Tile.
            </summary>
            <returns>String representation of this Tile.</returns>
        </member>
        <member name="M:Robust.Shared.Map.Tile.Equals(Robust.Shared.Map.Tile)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Map.Tile.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Map.Tile.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:Robust.Shared.Map.TileChangedEventHandler">
            <summary>
                Event delegate for the OnTileChanged event.
            </summary>
            <param name="gridId">The ID of the grid being changed.</param>
            <param name="tileRef">A reference to the new tile being inserted.</param>
            <param name="oldTile">The old tile that is being replaced.</param>
        </member>
        <member name="M:Robust.Shared.Map.TileDefinitionManager.#ctor">
            <summary>
            Default Constructor.
            </summary>
        </member>
        <member name="T:Robust.Shared.Map.TileRef">
            <summary>
                All of the information needed to reference a tile in the game.
            </summary>
        </member>
        <member name="F:Robust.Shared.Map.TileRef.GridUid">
            <summary>
                Grid Entity this Tile belongs to.
            </summary>
        </member>
        <member name="F:Robust.Shared.Map.TileRef.GridIndices">
            <summary>
                Positional indices of this tile on the grid.
            </summary>
        </member>
        <member name="F:Robust.Shared.Map.TileRef.Tile">
            <summary>
                Actual data of this Tile.
            </summary>
        </member>
        <member name="M:Robust.Shared.Map.TileRef.#ctor(Robust.Shared.GameObjects.EntityUid,System.Int32,System.Int32,Robust.Shared.Map.Tile)">
            <summary>
                Constructs a new instance of TileRef.
            </summary>
            <param name="gridId">Identifier of the grid this tile belongs to.</param>
            <param name="gridUid">Identifier of the grid entity this tile belongs to.</param>
            <param name="xIndex">Positional X index of this tile on the grid.</param>
            <param name="yIndex">Positional Y index of this tile on the grid.</param>
            <param name="tile">Actual data of this tile.</param>
        </member>
        <member name="M:Robust.Shared.Map.TileRef.#ctor(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Maths.Vector2i,Robust.Shared.Map.Tile)">
            <summary>
                Constructs a new instance of TileRef.
            </summary>
            <param name="gridId">Identifier of the grid this tile belongs to.</param>
            <param name="gridUid">Identifier of the grid entity this tile belongs to.</param>
            <param name="gridIndices">Positional indices of this tile on the grid.</param>
            <param name="tile">Actual data of this tile.</param>
        </member>
        <member name="P:Robust.Shared.Map.TileRef.X">
            <summary>
                Grid index on the X axis.
            </summary>
        </member>
        <member name="P:Robust.Shared.Map.TileRef.Y">
            <summary>
                Grid index on the Y axis.
            </summary>
        </member>
        <member name="M:Robust.Shared.Map.TileRef.ToString">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Map.TileRef.Equals(Robust.Shared.Map.TileRef)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Map.TileRef.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Map.TileRef.op_Equality(Robust.Shared.Map.TileRef,Robust.Shared.Map.TileRef)">
            <summary>
                Check for equality by value between two objects.
            </summary>
        </member>
        <member name="M:Robust.Shared.Map.TileRef.op_Inequality(Robust.Shared.Map.TileRef,Robust.Shared.Map.TileRef)">
            <summary>
                Check for inequality by value between two objects.
            </summary>
        </member>
        <member name="M:Robust.Shared.Map.TileRef.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:Robust.Shared.Map.WindowId">
            <summary>
                An identifier for a single OS window on the client. See <c>IClydeWindow</c> in the client project.
            </summary>
        </member>
        <member name="F:Robust.Shared.Map.WindowId.Invalid">
            <summary>
                An invalid, default value. Does not represent any actual window.
            </summary>
        </member>
        <member name="F:Robust.Shared.Map.WindowId.Main">
            <summary>
                Always the ID of the main game window.
            </summary>
        </member>
        <member name="T:Robust.Shared.Network.IAuthManager">
            <summary>
                Stores client authentication parameters.
            </summary>
        </member>
        <member name="T:Robust.Shared.Network.AuthMode">
            <summary>
            Possible modes for the authentication support on the server.
            </summary>
        </member>
        <member name="F:Robust.Shared.Network.AuthMode.Optional">
            <summary>
            Authentication is allowed but not required.
            </summary>
            <remarks>
            Unauthenticated clients get a "guest@" or "localhost@" prefix to avoid conflict with authenticated clients.
            </remarks>
        </member>
        <member name="F:Robust.Shared.Network.AuthMode.Required">
            <summary>
            Authenticated is required to join the server.
            </summary>
            <remarks>
            Unauthenticated clients are still allowed for localhost connections,
            but only if CVar <c>auth.allowlocal</c> is true.
            </remarks>
        </member>
        <member name="F:Robust.Shared.Network.AuthMode.Disabled">
            <summary>
            Authentication is fully disabled, and even clients capable of authenticating will not authenticate.
            </summary>
            <remarks>
            This disables any sort of "guest@" or "localhost@" prefix for unauthenticated users.
            This may result in confusing mingling of database entries, if actively switched between on the same server.
            </remarks>
        </member>
        <member name="F:Robust.Shared.Network.ClientConnectionState.NotConnecting">
            <summary>
                We are not connected and not trying to get connected either. Quite lonely huh.
            </summary>
        </member>
        <member name="F:Robust.Shared.Network.ClientConnectionState.ResolvingHost">
            <summary>
                Resolving the DNS query for the address of the server.
            </summary>
        </member>
        <member name="F:Robust.Shared.Network.ClientConnectionState.EstablishingConnection">
            <summary>
                Attempting to establish a connection to the server.
            </summary>
        </member>
        <member name="F:Robust.Shared.Network.ClientConnectionState.Handshake">
            <summary>
                Connection established, going through regular handshake business.
            </summary>
        </member>
        <member name="F:Robust.Shared.Network.ClientConnectionState.Connected">
            <summary>
                Connection is solid and handshake is done go wild.
            </summary>
        </member>
        <member name="T:Robust.Shared.Network.IHttpClientHolder">
            <summary>
            Holds a shared <see cref="T:System.Net.Http.HttpClient"/> for the whole program to use.
            </summary>
            <remarks>
            <para>
            The shared <see cref="T:System.Net.Http.HttpClient"/> has an appropriate <c>User-Agent</c> set for Robust,
            and correctly supports Happy Eyeballs.
            </para>
            <para>
            This interface is not available on the client.
            Engine code may use <see cref="T:Robust.Shared.Network.HttpClientHolder"/> directly instead,
            content code can't send arbitrary HTTP requests.
            </para>
            </remarks>
        </member>
        <member name="T:Robust.Shared.Network.HttpClientHolder">
            <summary>
            Implementation of <see cref="T:Robust.Shared.Network.IHttpClientHolder"/>.
            </summary>
        </member>
        <member name="T:Robust.Shared.Network.IClientNetManager">
            <summary>
                The Client version of the INetManager.
            </summary>
        </member>
        <member name="P:Robust.Shared.Network.IClientNetManager.ServerChannel">
            <summary>
                The NetChannel of the server.
            </summary>
        </member>
        <member name="E:Robust.Shared.Network.IClientNetManager.ConnectFailed">
            <summary>
                The attempted connection by a client to a server failed.
            </summary>
        </member>
        <member name="M:Robust.Shared.Network.IClientNetManager.ClientConnect(System.String,System.Int32,System.String)">
            <summary>
                Attempts to connect to the remote server. This does not Restart() the client networking. Make sure
                to Initialize(true) networking before calling this.
            </summary>
            <param name="host">The IP address of the remote server.</param>
            <param name="port">The port the server is listening on.</param>
            <param name="userNameRequest">
                The user name to request from the server.
                The server is in no way obliged to actually give this username to the client.
                It's more a "I'd prefer this" kinda deal.
            </param>
        </member>
        <member name="M:Robust.Shared.Network.IClientNetManager.ClientDisconnect(System.String)">
            <summary>
                Disconnects from the server. This does not Restart() the client networking. Make sure
                to Initialize(true) networking before calling this.
                Also cancels in-progress connection attempts.
            </summary>
            <param name="reason">The reason why disconnect was called.</param>
        </member>
        <member name="M:Robust.Shared.Network.IClientNetManager.DispatchLocalNetMessage(Robust.Shared.Network.NetMessage)">
            <summary>
                Dispatches a messages as if it had just been received over the network.
            </summary>
        </member>
        <member name="T:Robust.Shared.Network.INetChannel">
            <summary>
                A network channel between this peer and a remote peer.
            </summary>
        </member>
        <member name="P:Robust.Shared.Network.INetChannel.NetPeer">
            <summary>
                The NetPeer this belongs to.
            </summary>
        </member>
        <member name="P:Robust.Shared.Network.INetChannel.ConnectionId">
            <summary>
                The Unique Identifier of the connection.
            </summary>
        </member>
        <member name="P:Robust.Shared.Network.INetChannel.RemoteEndPoint">
            <summary>
                The IP end point.
            </summary>
        </member>
        <member name="P:Robust.Shared.Network.INetChannel.UserId">
            <summary>
                The session ID for this channel.
                On the server, this is the session ID for this client.
                On the client, this is the session ID for the client.
            </summary>
        </member>
        <member name="P:Robust.Shared.Network.INetChannel.RemoteTimeOffset">
            <summary>
                Offset between local RealTime and remote RealTime.
            </summary>
        </member>
        <member name="P:Robust.Shared.Network.INetChannel.RemoteTime">
            <summary>
                Remote RealTime.
            </summary>
        </member>
        <member name="P:Robust.Shared.Network.INetChannel.Ping">
            <summary>
                Average round trip time in milliseconds between the remote peer and us.
            </summary>
        </member>
        <member name="P:Robust.Shared.Network.INetChannel.IsConnected">
            <summary>
                Whether or not the channel is currently connected to a remote peer.
            </summary>
        </member>
        <member name="P:Robust.Shared.Network.INetChannel.IsHandshakeComplete">
            <summary>
                Has the serializer handshake completed and <see cref="E:Robust.Shared.Network.INetManager.Connected"/> been ran?
            </summary>
        </member>
        <member name="P:Robust.Shared.Network.INetChannel.CurrentMtu">
            <summary>
            Diagnostic indicating the maximum transmission unit being used for this connection.
            </summary>
            <seealso cref="F:Robust.Shared.CVars.NetMtu"/>
        </member>
        <member name="M:Robust.Shared.Network.INetChannel.CreateNetMessage``1">
            <summary>
                Creates a new NetMessage to be filled up and sent.
            </summary>
            <typeparam name="T">The derived NetMessage type to send.</typeparam>
            <returns>A new instance of the net message.</returns>
        </member>
        <member name="M:Robust.Shared.Network.INetChannel.SendMessage(Robust.Shared.Network.NetMessage)">
            <summary>
                Sends a NetMessage over this NetChannel.
            </summary>
            <param name="message">The NetMessage to send.</param>
        </member>
        <member name="M:Robust.Shared.Network.INetChannel.Disconnect(System.String)">
            <summary>
                Disconnects this channel from the remote peer.
            </summary>
            <param name="reason">Reason why it was disconnected.</param>
        </member>
        <member name="M:Robust.Shared.Network.INetChannel.Disconnect(System.String,System.Boolean)">
            <summary>
                Disconnects this channel from the remote peer.
            </summary>
            <param name="reason">Reason why it was disconnected.</param>
            <param name="sendBye">If false, we ghost the remote client and don't tell them they got disconnected properly.</param>
        </member>
        <member name="T:Robust.Shared.Network.INetManager">
            <summary>
                A network server that listens for connections, relays packets, and manages channels.
            </summary>
        </member>
        <member name="P:Robust.Shared.Network.INetManager.IsServer">
            <summary>
                Is this a server, or a client?
            </summary>
        </member>
        <member name="P:Robust.Shared.Network.INetManager.IsClient">
            <summary>
                Is this a client, or a server?
            </summary>
        </member>
        <member name="P:Robust.Shared.Network.INetManager.IsRunning">
            <summary>
                Has networking been started?
            </summary>
        </member>
        <member name="P:Robust.Shared.Network.INetManager.IsConnected">
            <summary>
                Is there at least one open NetChannel?
            </summary>
        </member>
        <member name="P:Robust.Shared.Network.INetManager.Statistics">
            <summary>
                Network traffic statistics for the local NetChannel.
            </summary>
        </member>
        <member name="P:Robust.Shared.Network.INetManager.Channels">
            <summary>
                All of the current connected NetChannels on this peer.
            </summary>
        </member>
        <member name="P:Robust.Shared.Network.INetManager.ChannelCount">
            <summary>
                The number of connected NetChannels on this peer.
            </summary>
        </member>
        <member name="P:Robust.Shared.Network.INetManager.Port">
            <summary>
                The port that the peer is listening on.
            </summary>
        </member>
        <member name="M:Robust.Shared.Network.INetManager.Initialize(System.Boolean)">
            <summary>
                Initializes the server, and starts listening for connections.
            </summary>
            <param name="isServer">Is this a server, or a client?</param>
        </member>
        <member name="M:Robust.Shared.Network.INetManager.StartServer">
            <summary>
                Starts the server running and listening on the port.
            </summary>
        </member>
        <member name="M:Robust.Shared.Network.INetManager.Shutdown(System.String)">
            <summary>
                Shuts down this peer, disconnecting all channels.
            </summary>
            <param name="reason">String describing why the peer was shut down.</param>
        </member>
        <member name="M:Robust.Shared.Network.INetManager.ProcessPackets">
            <summary>
                Process all queued packets. Should be called often.
            </summary>
        </member>
        <member name="M:Robust.Shared.Network.INetManager.ServerSendToAll(Robust.Shared.Network.NetMessage)">
            <summary>
                Broadcasts a message to every connected channel.
            </summary>
            <param name="message">The message to broadcast.</param>
        </member>
        <member name="M:Robust.Shared.Network.INetManager.ServerSendMessage(Robust.Shared.Network.NetMessage,Robust.Shared.Network.INetChannel)">
            <summary>
                Sends a message to a single channel.
            </summary>
            <param name="message">Message to send.</param>
            <param name="recipient">Channel to send the message over.</param>
        </member>
        <member name="M:Robust.Shared.Network.INetManager.ServerSendToMany(Robust.Shared.Network.NetMessage,System.Collections.Generic.List{Robust.Shared.Network.INetChannel})">
            <summary>
                Sends a message to a collection of channels.
            </summary>
            <param name="message">Message to send.</param>
            <param name="recipients">Channels to send the message over.</param>
        </member>
        <member name="M:Robust.Shared.Network.INetManager.ClientSendMessage(Robust.Shared.Network.NetMessage)">
            <summary>
                Sends a message to the server. Make sure to Initialize(true) and Connect() to a server before calling this.
            </summary>
            <param name="message">Message to send.</param>
        </member>
        <member name="E:Robust.Shared.Network.INetManager.Connecting">
            <summary>
                An incoming connection is being received.
            </summary>
        </member>
        <member name="E:Robust.Shared.Network.INetManager.Connected">
            <summary>
                A client has just connected to the server.
            </summary>
        </member>
        <member name="E:Robust.Shared.Network.INetManager.Disconnect">
            <summary>
                A client has just disconnected from the server.
            </summary>
        </member>
        <member name="M:Robust.Shared.Network.INetManager.RegisterNetMessage``1(Robust.Shared.Network.ProcessMessage{``0},Robust.Shared.Network.NetMessageAccept)">
            <summary>
                Registers a NetMessage to be sent or received.
            </summary>
            <typeparam name="T">Type to register.</typeparam>
            <param name="name">String ID of the message.</param>
            <param name="rxCallback">Callback function to process the received message.</param>
            <param name="accept">
            The side of the network this message is accepted on.
            If we are not on the side specified, the receive callback will not be registered even if provided.
            </param>
        </member>
        <member name="M:Robust.Shared.Network.INetManager.CreateNetMessage``1">
            <summary>
                Creates a new NetMessage to be sent.
            </summary>
            <remarks>
                This function is thread safe.
            </remarks>
            <typeparam name="T">Type of NetMessage to send.</typeparam>
            <returns>Instance of the NetMessage.</returns>
        </member>
        <member name="T:Robust.Shared.Network.IServerNetManager">
            <summary>
            The server version of the INetManager.
            </summary>
        </member>
        <member name="M:Robust.Shared.Network.IServerNetManager.DisconnectChannel(Robust.Shared.Network.INetChannel,System.String)">
            <summary>
                Disconnects this channel from the remote peer.
            </summary>
            <param name="channel">NetChannel to disconnect.</param>
            <param name="reason">Reason why it was disconnected.</param>
        </member>
        <member name="F:Robust.Shared.Network.LoginType.Guest">
            <summary>
                This player is not logged in and as soon as they disconnect their data will be gone, probably.
            </summary>
        </member>
        <member name="F:Robust.Shared.Network.LoginType.LoggedIn">
            <summary>
                This player is properly logged in with an auth account.
            </summary>
        </member>
        <member name="F:Robust.Shared.Network.LoginType.GuestAssigned">
            <summary>
                This player is not logged in but their username does have a static user ID assigned.
            </summary>
        </member>
        <member name="M:Robust.Shared.Network.Messages.MsgConVars.ReadFromBuffer(Lidgren.Network.NetIncomingMessage,Robust.Shared.Serialization.IRobustSerializer)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Network.Messages.MsgConVars.WriteToBuffer(Lidgren.Network.NetOutgoingMessage,Robust.Shared.Serialization.IRobustSerializer)">
            <inheritdoc />
        </member>
        <member name="T:Robust.Shared.Network.Messages.MsgMapStrClientHandshake">
            <summary>
            The client part of the string-exchange handshake, sent after the
            client receives the mapping hash and after the client receives a
            strings package. Tells the server if the client needs an updated
            copy of the mapping.
            </summary>
            <remarks>
            Also sent by the client after a new copy of the string mapping
            has been received. If successfully loaded, the value of
            <see cref="P:Robust.Shared.Network.Messages.MsgMapStrClientHandshake.NeedsStrings"/> is <c>false</c>, otherwise it will be
            <c>true</c>.
            </remarks>
            <seealso cref="M:Robust.Shared.Serialization.RobustMappedStringSerializer.NetworkInitialize"/>
        </member>
        <member name="P:Robust.Shared.Network.Messages.MsgMapStrClientHandshake.NeedsStrings">
            <value>
            <c>true</c> if the client needs a new copy of the mapping,
            <c>false</c> otherwise.
            </value>
        </member>
        <member name="T:Robust.Shared.Network.Messages.MsgMapStrServerHandshake">
            <summary>
            The server part of the string-exchange handshake. Sent as the
            first message in the handshake. Tells the client the hash of
            the current string mapping, so the client can check if it has
            a local copy.
            </summary>
            <seealso cref="M:Robust.Shared.Serialization.RobustMappedStringSerializer.NetworkInitialize"/>
        </member>
        <member name="P:Robust.Shared.Network.Messages.MsgMapStrServerHandshake.Hash">
            <value>
            The hash of the current string mapping held by the server.
            </value>
        </member>
        <member name="T:Robust.Shared.Network.Messages.MsgMapStrStrings">
            <summary>
            The meat of the string-exchange handshake sandwich. Sent by the
            server after the client requests an updated copy of the mapping.
            Contains the updated string mapping.
            </summary>
            <seealso cref="M:Robust.Shared.Serialization.RobustMappedStringSerializer.NetworkInitialize"/>
        </member>
        <member name="P:Robust.Shared.Network.Messages.MsgMapStrStrings.Package">
            <value>
            The raw bytes of the string mapping held by the server.
            </value>
        </member>
        <member name="P:Robust.Shared.Network.Messages.MsgPlacement.Replacement">
            <summary>
            Should we replace existing entities if possible
            </summary>
        </member>
        <member name="T:Robust.Shared.Network.Messages.MsgRay">
            <summary>
            Debug message contain physics collision ray data.
            </summary>
        </member>
        <member name="M:Robust.Shared.Network.Messages.MsgState.ShouldSendReliably">
            <summary>
                Whether this state message is large enough to warrant being sent reliably.
                This is only valid after
            </summary>
            <returns></returns>
        </member>
        <member name="T:Robust.Shared.Network.Messages.MsgStateLeavePvs">
            <summary>
                Message containing a list of entities that have left a clients view.
            </summary>
            <remarks>
                These messages are only sent if PVS is enabled. These messages are sent separately from the main game state.
            </remarks>
        </member>
        <member name="T:Robust.Shared.Network.Messages.MsgSyncTimeBase">
            <summary>
            Sent server -> client to synchronize initial TimeBase on connection.
            Any further time synchronizations are done through the configuration system.
            </summary>
        </member>
        <member name="T:Robust.Shared.Network.Messages.MsgViewVariablesCloseSession">
            <summary>
                Sent from client to server or server to client to notify to close a session.
            </summary>
        </member>
        <member name="P:Robust.Shared.Network.Messages.MsgViewVariablesCloseSession.SessionId">
            <summary>
                The session ID to close, which was agreed upon in <see cref="P:Robust.Shared.Network.Messages.MsgViewVariablesOpenSession.SessionId"/>.
            </summary>
        </member>
        <member name="T:Robust.Shared.Network.Messages.MsgViewVariablesDenySession">
            <summary>
                Sent server to client to deny a <see cref="T:Robust.Shared.Network.Messages.MsgViewVariablesReqSession"/>.
            </summary>
        </member>
        <member name="P:Robust.Shared.Network.Messages.MsgViewVariablesDenySession.RequestId">
            <summary>
                The request ID to identify WHICH request has been denied.
                Equal to <see cref="P:Robust.Shared.Network.Messages.MsgViewVariablesReqSession.RequestId"/> on the message that requested this denied session.
            </summary>
        </member>
        <member name="P:Robust.Shared.Network.Messages.MsgViewVariablesDenySession.Reason">
            <summary>
                Reason for why the request was denied.
            </summary>
        </member>
        <member name="P:Robust.Shared.Network.Messages.MsgViewVariablesModifyRemote.SessionId">
            <summary>
                The session ID of the session to modify.
            </summary>
        </member>
        <member name="P:Robust.Shared.Network.Messages.MsgViewVariablesModifyRemote.ReinterpretValue">
            <summary>
                Whether the value is meant to be "reinterpreted" on the server.
            </summary>
            <remarks>
                Modifying a remote prototype needs that we send an object of type <see cref="T:Robust.Shared.ViewVariables.ViewVariablesBlobMembers.PrototypeReferenceToken"/>.
                Setting this flag to true will make the server index and use the actual prototype the <see cref="P:Robust.Shared.Network.Messages.MsgViewVariablesModifyRemote.Value"/> refers to.
            </remarks>
        </member>
        <member name="P:Robust.Shared.Network.Messages.MsgViewVariablesModifyRemote.PropertyIndex">
            <summary>
                Same deal as <see cref="P:Robust.Shared.ViewVariables.ViewVariablesSessionRelativeSelector.PropertyIndex"/>.
            </summary>
        </member>
        <member name="P:Robust.Shared.Network.Messages.MsgViewVariablesModifyRemote.Value">
            <summary>
                The new value of the property.
            </summary>
        </member>
        <member name="T:Robust.Shared.Network.Messages.MsgViewVariablesOpenSession">
            <summary>
                Sent server to client to notify that a session was accepted and its new ID.
            </summary>
        </member>
        <member name="P:Robust.Shared.Network.Messages.MsgViewVariablesOpenSession.RequestId">
            <summary>
                The request ID to identify WHICH request has been granted.
                Equal to <see cref="P:Robust.Shared.Network.Messages.MsgViewVariablesReqSession.RequestId"/> on the message that requested this session.
            </summary>
        </member>
        <member name="P:Robust.Shared.Network.Messages.MsgViewVariablesOpenSession.SessionId">
            <summary>
                The session ID with which to refer to the session from now on.
            </summary>
        </member>
        <member name="T:Robust.Shared.Network.Messages.MsgViewVariablesRemoteData">
            <summary>
                Sent server to client to contain object data read by VV.
            </summary>
        </member>
        <member name="P:Robust.Shared.Network.Messages.MsgViewVariablesRemoteData.RequestId">
            <summary>
                The request ID equal to the ID sent in <see cref="P:Robust.Shared.Network.Messages.MsgViewVariablesRemoteData.RequestId"/>,
                to identify multiple, potentially concurrent, requests.
            </summary>
        </member>
        <member name="P:Robust.Shared.Network.Messages.MsgViewVariablesRemoteData.Blob">
            <summary>
                The data blob containing the requested data.
            </summary>
        </member>
        <member name="T:Robust.Shared.Network.Messages.MsgViewVariablesReqData">
            <summary>
                Sent client to server to request data from the server.
            </summary>
        </member>
        <member name="P:Robust.Shared.Network.Messages.MsgViewVariablesReqData.RequestId">
            <summary>
                The request ID that will be sent in <see cref="T:Robust.Shared.Network.Messages.MsgViewVariablesRemoteData"/> to
                identify this request among multiple potentially concurrent ones.
            </summary>
        </member>
        <member name="P:Robust.Shared.Network.Messages.MsgViewVariablesReqData.SessionId">
            <summary>
                The session ID for the session to read the data from.
            </summary>
        </member>
        <member name="P:Robust.Shared.Network.Messages.MsgViewVariablesReqData.RequestMeta">
            <summary>
                A metadata object that can be used by the server to know what data is being requested.
            </summary>
        </member>
        <member name="T:Robust.Shared.Network.Messages.MsgViewVariablesReqSession">
            <summary>
                Sent from client to server to request to open a session.
            </summary>
        </member>
        <member name="P:Robust.Shared.Network.Messages.MsgViewVariablesReqSession.RequestId">
            <summary>
                An ID the client assigns so it knows which request was accepted/denied through
                <see cref="T:Robust.Shared.Network.Messages.MsgViewVariablesOpenSession"/> and <see cref="T:Robust.Shared.Network.Messages.MsgViewVariablesCloseSession"/>.
            </summary>
        </member>
        <member name="P:Robust.Shared.Network.Messages.MsgViewVariablesReqSession.Selector">
            <summary>
                A selector that can be used to describe a server object.
                This isn't BYOND, we don't have consistent \ref references.
            </summary>
        </member>
        <member name="T:Robust.Shared.Network.NetChannelArgs">
            <summary>
            Arguments for NetChannel events.
            </summary>
        </member>
        <member name="F:Robust.Shared.Network.NetChannelArgs.Channel">
            <summary>
                The channel causing the event.
            </summary>
        </member>
        <member name="M:Robust.Shared.Network.NetChannelArgs.#ctor(Robust.Shared.Network.INetChannel)">
            <summary>
            Constructs a new instance.
            </summary>
            <param name="channel">The channel causing the event.</param>
        </member>
        <member name="T:Robust.Shared.Network.NetConnectingArgs">
            <summary>
            Arguments for incoming connection event.
            </summary>
        </member>
        <member name="P:Robust.Shared.Network.NetConnectingArgs.UserId">
            <summary>
            The IP of the incoming connection.
            </summary>
        </member>
        <member name="M:Robust.Shared.Network.NetConnectingArgs.#ctor(Robust.Shared.Network.NetUserData,System.Net.IPEndPoint,Robust.Shared.Network.LoginType)">
            <summary>
                Constructs a new instance.
            </summary>
            <param name="data">The user data of the incoming connection.</param>
            <param name="ip"></param>
            <param name="authType">The type of authentication to use when connecting.</param>
        </member>
        <member name="T:Robust.Shared.Network.NetDenyReason">
            <summary>
            Contains a reason for denying a client connection to the game server.
            </summary>
            <param name="Text">The textual reason, presented to the user.</param>
            <param name="AdditionalProperties">
            Additional JSON properties that will be included in the <see cref="T:Robust.Shared.Network.NetDisconnectMessage"/>.
            Valid value types are: string, int, float, bool.
            </param>
            <seealso cref="T:Robust.Shared.Network.NetDisconnectMessage"/>
            <seealso cref="T:Robust.Shared.Network.NetConnectingArgs"/>
        </member>
        <member name="M:Robust.Shared.Network.NetDenyReason.#ctor(System.String,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            Contains a reason for denying a client connection to the game server.
            </summary>
            <param name="Text">The textual reason, presented to the user.</param>
            <param name="AdditionalProperties">
            Additional JSON properties that will be included in the <see cref="T:Robust.Shared.Network.NetDisconnectMessage"/>.
            Valid value types are: string, int, float, bool.
            </param>
            <seealso cref="T:Robust.Shared.Network.NetDisconnectMessage"/>
            <seealso cref="T:Robust.Shared.Network.NetConnectingArgs"/>
        </member>
        <member name="P:Robust.Shared.Network.NetDenyReason.Text">
            <summary>The textual reason, presented to the user.</summary>
        </member>
        <member name="P:Robust.Shared.Network.NetDenyReason.AdditionalProperties">
            <summary>
            Additional JSON properties that will be included in the <see cref="T:Robust.Shared.Network.NetDisconnectMessage"/>.
            Valid value types are: string, int, float, bool.
            </summary>
        </member>
        <member name="T:Robust.Shared.Network.INetStructuredReason">
            <summary>
            Structured reason common interface.
            </summary>
        </member>
        <member name="T:Robust.Shared.Network.NetConnectFailArgs">
            <summary>
            Arguments for a failed connection attempt.
            </summary>
        </member>
        <member name="T:Robust.Shared.Network.NetDisconnectMessage">
            <summary>
            Stores structured information about why a connection was denied or disconnected.
            </summary>
            <remarks>
            <para>
            The core networking layer (Lidgren) allows passing plain strings for disconnect reasons.
            We can beam a structured format (like JSON) over this,
            but Lidgren also generates messages internally (such as on timeout).
            This class is responsible for bridging the two to produce consistent results.
            </para>
            <para>
            Disconnect messages are just a simple key/value format.
            Valid value types are <see cref="T:System.Int32"/>, <see cref="T:System.Single"/>, <see cref="T:System.Boolean"/>, and <see cref="T:System.String"/>.
            </para>
            </remarks>
        </member>
        <member name="F:Robust.Shared.Network.NetDisconnectMessage.DefaultReason">
            <summary>
            The reason given if none was included in the structured message.
            </summary>
        </member>
        <member name="F:Robust.Shared.Network.NetDisconnectMessage.DefaultRedialFlag">
            <summary>
            The default redial flag given if none was included in the structured message.
            </summary>
        </member>
        <member name="F:Robust.Shared.Network.NetDisconnectMessage.ReasonKey">
            <summary>
            The key of the <see cref="P:Robust.Shared.Network.NetDisconnectMessage.Reason"/> value.
            </summary>
        </member>
        <member name="F:Robust.Shared.Network.NetDisconnectMessage.RedialKey">
            <summary>
            The key of the <see cref="P:Robust.Shared.Network.NetDisconnectMessage.RedialFlag"/> value.
            </summary>
        </member>
        <member name="P:Robust.Shared.Network.NetDisconnectMessage.Reason">
            <summary>
            The human-readable reason for why the disconnection happened.
            </summary>
            <seealso cref="F:Robust.Shared.Network.NetDisconnectMessage.ReasonKey"/>
        </member>
        <member name="P:Robust.Shared.Network.NetDisconnectMessage.RedialFlag">
            <summary>
            Whether the client should "redial" to reconnect to the server.
            </summary>
            <remarks>
            Redial means the client gets restarted by the launcher, to enable an update to occur.
            This is generally set if the disconnection reason is some sort of version mismatch.
            </remarks>
            <seealso cref="F:Robust.Shared.Network.NetDisconnectMessage.RedialKey"/>
        </member>
        <member name="M:Robust.Shared.Network.NetDisconnectMessage.Decode(System.String)">
            <summary>
            Decode from a disconnect message.
            </summary>
            <remarks>
            <para>
            If structured JSON can be extracted, it is used.
            Otherwise, or if the format is invalid, the entire input is returned as disconnect reason.
            </para>
            <para>Invalid JSON values (e.g. arrays) are discarded.</para>
            </remarks>
            <param name="text">The disconnect reason from Lidgren's disconnect message.</param>
        </member>
        <member name="M:Robust.Shared.Network.NetDisconnectMessage.Encode">
            <summary>
            Encode to a textual string, that can be embedded into a disconnect message.
            </summary>
        </member>
        <member name="M:Robust.Shared.Network.NetDisconnectMessage.ValueOf(System.String)">
            <summary>
            Get a value by its key.
            </summary>
            <param name="key">The key of the value to look up.</param>
            <returns>
            Null if no such value exists, otherwise an object of one of the valid types (int, float, string, bool).
            </returns>
        </member>
        <member name="M:Robust.Shared.Network.NetDisconnectMessage.StringOf(System.String,System.String)">
            <summary>
            Get a <see cref="T:System.String"/> value by its key.
            </summary>
            <param name="key">The key of the value to look up.</param>
            <param name="defaultValue">Default value to return if the value does not exist or is the wrong type.</param>
            <returns>
            The <see cref="T:System.String"/> value with the given key,
            or <paramref name="defaultValue"/> if no such value exists or it's a different type.
            </returns>
        </member>
        <member name="M:Robust.Shared.Network.NetDisconnectMessage.BoolOf(System.String)">
            <summary>
            Get a <see cref="T:System.Boolean"/> value by its key.
            </summary>
            <param name="key">The key of the value to look up.</param>
            <returns>
            The <see cref="T:System.Boolean"/> value with the given key, or <see langword="null" /> if no such value exists or it's a different type.
            </returns>
        </member>
        <member name="M:Robust.Shared.Network.NetDisconnectMessage.BoolOf(System.String,System.Boolean)">
            <summary>
            Get a <see cref="T:System.Boolean"/> value by its key.
            </summary>
            <param name="key">The key of the value to look up.</param>
            <param name="defaultValue">Default value to return if the value does not exist or is the wrong type.</param>
            <returns>
            The <see cref="T:System.Boolean"/> value with the given key,
            or <paramref name="defaultValue"/> if no such value exists or it's a different type.
            </returns>
        </member>
        <member name="M:Robust.Shared.Network.NetDisconnectMessage.Int32Of(System.String)">
            <summary>
            Get a <see cref="T:System.Int32"/> value by its key.
            </summary>
            <param name="key">The key of the value to look up.</param>
            <returns>
            The <see cref="T:System.Int32"/> value with the given key, or <see langword="null" /> if no such value exists or it's a different type.
            </returns>
        </member>
        <member name="M:Robust.Shared.Network.NetDisconnectMessage.Int32Of(System.String,System.Int32)">
            <summary>
            Get an <see cref="T:System.Int32"/> value by its key.
            </summary>
            <param name="key">The key of the value to look up.</param>
            <param name="defaultValue">Default value to return if the value does not exist or is the wrong type.</param>
            <returns>
            The <see cref="T:System.Int32"/> value with the given key,
            or <paramref name="defaultValue"/> if no such value exists or it's a different type.
            </returns>
        </member>
        <member name="M:Robust.Shared.Network.NetDisconnectMessage.SingleOf(System.String)">
            <summary>
            Get a <see cref="T:System.Single"/> value by its key.
            </summary>
            <param name="key">The key of the value to look up.</param>
            <returns>
            The <see cref="T:System.Single"/> value with the given key, or <see langword="null" /> if no such value exists or it's a different type.
            </returns>
        </member>
        <member name="M:Robust.Shared.Network.NetDisconnectMessage.SingleOf(System.String,System.Single)">
            <summary>
            Get a <see cref="T:System.Single"/> value by its key.
            </summary>
            <param name="key">The key of the value to look up.</param>
            <param name="defaultValue">Default value to return if the value does not exist or is the wrong type.</param>
            <returns>
            The <see cref="T:System.Single"/> value with the given key,
            or <paramref name="defaultValue"/> if no such value exists or it's a different type.
            </returns>
        </member>
        <member name="T:Robust.Shared.Network.NetManager">
            <summary>
                Manages all network connections and packet IO.
            </summary>
        </member>
        <member name="M:Robust.Shared.Network.NetManager.ClientConnect(System.String,System.Int32,System.String)">
            <inheritdoc />
        </member>
        <member name="F:Robust.Shared.Network.NetManager._channels">
            <summary>
                Holds the synced lookup table of NetConnection -> NetChannel
            </summary>
        </member>
        <member name="F:Robust.Shared.Network.NetManager._messages">
            <summary>
                Holds lookup table for NetMessage.Id -> NetMessage.Type
            </summary>
        </member>
        <member name="F:Robust.Shared.Network.NetManager._strings">
            <summary>
            The StringTable for transforming packet Ids to Packet name.
            </summary>
        </member>
        <member name="F:Robust.Shared.Network.NetManager._netPeers">
            <summary>
                The list of network peers we are listening on.
            </summary>
        </member>
        <member name="P:Robust.Shared.Network.NetManager.Port">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Network.NetManager.IsServer">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Network.NetManager.IsClient">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Network.NetManager.IsConnected">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Network.NetManager.Channels">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Network.NetManager.ChannelCount">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Network.NetManager.ServerChannel">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Network.NetManager.Initialize(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Network.NetManager.Shutdown(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Network.NetManager.ClientDisconnect(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Network.NetManager.GetChannel(Lidgren.Network.NetConnection)">
            <summary>
                Gets the NetChannel of a peer NetConnection.
            </summary>
            <param name="connection">The raw connection of the peer.</param>
            <returns>The NetChannel of the peer.</returns>
        </member>
        <member name="M:Robust.Shared.Network.NetManager.DisconnectChannel(Robust.Shared.Network.INetChannel,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Network.NetManager.RegisterNetMessage``1(Robust.Shared.Network.ProcessMessage{``0},Robust.Shared.Network.NetMessageAccept)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Network.NetManager.CreateNetMessage``1">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Network.NetManager.ServerSendToAll(Robust.Shared.Network.NetMessage)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Network.NetManager.ServerSendMessage(Robust.Shared.Network.NetMessage,Robust.Shared.Network.INetChannel)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Network.NetManager.ServerSendToMany(Robust.Shared.Network.NetMessage,System.Collections.Generic.List{Robust.Shared.Network.INetChannel})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Network.NetManager.ClientSendMessage(Robust.Shared.Network.NetMessage)">
            <inheritdoc />
        </member>
        <member name="E:Robust.Shared.Network.NetManager.Connecting">
            <inheritdoc />
        </member>
        <member name="E:Robust.Shared.Network.NetManager.ConnectFailed">
            <inheritdoc />
        </member>
        <member name="E:Robust.Shared.Network.NetManager.Connected">
            <inheritdoc />
        </member>
        <member name="E:Robust.Shared.Network.NetManager.Disconnect">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Network.NetManager.NetChannel.ConnectionId">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Network.NetManager.NetChannel.NetPeer">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Network.NetManager.NetChannel.Ping">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Network.NetManager.NetChannel.IsConnected">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Network.NetManager.NetChannel.RemoteEndPoint">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Network.NetManager.NetChannel.Connection">
            <summary>
                Exposes the lidgren connection.
            </summary>
        </member>
        <member name="M:Robust.Shared.Network.NetManager.NetChannel.#ctor(Robust.Shared.Network.NetManager,Lidgren.Network.NetConnection,Robust.Shared.Network.NetUserData,Robust.Shared.Network.LoginType)">
            <summary>
                Creates a new instance of a NetChannel.
            </summary>
            <param name="manager">The server this channel belongs to.</param>
            <param name="connection">The raw NetConnection to the remote peer.</param>
        </member>
        <member name="M:Robust.Shared.Network.NetManager.NetChannel.CreateNetMessage``1">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Network.NetManager.NetChannel.SendMessage(Robust.Shared.Network.NetMessage)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Network.NetManager.NetChannel.Disconnect(System.String)">
            <inheritdoc />
        </member>
        <member name="T:Robust.Shared.Network.ProcessMessage">
            <summary>
                Callback for registered NetMessages.
            </summary>
            <param name="message">The message received.</param>
        </member>
        <member name="T:Robust.Shared.Network.ProcessMessage`1">
            <summary>
                Callback for registered NetMessages.
            </summary>
            <param name="message">The message received.</param>
        </member>
        <member name="T:Robust.Shared.Network.NetManagerException">
            <summary>
                Generic exception thrown by the NetManager class.
            </summary>
        </member>
        <member name="T:Robust.Shared.Network.NetworkStats">
            <summary>
                Traffic statistics for a NetChannel.
            </summary>
        </member>
        <member name="F:Robust.Shared.Network.NetworkStats.SentBytes">
            <summary>
                Total sent bytes.
            </summary>
        </member>
        <member name="F:Robust.Shared.Network.NetworkStats.ReceivedBytes">
            <summary>
                Total received bytes.
            </summary>
        </member>
        <member name="F:Robust.Shared.Network.NetworkStats.SentPackets">
            <summary>
                Total sent packets.
            </summary>
        </member>
        <member name="F:Robust.Shared.Network.NetworkStats.ReceivedPackets">
            <summary>
                Total received packets.
            </summary>
        </member>
        <member name="M:Robust.Shared.Network.NetworkStats.#ctor(Lidgren.Network.NetPeerStatistics)">
            <summary>
                Creates an instance of this object.
            </summary>
        </member>
        <member name="T:Robust.Shared.Network.MsgGroups">
            <summary>
            The group the message belongs to, used for statistics and packet channels.
            </summary>
        </member>
        <member name="F:Robust.Shared.Network.MsgGroups.Error">
            <summary>
            Error state, the message needs to set a different one.
            </summary>
        </member>
        <member name="F:Robust.Shared.Network.MsgGroups.Core">
            <summary>
            A core message, like connect, disconnect, and tick.
            </summary>
        </member>
        <member name="F:Robust.Shared.Network.MsgGroups.Entity">
            <summary>
            Entity message, for keeping entities in sync.
            </summary>
        </member>
        <member name="F:Robust.Shared.Network.MsgGroups.String">
            <summary>
            A string message, for chat.
            </summary>
        </member>
        <member name="F:Robust.Shared.Network.MsgGroups.Command">
            <summary>
            A command message from client -> server.
            </summary>
        </member>
        <member name="F:Robust.Shared.Network.MsgGroups.EntityEvent">
            <summary>
            ECS Events between the server and the client.
            </summary>
        </member>
        <member name="T:Robust.Shared.Network.NetMessage">
            <summary>
            A packet message that the NetManager sends/receives.
            </summary>
        </member>
        <member name="P:Robust.Shared.Network.NetMessage.MsgName">
            <summary>
            String identifier of the message type.
            </summary>
        </member>
        <member name="P:Robust.Shared.Network.NetMessage.MsgGroup">
            <summary>
            The group this message type belongs to.
            </summary>
        </member>
        <member name="P:Robust.Shared.Network.NetMessage.MsgChannel">
            <summary>
            The channel that this message came in on.
            </summary>
        </member>
        <member name="P:Robust.Shared.Network.NetMessage.MsgSize">
            <summary>
                The size of this packet in bytes.
            </summary>
        </member>
        <member name="M:Robust.Shared.Network.NetMessage.ReadFromBuffer(Lidgren.Network.NetIncomingMessage,Robust.Shared.Serialization.IRobustSerializer)">
            <summary>
            Deserializes the NetIncomingMessage into this NetMessage class.
            </summary>
            <param name="buffer">The buffer of the raw incoming packet.</param>
            <param name="serializer"></param>
        </member>
        <member name="M:Robust.Shared.Network.NetMessage.WriteToBuffer(Lidgren.Network.NetOutgoingMessage,Robust.Shared.Serialization.IRobustSerializer)">
            <summary>
            Serializes this NetMessage into a new NetOutgoingMessage.
            </summary>
            <param name="buffer">The buffer of the new packet being serialized.</param>
            <param name="serializer"></param>
        </member>
        <member name="T:Robust.Shared.Network.NetMessageAccept">
            <summary>
                Defines on which side of the network a net message can be accepted.
            </summary>
        </member>
        <member name="F:Robust.Shared.Network.NetMessageAccept.Server">
            <summary>
                Message can only be received on the server and it is an error to send it to a client.
            </summary>
        </member>
        <member name="F:Robust.Shared.Network.NetMessageAccept.Client">
            <summary>
                Message can only be received on the client and it is an error to send it to a server.
            </summary>
        </member>
        <member name="F:Robust.Shared.Network.NetMessageAccept.Both">
            <summary>
                Message can be received on both client and server.
            </summary>
        </member>
        <member name="F:Robust.Shared.Network.NetMessageAccept.Handshake">
            <summary>
                Message is used during connection handshake and may be sent before the initial handshake is completed.
            </summary>
            <remarks>
                There is a window of time between the initial authentication handshake and serialization handshake,
                where the connection *does* have an INetChannel.
                During this handshake messages are still blocked however unless this flag is sent on the message type.
            </remarks>
        </member>
        <member name="T:Robust.Shared.Network.NetMessageArgs">
            <summary>
            Arguments for the MessageArrived event. This will be removed in the future.
            </summary>
        </member>
        <member name="M:Robust.Shared.Network.NetMessageExt.ReadAlignedMemory(Lidgren.Network.NetIncomingMessage,System.IO.MemoryStream,System.Int32)">
            <summary>
                Reads byte-aligned data as a memory stream.
            </summary>
            <exception cref="T:System.ArgumentException">
                Thrown if the current read position of the message is not byte-aligned.
            </exception>
        </member>
        <member name="T:Robust.Shared.Network.NetUserData">
            <summary>
                Contains data about players returned from auth server.
            </summary>
        </member>
        <member name="T:Robust.Shared.Network.InitCallback">
            <summary>
                Callback for when the string table gets initialized on the client. This is NOT called on the server.
            </summary>
        </member>
        <member name="T:Robust.Shared.Network.StringTableUpdateCallback">
            <summary>
                Callback for when one or more entries in the string table get updated on the client.
                This is NOT called on the server.
            </summary>
            <param name="entries">The entries that were updated.</param>
        </member>
        <member name="T:Robust.Shared.Network.StringTable">
            <summary>
                Contains a networked mapping of IDs -> Strings.
            </summary>
        </member>
        <member name="F:Robust.Shared.Network.StringTable.StringTablePacketId">
            <summary>
                The ID of the <see cref="T:Robust.Shared.Network.MsgStringTableEntries"/> packet.
                This packet must have a fixed ID so the system can bootstrap itself.
            </summary>
        </member>
        <member name="M:Robust.Shared.Network.StringTable.#ctor(Robust.Shared.Network.INetManager)">
            <summary>
                Default constructor.
            </summary>
        </member>
        <member name="P:Robust.Shared.Network.StringTable.InvalidStringId">
            <summary>
            The ID of an invalid string.
            </summary>
        </member>
        <member name="M:Robust.Shared.Network.StringTable.Initialize(Robust.Shared.Network.InitCallback,Robust.Shared.Network.StringTableUpdateCallback)">
            <summary>
            Initializes the string table.
            </summary>
        </member>
        <member name="M:Robust.Shared.Network.StringTable.Reset">
            <summary>
                Resets the string table to the state right after calling Initialize().
            </summary>
        </member>
        <member name="M:Robust.Shared.Network.StringTable.AddString(System.String)">
            <summary>
                Adds a string to the table. The ID is generated automatically.
            </summary>
            <param name="str">The string to add.</param>
            <returns>The ID of the added string.</returns>
        </member>
        <member name="M:Robust.Shared.Network.StringTable.AddStringFixed(System.Int32,System.String)">
            <summary>
                Adds a string with the given ID. If the string already exists with another ID,
                the existing string will be deleted.
                NOTE: You should be using AddString(), unless you know what you are doing, and
                know how this method can break things.
            </summary>
            <param name="id">The ID the string has to use.</param>
            <param name="str">The string to add.</param>
            <returns>The ID of the added string.</returns>
        </member>
        <member name="M:Robust.Shared.Network.StringTable.GetString(System.Int32)">
            <summary>
                Gets the string with the given ID.
            </summary>
            <param name="id">THe ID of the string to get.</param>
            <returns>The string with the given ID, or null.</returns>
        </member>
        <member name="M:Robust.Shared.Network.StringTable.TryGetString(System.Int32,System.String@)">
            <summary>
                Tries to get the string with the given ID.
            </summary>
            <param name="id">The ID of the string.</param>
            <param name="str">The string with the ID.</param>
            <returns>True if the table contains the ID, false if it does not.</returns>
        </member>
        <member name="M:Robust.Shared.Network.StringTable.TryFindStringId(System.String,System.Int32@)">
            <summary>
                Tries to find the ID of the given string.
            </summary>
            <param name="str">The string to find.</param>
            <param name="id">The found ID of the string.</param>
            <returns>True if the table contains the string, false if it does not.</returns>
        </member>
        <member name="M:Robust.Shared.Network.StringTable.SendFullTable(Robust.Shared.Network.INetChannel)">
            <summary>
                Sends the full table to a channel.
            </summary>
            <param name="channel">The channel that will receive the table.</param>
        </member>
        <member name="T:Robust.Shared.Network.MsgStringTableEntries">
            <summary>
            A net message for transmitting a string table entry to clients.
            </summary>
        </member>
        <member name="T:Robust.Shared.Network.MsgStringTableEntries.Entry">
            <summary>
                A string table entry.
            </summary>
        </member>
        <member name="P:Robust.Shared.Network.MsgStringTableEntries.Entry.String">
            <summary>
                The string contained inside of the message.
            </summary>
        </member>
        <member name="P:Robust.Shared.Network.MsgStringTableEntries.Entry.Id">
            <summary>
                The ID of the string inside of the message.
            </summary>
        </member>
        <member name="M:Robust.Shared.Network.MsgStringTableEntries.ReadFromBuffer(Lidgren.Network.NetIncomingMessage,Robust.Shared.Serialization.IRobustSerializer)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Network.MsgStringTableEntries.WriteToBuffer(Lidgren.Network.NetOutgoingMessage,Robust.Shared.Serialization.IRobustSerializer)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Noise.FastNoise.GetDecimalType">
            <summary>
            Returns a 0 float/double
            </summary>
        </member>
        <member name="M:Robust.Shared.Noise.FastNoise.GetSeed">
            <summary>
            Returns the seed used by this object
            </summary>
        </member>
        <member name="M:Robust.Shared.Noise.FastNoise.SetSeed(System.Int32)">
            <summary>
            Sets seed used for all noise types
            Default: 1337
            </summary>
            <param name="seed"></param>
        </member>
        <member name="M:Robust.Shared.Noise.FastNoise.SetFrequency(System.Single)">
            <summary>
            Sets frequency for all noise types
            Default: 0.01
            </summary>
            <param name="frequency"></param>
        </member>
        <member name="M:Robust.Shared.Noise.FastNoise.SetInterp(Robust.Shared.Noise.FastNoise.Interp)">
            <summary>
            Changes the interpolation method used to smooth between noise values
            Possible interpolation methods (lowest to highest quality) :
            - Linear
            - Hermite
            - Quintic
            Used in Value, Gradient Noise and Position Perturbing
            Default: Quintic
            </summary>
        </member>
        <member name="M:Robust.Shared.Noise.FastNoise.SetNoiseType(Robust.Shared.Noise.FastNoise.NoiseType)">
            <summary>
            Sets noise return type of GetNoise(...)
            Default: Simplex
            </summary>
            <param name="noiseType"></param>
        </member>
        <member name="M:Robust.Shared.Noise.FastNoise.SetFractalOctaves(System.Int32)">
            <summary>
            Sets octave count for all fractal noise types
            Default: 3
            </summary>
        </member>
        <member name="M:Robust.Shared.Noise.FastNoise.SetFractalLacunarity(System.Single)">
            <summary>
            Sets octave lacunarity for all fractal noise types
            Default: 2.0
            </summary>
        </member>
        <member name="M:Robust.Shared.Noise.FastNoise.SetFractalGain(System.Single)">
            <summary>
            Sets octave gain for all fractal noise types
            Default: 0.5
            </summary>
        </member>
        <member name="M:Robust.Shared.Noise.FastNoise.SetFractalType(Robust.Shared.Noise.FastNoise.FractalType)">
            <summary>
            Sets method for combining octaves in all fractal noise types
            Default: FBM
            </summary>
        </member>
        <member name="M:Robust.Shared.Noise.FastNoise.SetCellularDistanceFunction(Robust.Shared.Noise.FastNoise.CellularDistanceFunction)">
            <summary>
            Sets return type from cellular noise calculations
            Note: NoiseLookup requires another FastNoise object be set with SetCellularNoiseLookup() to function
            Default: CellValue
            </summary>
        </member>
        <member name="M:Robust.Shared.Noise.FastNoise.SetCellularReturnType(Robust.Shared.Noise.FastNoise.CellularReturnType)">
            <summary>
            Sets distance function used in cellular noise calculations
            Default: Euclidean
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Robust.Shared.Noise.FastNoise.SetCellularDistance2Indices(System.Int32,System.Int32)" -->
        <member name="M:Robust.Shared.Noise.FastNoise.SetCellularJitter(System.Single)">
            <summary>
            Sets the maximum distance a cellular point can move from its grid position
            Setting this high will make artifacts more common
            Default: 0.45
            </summary>
        </member>
        <member name="M:Robust.Shared.Noise.FastNoise.SetCellularNoiseLookup(Robust.Shared.Noise.FastNoise)">
            <summary>
            Noise used to calculate a cell value if cellular return type is NoiseLookup
            The lookup value is acquired through GetNoise() so ensure you SetNoiseType() on the noise lookup, value, gradient or simplex is recommended
            </summary>
        </member>
        <member name="M:Robust.Shared.Noise.FastNoise.SetGradientPerturbAmp(System.Single)">
            <summary>
            Sets the maximum perturb distance from original location when using GradientPerturb{Fractal}(...)
            Default: 1.0
            </summary>
        </member>
        <member name="M:Robust.Shared.Noise.FastNoise.FloatCast2Int(System.Single)">
            <summary>
            White Noise
            </summary>
        </member>
        <member name="M:Robust.Shared.Noise.FastNoise.GetValueFractal(System.Single,System.Single,System.Single)">
            <summary>
            Value Noise
            </summary>
        </member>
        <member name="M:Robust.Shared.Noise.FastNoise.GetPerlinFractal(System.Single,System.Single,System.Single)">
            <summary>
            Gradient Noise
            </summary>
        </member>
        <member name="M:Robust.Shared.Noise.FastNoise.GetSimplexFractal(System.Single,System.Single,System.Single)">
            <summary>
            Simplex Noise
            </summary>
        </member>
        <member name="M:Robust.Shared.Noise.FastNoise.GetCubicFractal(System.Single,System.Single,System.Single)">
            <summary>
            Cubic Noise
            </summary>
        </member>
        <member name="M:Robust.Shared.Noise.FastNoise.GetCellular(System.Single,System.Single,System.Single)">
            <summary>
            Cellular Noise
            </summary>
        </member>
        <member name="M:Robust.Shared.Noise.FastNoiseLite.#ctor(System.Int32)">
            <summary>
            Create new FastNoise object with optional seed
            </summary>
        </member>
        <member name="M:Robust.Shared.Noise.FastNoiseLite.SetSeed(System.Int32)">
            <summary>
            Sets seed used for all noise types
            </summary>
            <remarks>
            Default: 1337
            </remarks>
        </member>
        <member name="M:Robust.Shared.Noise.FastNoiseLite.SetFrequency(System.Single)">
            <summary>
            Sets frequency for all noise types
            </summary>
            <remarks>
            Default: 0.01
            </remarks>
        </member>
        <member name="M:Robust.Shared.Noise.FastNoiseLite.SetNoiseType(Robust.Shared.Noise.FastNoiseLite.NoiseType)">
            <summary>
            Sets noise algorithm used for GetNoise(...)
            </summary>
            <remarks>
            Default: OpenSimplex2
            </remarks>
        </member>
        <member name="M:Robust.Shared.Noise.FastNoiseLite.SetRotationType3D(Robust.Shared.Noise.FastNoiseLite.RotationType3D)">
            <summary>
            Sets domain rotation type for 3D Noise and 3D DomainWarp.
            Can aid in reducing directional artifacts when sampling a 2D plane in 3D
            </summary>
            <remarks>
            Default: None
            </remarks>
        </member>
        <member name="M:Robust.Shared.Noise.FastNoiseLite.SetFractalType(Robust.Shared.Noise.FastNoiseLite.FractalType)">
            <summary>
            Sets method for combining octaves in all fractal noise types
            </summary>
            <remarks>
            Default: None
            Note: FractalType.DomainWarp... only affects DomainWarp(...)
            </remarks>
        </member>
        <member name="M:Robust.Shared.Noise.FastNoiseLite.SetFractalOctaves(System.Int32)">
            <summary>
            Sets octave count for all fractal noise types
            </summary>
            <remarks>
            Default: 3
            </remarks>
        </member>
        <member name="M:Robust.Shared.Noise.FastNoiseLite.SetFractalLacunarity(System.Single)">
            <summary>
            Sets octave lacunarity for all fractal noise types
            </summary>
            <remarks>
            Default: 2.0
            </remarks>
        </member>
        <member name="M:Robust.Shared.Noise.FastNoiseLite.SetFractalGain(System.Single)">
            <summary>
            Sets octave gain for all fractal noise types
            </summary>
            <remarks>
            Default: 0.5
            </remarks>
        </member>
        <member name="M:Robust.Shared.Noise.FastNoiseLite.SetFractalWeightedStrength(System.Single)">
            <summary>
            Sets octave weighting for all none DomainWarp fratal types
            </summary>
            <remarks>
            Default: 0.0
            Note: Keep between 0...1 to maintain -1...1 output bounding
            </remarks>
        </member>
        <member name="M:Robust.Shared.Noise.FastNoiseLite.SetFractalPingPongStrength(System.Single)">
            <summary>
            Sets strength of the fractal ping pong effect
            </summary>
            <remarks>
            Default: 2.0
            </remarks>
        </member>
        <member name="M:Robust.Shared.Noise.FastNoiseLite.SetCellularDistanceFunction(Robust.Shared.Noise.FastNoiseLite.CellularDistanceFunction)">
            <summary>
            Sets distance function used in cellular noise calculations
            </summary>
            <remarks>
            Default: Distance
            </remarks>
        </member>
        <member name="M:Robust.Shared.Noise.FastNoiseLite.SetCellularReturnType(Robust.Shared.Noise.FastNoiseLite.CellularReturnType)">
            <summary>
            Sets return type from cellular noise calculations
            </summary>
            <remarks>
            Default: EuclideanSq
            </remarks>
        </member>
        <member name="M:Robust.Shared.Noise.FastNoiseLite.SetCellularJitter(System.Single)">
            <summary>
            Sets the maximum distance a cellular point can move from it's grid position
            </summary>
            <remarks>
            Default: 1.0
            Note: Setting this higher than 1 will cause artifacts
            </remarks>
        </member>
        <member name="M:Robust.Shared.Noise.FastNoiseLite.SetDomainWarpType(Robust.Shared.Noise.FastNoiseLite.DomainWarpType)">
            <summary>
            Sets the warp algorithm when using DomainWarp(...)
            </summary>
            <remarks>
            Default: OpenSimplex2
            </remarks>
        </member>
        <member name="M:Robust.Shared.Noise.FastNoiseLite.SetDomainWarpAmp(System.Single)">
            <summary>
            Sets the maximum warp distance from original position when using DomainWarp(...)
            </summary>
            <remarks>
            Default: 1.0
            </remarks>
        </member>
        <member name="M:Robust.Shared.Noise.FastNoiseLite.GetNoise(System.Single,System.Single)">
            <summary>
            2D noise at given position using current settings
            </summary>
            <returns>
            Noise output bounded between -1...1
            </returns>
        </member>
        <member name="M:Robust.Shared.Noise.FastNoiseLite.GetNoise(System.Single,System.Single,System.Single)">
            <summary>
            3D noise at given position using current settings
            </summary>
            <returns>
            Noise output bounded between -1...1
            </returns>
        </member>
        <member name="M:Robust.Shared.Noise.FastNoiseLite.DomainWarp(System.Single@,System.Single@)">
            <summary>
            2D warps the input position using current domain warp settings
            </summary>
            <example>
            Example usage with GetNoise
            <code>DomainWarp(ref x, ref y)
            noise = GetNoise(x, y)</code>
            </example>
        </member>
        <member name="M:Robust.Shared.Noise.FastNoiseLite.DomainWarp(System.Single@,System.Single@,System.Single@)">
            <summary>
            3D warps the input position using current domain warp settings
            </summary>
            <example>
            Example usage with GetNoise
            <code>DomainWarp(ref x, ref y, ref z)
            noise = GetNoise(x, y, z)</code>
            </example>
        </member>
        <member name="M:Robust.Shared.Noise.FastNoiseLite.InternalCopy(Robust.Shared.Noise.FastNoiseLite@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Noise.FastNoiseLite.Copy(Robust.Shared.Noise.FastNoiseLite@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Noise.FastNoiseLite.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Noise.FastNoiseLite.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Shared.Physics.B2DynamicTree`1">
             <summary>
            
             </summary>
             <typeparam name="T"></typeparam>
        </member>
        <member name="M:Robust.Shared.Physics.B2DynamicTree`1.AllocateNode(Robust.Shared.Physics.DynamicTree.Proxy@)">
            <summary>Allocate a node from the pool. Grow the pool if necessary.</summary>
            <remarks>
                If allocation occurs, references to <see cref="T:Robust.Shared.Physics.B2DynamicTree`1.Node" />s will be invalid.
            </remarks>
        </member>
        <member name="M:Robust.Shared.Physics.B2DynamicTree`1.FreeNode(Robust.Shared.Physics.DynamicTree.Proxy)">
            <summary>
                Return a node to the pool.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.B2DynamicTree`1.CreateProxy(Robust.Shared.Maths.Box2@,`0)">
            <summary>
                Create a proxy in the tree as a leaf node.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.B2DynamicTree`1.BalanceStep(Robust.Shared.Physics.DynamicTree.Proxy)">
            <summary>
                Perform a left or right rotation if node A is imbalanced.
            </summary>
            <returns>The new root index.</returns>
        </member>
        <member name="M:Robust.Shared.Physics.B2DynamicTree`1.ComputeHeight(Robust.Shared.Physics.DynamicTree.Proxy)">
            <summary>
                Compute the height of a sub-tree.
            </summary>
        </member>
        <member name="T:Robust.Shared.Physics.BodyType">
            <summary>
                The properties of physical body. This determines how collisions will effect this body.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.BodyType.Kinematic">
            <summary>
                Kinematic objects have to be moved manually and have their forces reset every tick.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.BodyType.KinematicController">
            <summary>
                Kinematic controller objects are similar to kinematic bodies except they cannot push anything at all.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.BodyType.Static">
            <summary>
                Static objects have infinite mass and cannot be moved by forces or collisions. They are solid,
                will collide with other objects, and raise collision events. This is what you use for immovable level geometry.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.BodyType.Dynamic">
            <summary>
                Dynamic objects will respond to collisions and forces. They will raise collision events. This is what
                you use for movable objects in the game.
            </summary>
        </member>
        <member name="T:Robust.Shared.Physics.BroadphaseComponent">
            <summary>
            Stores the broadphase structure for the relevant grid / map.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.BroadphaseComponent.DynamicTree">
            <summary>
            Stores all non-static bodies.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.BroadphaseComponent.StaticTree">
            <summary>
            Stores all static bodies.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.BroadphaseComponent.SundriesTree">
            <summary>
            Stores all other non-static entities not in another tree.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.BroadphaseComponent.StaticSundriesTree">
            <summary>
            Stores all other static entities not in another tree.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.BroadphaseComponent.InternalCopy(Robust.Shared.Physics.BroadphaseComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.BroadphaseComponent.Copy(Robust.Shared.Physics.BroadphaseComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.BroadphaseComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.BroadphaseComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.BroadphaseComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.BroadphaseComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.BroadphaseComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Shared.Physics.CollisionRay">
            <summary>
                A representation of a 2D ray.
            </summary>
        </member>
        <member name="P:Robust.Shared.Physics.CollisionRay.Position">
            <summary>
                Specifies the starting point of the ray.
            </summary>
        </member>
        <member name="P:Robust.Shared.Physics.CollisionRay.Direction">
            <summary>
                Specifies the direction the ray is pointing.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.CollisionRay.#ctor(System.Numerics.Vector2,System.Numerics.Vector2,System.Int32)">
            <summary>
                Creates a new instance of a Ray.
            </summary>
            <param name="position">Starting position of the ray.</param>
            <param name="direction">Unit direction vector that the ray is pointing.</param>
        </member>
        <member name="M:Robust.Shared.Physics.CollisionRay.Equals(Robust.Shared.Physics.CollisionRay)">
            <summary>
                Determines if this Ray and another Ray are equivalent.
            </summary>
            <param name="other">Ray to compare to.</param>
        </member>
        <member name="M:Robust.Shared.Physics.CollisionRay.Equals(System.Object)">
            <summary>
                Determines if this ray and another object is equivalent.
            </summary>
            <param name="obj">Object to compare to.</param>
        </member>
        <member name="M:Robust.Shared.Physics.CollisionRay.GetHashCode">
            <summary>
                Calculates the hash code of this Ray.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.CollisionRay.op_Equality(Robust.Shared.Physics.CollisionRay,Robust.Shared.Physics.CollisionRay)">
            <summary>
                Determines if two instances of Ray are equal.
            </summary>
            <param name="a">Ray on the left side of the operator.</param>
            <param name="b">Ray on the right side of the operator.</param>
        </member>
        <member name="M:Robust.Shared.Physics.CollisionRay.op_Inequality(Robust.Shared.Physics.CollisionRay,Robust.Shared.Physics.CollisionRay)">
            <summary>
                Determines if two instances of Ray are not equal.
            </summary>
            <param name="a">Ray on the left side of the operator.</param>
            <param name="b">Ray on the right side of the operator.</param>
        </member>
        <member name="T:Robust.Shared.Physics.Collision.ClipVertex">
            <summary>
            Used for computing contact manifolds.
            </summary>
        </member>
        <member name="T:Robust.Shared.Physics.Collision.CollisionManager">
            <summary>
                Handles several collision features: Generating contact manifolds, testing shape overlap,
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Collision.CollisionManager.GetPointStates(Robust.Shared.Physics.Collision.PointState[]@,Robust.Shared.Physics.Collision.PointState[]@,Robust.Shared.Physics.Collision.Manifold@,Robust.Shared.Physics.Collision.Manifold@)">
            <summary>
                Used for debugging contact points.
            </summary>
            <param name="state1"></param>
            <param name="state2"></param>
            <param name="manifold1"></param>
            <param name="manifold2"></param>
        </member>
        <member name="M:Robust.Shared.Physics.Collision.CollisionManager.ClipSegmentToLine(System.Span{Robust.Shared.Physics.Collision.ClipVertex},System.Span{Robust.Shared.Physics.Collision.ClipVertex},System.Numerics.Vector2,System.Single,System.Int32)">
            <summary>
                Clipping for contact manifolds.
            </summary>
            <param name="vOut">The v out.</param>
            <param name="vIn">The v in.</param>
            <param name="normal">The normal.</param>
            <param name="offset">The offset.</param>
            <param name="vertexIndexA">The vertex index A.</param>
            <returns></returns>
        </member>
        <member name="M:Robust.Shared.Physics.Collision.CollisionManager.CollideEdgeAndCircle(Robust.Shared.Physics.Collision.Manifold@,Robust.Shared.Physics.Collision.Shapes.EdgeShape,Robust.Shared.Physics.Transform@,Robust.Shared.Physics.Collision.Shapes.PhysShapeCircle,Robust.Shared.Physics.Transform@)">
            <summary>
            Compute contact points for edge versus circle.
            This accounts for edge connectivity.
            </summary>
            <param name="manifold">The manifold.</param>
            <param name="edgeA">The edge A.</param>
            <param name="transformA">The transform A.</param>
            <param name="circleB">The circle B.</param>
            <param name="transformB">The transform B.</param>
        </member>
        <member name="M:Robust.Shared.Physics.Collision.CollisionManager.CollideEdgeAndPolygon(Robust.Shared.Physics.Collision.Manifold@,Robust.Shared.Physics.Collision.Shapes.EdgeShape,Robust.Shared.Physics.Transform@,Robust.Shared.Physics.Collision.Shapes.PolygonShape,Robust.Shared.Physics.Transform@)">
            <summary>
                Collides and edge and a polygon, taking into account edge adjacency.
            </summary>
            <param name="manifold">The manifold.</param>
            <param name="edgeA">The edge A.</param>
            <param name="xfA">The xf A.</param>
            <param name="polygonB">The polygon B.</param>
            <param name="xfB">The xf B.</param>
        </member>
        <member name="M:Robust.Shared.Physics.Collision.CollisionManager.TestOverlap(Robust.Shared.Physics.Collision.Shapes.IPhysShape,System.Int32,Robust.Shared.Physics.Collision.Shapes.IPhysShape,System.Int32,Robust.Shared.Physics.Transform@,Robust.Shared.Physics.Transform@)">
            <summary>
            Test overlap between the two shapes.
            </summary>
            <param name="shapeA">The first shape.</param>
            <param name="shapeB">The second shape.</param>
            <param name="xfA">The transform for the first shape.</param>
            <param name="xfB">The transform for the seconds shape.</param>
            <returns></returns>
        </member>
        <member name="M:Robust.Shared.Physics.Collision.CollisionManager.CollidePolygonAndCircle(Robust.Shared.Physics.Collision.Manifold@,Robust.Shared.Physics.Collision.Shapes.PolygonShape,Robust.Shared.Physics.Transform@,Robust.Shared.Physics.Collision.Shapes.PhysShapeCircle,Robust.Shared.Physics.Transform@)">
            <summary>
            Compute the collision manifold between a polygon and a circle.
            </summary>
            <param name="manifold">The manifold.</param>
            <param name="polygonA">The polygon A.</param>
            <param name="xfA">The transform of A.</param>
            <param name="circleB">The circle B.</param>
            <param name="xfB">The transform of B.</param>
        </member>
        <member name="M:Robust.Shared.Physics.Collision.CollisionManager.FindMaxSeparation(System.Int32@,Robust.Shared.Physics.Collision.Shapes.PolygonShape,Robust.Shared.Physics.Transform@,Robust.Shared.Physics.Collision.Shapes.PolygonShape,Robust.Shared.Physics.Transform@)">
            <summary>
            Find the max separation between poly1 and poly2 using edge normals from poly1.
            </summary>
            <param name="edgeIndex">Index of the edge.</param>
            <param name="poly1">The poly1.</param>
            <param name="xf1">The XF1.</param>
            <param name="poly2">The poly2.</param>
            <param name="xf2">The XF2.</param>
            <returns></returns>
        </member>
        <member name="M:Robust.Shared.Physics.Collision.CollisionManager.CollidePolygons(Robust.Shared.Physics.Collision.Manifold@,Robust.Shared.Physics.Collision.Shapes.PolygonShape,Robust.Shared.Physics.Transform@,Robust.Shared.Physics.Collision.Shapes.PolygonShape,Robust.Shared.Physics.Transform@)">
            <summary>
            Compute the collision manifold between two polygons.
            </summary>
            <param name="manifold">The manifold.</param>
            <param name="polyA">The poly A.</param>
            <param name="transformA">The transform A.</param>
            <param name="polyB">The poly B.</param>
            <param name="transformB">The transform B.</param>
        </member>
        <member name="T:Robust.Shared.Physics.Collision.EPAxis">
            <summary>
            This structure is used to keep track of the best separating axis.
            </summary>
        </member>
        <member name="T:Robust.Shared.Physics.Collision.ReferenceFace">
            <summary>
            Reference face used for clipping
            </summary>
        </member>
        <member name="T:Robust.Shared.Physics.Collision.DistanceInput">
            <summary>
            Input for Distance.ComputeDistance().
            DANGEROUS TO USE DUE TO C# LIMITATIONS, DO NOT USE DIRECTLY EVER I WILL SHED YOU.
            You have to option to use the shape radii in the computation.
            </summary>
        </member>
        <member name="T:Robust.Shared.Physics.Collision.DistanceProxy">
            <summary>
            A distance proxy is used by the GJK algorithm.
            It encapsulates any shape.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Collision.DistanceProxy.Set(Robust.Shared.Physics.Collision.Shapes.IPhysShape,System.Int32)">
            <summary>
            Initialize the proxy using the given shape. The shape
            must remain in scope while the proxy is in use.
            </summary>
            <param name="shape">The shape.</param>
        </member>
        <member name="M:Robust.Shared.Physics.Collision.DistanceProxy.GetSupport(System.Numerics.Vector2)">
            <summary>
            Get the supporting vertex index in the given direction.
            </summary>
            <param name="direction">The direction.</param>
            <returns></returns>
        </member>
        <member name="M:Robust.Shared.Physics.Collision.DistanceProxy.GetSupportVertex(System.Numerics.Vector2)">
            <summary>
            Get the supporting vertex in the given direction.
            </summary>
            <param name="direction">The direction.</param>
            <returns></returns>
        </member>
        <member name="T:Robust.Shared.Physics.Collision.DistanceOutput">
            <summary>
            Output for Distance.ComputeDistance().
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Collision.DistanceOutput.Iterations">
            <summary>
            Number of GJK iterations used
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Collision.DistanceOutput.PointA">
            <summary>
            Closest point on shapeA
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Collision.DistanceOutput.PointB">
            <summary>
            Closest point on shapeB
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Collision.SimplexVertex.A">
            <summary>
            Barycentric coordinate for closest point
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Collision.SimplexVertex.IndexA">
            <summary>
            wA index
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Collision.SimplexVertex.IndexB">
            <summary>
            wB index
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Collision.SimplexVertex.W">
            <summary>
            wB - wA
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Collision.SimplexVertex.WA">
            <summary>
            Support point in proxyA
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Collision.SimplexVertex.WB">
            <summary>
            Support point in proxyB
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Collision.IManifoldManager.GetContactEdge">
            <summary>
            Gets an edge from objectpool.
            </summary>
        </member>
        <member name="T:Robust.Shared.Physics.Collision.ContactFeature">
            <summary>
            The features that intersect to form the contact point
            This must be 4 bytes or less.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Collision.ContactFeature.IndexA">
            <summary>
            Feature index on ShapeA
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Collision.ContactFeature.IndexB">
            <summary>
            Feature index on ShapeB
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Collision.ContactFeature.TypeA">
            <summary>
            The feature type on ShapeA
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Collision.ContactFeature.TypeB">
            <summary>
            The feature type on ShapeB
            </summary>
        </member>
        <member name="T:Robust.Shared.Physics.Collision.ContactID">
            <summary>
            Contact ids to facilitate warm starting.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Collision.ContactID.Features">
            <summary>
            The features that intersect to form the contact point
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Collision.ContactID.Key">
            <summary>
            Used to quickly compare contact ids.
            </summary>
        </member>
        <member name="T:Robust.Shared.Physics.Collision.Manifold">
            <summary>
            A manifold for two touching convex Shapes.
            Box2D supports multiple types of contact:
            - Clip point versus plane with radius
            - Point versus point with radius (circles)
            The local point usage depends on the manifold type:
            - ShapeType.Circles: the local center of circleA
            - SeparationFunction.FaceA: the center of faceA
            - SeparationFunction.FaceB: the center of faceB
            Similarly the local normal usage:
            - ShapeType.Circles: not used
            - SeparationFunction.FaceA: the normal on polygonA
            - SeparationFunction.FaceB: the normal on polygonB
            We store contacts in this way so that position correction can
            account for movement, which is critical for continuous physics.
            All contact scenarios must be expressed in one of these types.
            This structure is stored across time steps, so we keep it small.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Collision.Manifold.LocalPoint">
            <summary>
                Usage depends on manifold type.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Collision.Manifold.Points">
            <summary>
                Points of contact, can only be 0 -> 2.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Collision.ManifoldPoint.Id">
            <summary>
                Unique identifier for the contact point between 2 shapes.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Collision.ManifoldPoint.LocalPoint">
            <summary>
                Usage depends on manifold type.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Collision.ManifoldPoint.NormalImpulse">
            <summary>
                The non-penetration impulse.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Collision.ManifoldPoint.TangentImpulse">
            <summary>
                Friction impulse.
            </summary>
        </member>
        <member name="T:Robust.Shared.Physics.Collision.PointState">
            <summary>
            This is used for determining the state of contact points.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Collision.PointState.Null">
            <summary>
            Point does not exist
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Collision.PointState.Add">
            <summary>
            Point was added in the update
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Collision.PointState.Persist">
            <summary>
            Point persisted across the update
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Collision.PointState.Remove">
            <summary>
            Point was removed in the update
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Collision.Shapes.ChainShape.CreateLoop(System.Numerics.Vector2,System.Single,System.Boolean,System.Single)">
            <summary>
            Creates a circular loop with the specified radius.
            </summary>
            <param name="position"></param>
            <param name="radius"></param>
            <param name="outer">Does the chain block the outside (CCW) or inside (CW).</param>
            <param name="count">How many multiply radius by count to get total edges.</param>
        </member>
        <member name="M:Robust.Shared.Physics.Collision.Shapes.ChainShape.CreateLoop(System.ReadOnlySpan{System.Numerics.Vector2})">
            <summary>
            Creates a chain loop with the specified vertices and count.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Collision.Shapes.ChainShape.InternalCopy(Robust.Shared.Physics.Collision.Shapes.ChainShape@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Collision.Shapes.ChainShape.Copy(Robust.Shared.Physics.Collision.Shapes.ChainShape@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Collision.Shapes.ChainShape.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Collision.Shapes.ChainShape.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="F:Robust.Shared.Physics.Collision.Shapes.EdgeShape.Vertex1">
            <summary>
                Edge start vertex
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Collision.Shapes.EdgeShape.Vertex2">
            <summary>
                Edge end vertex
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Collision.Shapes.EdgeShape.#ctor(System.Numerics.Vector2,System.Numerics.Vector2)">
            <summary>
                Create a 1-sided edge.
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
        </member>
        <member name="M:Robust.Shared.Physics.Collision.Shapes.EdgeShape.SetTwoSided(System.Numerics.Vector2,System.Numerics.Vector2)">
            <summary>
            Set this as an isolated edge.
            </summary>
            <param name="start">The start.</param>
            <param name="end">The end.</param>
        </member>
        <member name="M:Robust.Shared.Physics.Collision.Shapes.EdgeShape.InternalCopy(Robust.Shared.Physics.Collision.Shapes.EdgeShape@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Collision.Shapes.EdgeShape.Copy(Robust.Shared.Physics.Collision.Shapes.EdgeShape@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Collision.Shapes.EdgeShape.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Collision.Shapes.EdgeShape.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Shared.Physics.Collision.Shapes.IPhysShape">
            <summary>
            A primitive physical shape that is used by a <see cref="T:Robust.Shared.Physics.Components.PhysicsComponent"/>.
            </summary>
        </member>
        <member name="P:Robust.Shared.Physics.Collision.Shapes.IPhysShape.ChildCount">
            <summary>
                Get the number of child primitives. Only relevant for chain shape.
            </summary>
        </member>
        <member name="P:Robust.Shared.Physics.Collision.Shapes.IPhysShape.Radius">
            <summary>
            Radius of the Shape
            Changing the radius causes a recalculation of shape properties.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Collision.Shapes.IPhysShape.ComputeAABB(Robust.Shared.Physics.Transform,System.Int32)">
            <summary>
            Calculate the AABB of the shape.
            </summary>
        </member>
        <member name="T:Robust.Shared.Physics.Collision.Shapes.PhysShapeAabb">
            <summary>
            A physics shape that represents an Axis-Aligned Bounding Box.
            This box does not rotate with the entity, and will always be offset from the
            entity origin in world space.
            </summary>
        </member>
        <member name="P:Robust.Shared.Physics.Collision.Shapes.PhysShapeAabb.Radius">
            <summary>
            The radius of this AABB
            </summary>
        </member>
        <member name="P:Robust.Shared.Physics.Collision.Shapes.PhysShapeAabb.LocalBounds">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Physics.Collision.Shapes.PhysShapeAabb.InternalCopy(Robust.Shared.Physics.Collision.Shapes.PhysShapeAabb@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Collision.Shapes.PhysShapeAabb.Copy(Robust.Shared.Physics.Collision.Shapes.PhysShapeAabb@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Collision.Shapes.PhysShapeAabb.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Collision.Shapes.PhysShapeAabb.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Shared.Physics.Collision.Shapes.PhysShapeCircle">
            <summary>
            A physics shape that represents a circle. The circle cannot be rotated,
            and it's origin is always the same as the entity position.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Collision.Shapes.PhysShapeCircle.InternalCopy(Robust.Shared.Physics.Collision.Shapes.PhysShapeCircle@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Collision.Shapes.PhysShapeCircle.Copy(Robust.Shared.Physics.Collision.Shapes.PhysShapeCircle@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Collision.Shapes.PhysShapeCircle.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Collision.Shapes.PhysShapeCircle.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="P:Robust.Shared.Physics.Collision.Shapes.PolygonShape.Radius">
            <summary>
            The radius of this polygon.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Collision.Shapes.PolygonShape.InternalCopy(Robust.Shared.Physics.Collision.Shapes.PolygonShape@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Collision.Shapes.PolygonShape.Copy(Robust.Shared.Physics.Collision.Shapes.PolygonShape@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Collision.Shapes.PolygonShape.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Collision.Shapes.PolygonShape.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Shared.Physics.Collision.SimplexCache">
            <summary>
            Used to warm start ComputeDistance.
            Set count to zero on first call.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Collision.SimplexCache.Count">
            <summary>
            Length or area
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Collision.SimplexCache.IndexA">
            <summary>
            Vertices on shape A
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Collision.SimplexCache.IndexB">
            <summary>
            Vertices on shape B
            </summary>
        </member>
        <member name="T:Robust.Shared.Physics.PhysicsHull">
            <summary>
            Convex hull used for poly collision.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.PhysicsHull.#ctor">
            <summary>
            Convex hull used for poly collision.
            </summary>
        </member>
        <member name="T:Robust.Shared.Physics.Components.FixturesChangeComponent">
            <summary>
            Adds / removes fixtures on startup / shutdown without modifying the other fixtures on the entity.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Components.FixturesChangeComponent.InternalCopy(Robust.Shared.Physics.Components.FixturesChangeComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Components.FixturesChangeComponent.Copy(Robust.Shared.Physics.Components.FixturesChangeComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Components.FixturesChangeComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Components.FixturesChangeComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Components.FixturesChangeComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Components.FixturesChangeComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Components.FixturesChangeComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="F:Robust.Shared.Physics.Components.Gravity2DComponent.Gravity">
            <summary>
            Applies side-view gravity to the map.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Components.Gravity2DComponent.InternalCopy(Robust.Shared.Physics.Components.Gravity2DComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Components.Gravity2DComponent.Copy(Robust.Shared.Physics.Components.Gravity2DComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Components.Gravity2DComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Components.Gravity2DComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Components.Gravity2DComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Components.Gravity2DComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Components.Gravity2DComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Shared.Physics.Components.JointRelayTargetComponent">
            <summary>
            Does this entity have joint data relayed from elsewhere.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Components.JointRelayTargetComponent.InternalCopy(Robust.Shared.Physics.Components.JointRelayTargetComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Components.JointRelayTargetComponent.Copy(Robust.Shared.Physics.Components.JointRelayTargetComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Components.JointRelayTargetComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Components.JointRelayTargetComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Components.JointRelayTargetComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Components.JointRelayTargetComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Components.JointRelayTargetComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="F:Robust.Shared.Physics.Components.PhysicsComponent.Island">
            <summary>
                Has this body been added to an island previously in this tick.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Components.PhysicsComponent.IslandIndex">
            <summary>
                Store the body's index within the island so we can lookup its data.
                Key is Island's ID and value is our index.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Components.PhysicsComponent.Contacts">
            <summary>
                Linked-list of all of our contacts.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Components.PhysicsComponent.SleepingAllowed">
            <summary>
            You can disable sleeping on this body. If you disable sleeping, the
            body will be woken.
            </summary>
            <value><c>true</c> if sleeping is allowed; otherwise, <c>false</c>.</value>
        </member>
        <member name="F:Robust.Shared.Physics.Components.PhysicsComponent.CanCollide">
            <summary>
                Enables or disabled collision processing of this component.
            </summary>
            <remarks>
                Also known as Enabled in Box2D
            </remarks>
        </member>
        <member name="P:Robust.Shared.Physics.Components.PhysicsComponent.Hard">
            <summary>
                Non-hard physics bodies will not cause action collision (e.g. blocking of movement)
                while still raising collision events. Recommended you use the fixture hard values directly
            </summary>
            <remarks>
                This is useful for triggers or such to detect collision without actually causing a blockage.
            </remarks>
        </member>
        <member name="P:Robust.Shared.Physics.Components.PhysicsComponent.CollisionLayer">
            <summary>
                Bitmask of the collision layers this component is a part of.
            </summary>
        </member>
        <member name="P:Robust.Shared.Physics.Components.PhysicsComponent.CollisionMask">
            <summary>
                Bitmask of the layers this component collides with.
            </summary>
        </member>
        <member name="P:Robust.Shared.Physics.Components.PhysicsComponent.FixturesMass">
            <summary>
                The current total mass of the entities fixtures in kilograms. Ignores the body type.
            </summary>
        </member>
        <member name="P:Robust.Shared.Physics.Components.PhysicsComponent.Mass">
            <summary>
                Current mass of the entity in kilograms. This may be 0 depending on the body type.
            </summary>
        </member>
        <member name="P:Robust.Shared.Physics.Components.PhysicsComponent.InvMass">
            <summary>
                Inverse mass of the entity in kilograms (1 / Mass).
            </summary>
        </member>
        <member name="P:Robust.Shared.Physics.Components.PhysicsComponent.Inertia">
            <summary>
            Moment of inertia, or angular mass, in kg * m^2.
            </summary>
            <remarks>
            https://en.wikipedia.org/wiki/Moment_of_inertia
            </remarks>
        </member>
        <member name="F:Robust.Shared.Physics.Components.PhysicsComponent.IgnoreGravity">
            <summary>
                Indicates whether this body ignores gravity
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Components.PhysicsComponent.InvI">
            <summary>
            Inverse moment of inertia (1 / I).
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Components.PhysicsComponent.FixedRotation">
            <summary>
                Is the body allowed to have angular velocity.
            </summary>
        </member>
        <member name="P:Robust.Shared.Physics.Components.PhysicsComponent.LocalCenter">
            <summary>
                Get this body's center of mass offset to world position.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Components.PhysicsComponent.Force">
            <summary>
            Current Force being applied to this entity in Newtons.
            </summary>
            <remarks>
            The force is applied to the center of mass.
            https://en.wikipedia.org/wiki/Force
            </remarks>
        </member>
        <member name="F:Robust.Shared.Physics.Components.PhysicsComponent.Torque">
            <summary>
            Current torque being applied to this entity in N*m.
            </summary>
            <remarks>
            The torque rotates around the Z axis on the object.
            https://en.wikipedia.org/wiki/Torque
            </remarks>
        </member>
        <member name="P:Robust.Shared.Physics.Components.PhysicsComponent.Friction">
            <summary>
                Contact friction between 2 bodies.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Components.PhysicsComponent.LinearDamping">
            <summary>
                This is a set amount that the body's linear velocity is reduced by every tick.
                Combined with the tile friction.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Components.PhysicsComponent.AngularDamping">
            <summary>
                This is a set amount that the body's angular velocity is reduced every tick.
                Combined with the tile friction.
            </summary>
            <returns></returns>
        </member>
        <member name="F:Robust.Shared.Physics.Components.PhysicsComponent.LinearVelocity">
            <summary>
                Current linear velocity of the entity in meters per second.
            </summary>
            <remarks>
                This is the velocity relative to the parent, but is defined in terms of map coordinates. I.e., if the
                entity's parents are all stationary, this is the rate of change of this entity's world position (not
                local position).
            </remarks>
        </member>
        <member name="F:Robust.Shared.Physics.Components.PhysicsComponent.AngularVelocity">
            <summary>
                Current angular velocity of the entity in radians per sec.
            </summary>
        </member>
        <member name="P:Robust.Shared.Physics.Components.PhysicsComponent.Momentum">
            <summary>
                Current momentum of the entity in kilogram meters per second
            </summary>
        </member>
        <member name="P:Robust.Shared.Physics.Components.PhysicsComponent.BodyStatus">
            <summary>
                The current status of the object
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Components.PhysicsComponent.InternalCopy(Robust.Shared.Physics.Components.PhysicsComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Components.PhysicsComponent.Copy(Robust.Shared.Physics.Components.PhysicsComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Components.PhysicsComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Components.PhysicsComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Components.PhysicsComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Components.PhysicsComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Components.PhysicsComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Shared.Physics.ComponentTreeEntry`1">
            <summary>
                This is a data struct for use with a <see cref="T:Robust.Shared.Physics.DynamicTree"/>. This stores both some generic component and the
                entity's transform component. This is being used in place of a simple tuple so that the IEquatable can be
                overriden, such that we can remove entries without needing to fetch the transform component of a possible
                deleted entity.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Controllers.VirtualController.UpdateBeforeSolve(System.Boolean,System.Single)">
            <summary>
                Run before any map processing starts.
            </summary>
            <param name="prediction"></param>
            <param name="frameTime"></param>
        </member>
        <member name="M:Robust.Shared.Physics.Controllers.VirtualController.UpdateAfterSolve(System.Boolean,System.Single)">
            <summary>
                Run after all map processing has finished.
            </summary>
            <param name="prediction"></param>
            <param name="frameTime"></param>
        </member>
        <member name="M:Robust.Shared.Physics.Controllers.VirtualController.UpdateBeforeMapSolve(System.Boolean,Robust.Shared.Physics.Dynamics.PhysicsMapComponent,System.Single)">
            <summary>
                Run before a particular map starts.
            </summary>
            <param name="prediction"></param>
            <param name="mapComponent"></param>
            <param name="frameTime"></param>
        </member>
        <member name="M:Robust.Shared.Physics.Controllers.VirtualController.UpdateAfterMapSolve(System.Boolean,Robust.Shared.Physics.Dynamics.PhysicsMapComponent,System.Single)">
            <summary>
                Run after a particular map finishes.
            </summary>
            <param name="prediction"></param>
            <param name="mapComponent"></param>
            <param name="frameTime"></param>
        </member>
        <member name="F:Robust.Shared.Physics.Dynamics.Contacts.Contact.MapNode">
            <summary>
            The node of this contact on the map.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Dynamics.Contacts.Contact.BodyANode">
            <summary>
            The node of this contact on body A.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Dynamics.Contacts.Contact.BodyBNode">
            <summary>
            The node of this contact on body A.
            </summary>
        </member>
        <member name="P:Robust.Shared.Physics.Dynamics.Contacts.Contact.IsTouching">
            <summary>
                Determines whether the contact is touching.
            </summary>
        </member>
        <member name="P:Robust.Shared.Physics.Dynamics.Contacts.Contact.Enabled">
            Enable/disable this contact. This can be used inside the pre-solve
            contact listener. The contact is only disabled for the current
            time step (or sub-step in continuous collisions).
        </member>
        <member name="P:Robust.Shared.Physics.Dynamics.Contacts.Contact.ChildIndexA">
            <summary>
                Get the child primitive index for fixture A.
            </summary>
        </member>
        <member name="P:Robust.Shared.Physics.Dynamics.Contacts.Contact.ChildIndexB">
            <summary>
                Get the child primitive index for fixture B.
            </summary>
        </member>
        <member name="P:Robust.Shared.Physics.Dynamics.Contacts.Contact.Friction">
            <summary>
                The mixed friction of the 2 fixtures.
            </summary>
        </member>
        <member name="P:Robust.Shared.Physics.Dynamics.Contacts.Contact.Restitution">
            <summary>
                The mixed restitution of the 2 fixtures.
            </summary>
        </member>
        <member name="P:Robust.Shared.Physics.Dynamics.Contacts.Contact.TangentSpeed">
            <summary>
                Used for conveyor belt behavior in m/s.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Contacts.Contact.GetWorldManifold(Robust.Shared.Physics.Transform,Robust.Shared.Physics.Transform,System.Numerics.Vector2@,System.Span{System.Numerics.Vector2})">
            <summary>
            Gets the world manifold.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Contacts.Contact.Update(Robust.Shared.Physics.Transform,Robust.Shared.Physics.Transform,System.Boolean@)">
            <summary>
            Update the contact manifold and touching status.
            Note: do not assume the fixture AABBs are overlapping or are valid.
            </summary>
            <param name="wake">Whether we should wake the bodies due to touching changing.</param>
            <returns>What current status of the contact is (e.g. start touching, end touching, etc.)</returns>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Contacts.Contact.UpdateIsTouching(Robust.Shared.Physics.Transform,Robust.Shared.Physics.Transform)">
            <summary>
            Trimmed down version of <see cref="M:Robust.Shared.Physics.Dynamics.Contacts.Contact.Update(Robust.Shared.Physics.Transform,Robust.Shared.Physics.Transform,System.Boolean@)"/> that only updates whether or not the contact's shapes are
            touching.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Contacts.Contact.Evaluate(Robust.Shared.Physics.Collision.Manifold@,Robust.Shared.Physics.Transform@,Robust.Shared.Physics.Transform@)">
            <summary>
                Evaluate this contact with your own manifold and transforms.
            </summary>
            <param name="manifold">The manifold.</param>
            <param name="transformA">The first transform.</param>
            <param name="transformB">The second transform.</param>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Contacts.Contact.OtherEnt(Robust.Shared.GameObjects.EntityUid)">
            <summary>
            Gets the other ent for this contact.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Dynamics.Contacts.ContactFlags.PreInit">
            <summary>
            Is the contact pending its first manifold generation.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Dynamics.Contacts.ContactFlags.Island">
            <summary>
                Has this contact already been added to an island?
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Dynamics.Contacts.ContactFlags.Filter">
            <summary>
                Does this contact need re-filtering?
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Dynamics.Contacts.ContactFlags.Grid">
            <summary>
            Is this a special contact for grid-grid collisions
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Dynamics.Contacts.ContactFlags.Deleting">
            <summary>
            Set right before the contact is deleted
            </summary>
        </member>
        <member name="P:Robust.Shared.Physics.Dynamics.Contacts.ContactPositionConstraint.IndexA">
            <summary>
                Index of BodyA in the island.
            </summary>
        </member>
        <member name="P:Robust.Shared.Physics.Dynamics.Contacts.ContactPositionConstraint.IndexB">
            <summary>
                Index of BodyB in the island.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Dynamics.Contacts.ContactVelocityConstraint.IndexA">
            <summary>
                Index of BodyA in the island.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Dynamics.Contacts.ContactVelocityConstraint.IndexB">
            <summary>
                Index of BodyB in the island.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Dynamics.Fixture.Contacts">
            <summary>
            All of the other fixtures this fixture has a contact with.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Dynamics.Fixture.Friction">
            <summary>
            Contact friction between 2 bodies. Not tile-friction for top-down.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Dynamics.Fixture.Restitution">
            <summary>
            AKA how much bounce there is on a collision.
            0.0 for inelastic collision and 1.0 for elastic.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Dynamics.Fixture.Hard">
            <summary>
                Non-hard <see cref="T:Robust.Shared.Physics.Components.PhysicsComponent"/>s will not cause action collision (e.g. blocking of movement)
                while still raising collision events.
            </summary>
            <remarks>
                This is useful for triggers or such to detect collision without actually causing a blockage.
            </remarks>
        </member>
        <member name="F:Robust.Shared.Physics.Dynamics.Fixture.Density">
            <summary>
            In kg / m ^ 2
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Dynamics.Fixture.CollisionLayer">
            <summary>
            Bitmask of the collision layers the component is a part of.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Dynamics.Fixture.CollisionMask">
            <summary>
             Bitmask of the layers this component collides with.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Fixture.CopyTo(Robust.Shared.Physics.Dynamics.Fixture)">
            <summary>
                As a bunch of things aren't serialized we need to instantiate Fixture from an empty ctor and then copy values across.
            </summary>
            <param name="fixture"></param>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Fixture.Equivalent(Robust.Shared.Physics.Dynamics.Fixture)">
            <summary>
            Returns true if equal apart from body reference.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Fixture.InternalCopy(Robust.Shared.Physics.Dynamics.Fixture@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Fixture.Copy(Robust.Shared.Physics.Dynamics.Fixture@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Fixture.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Fixture.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Shared.Physics.Dynamics.CollisionLayer">
            <summary>
            Tag type for defining the representation of the collision layer bitmask
            in terms of readable names in the content. To understand more about the
            point of this type, see the <see cref="T:Robust.Shared.Serialization.FlagsForAttribute"/>.
            </summary>
        </member>
        <member name="T:Robust.Shared.Physics.Dynamics.CollisionMask">
            <summary>
            Tag type for defining the representation of the collision mask bitmask
            in terms of readable names in the content. To understand more about the
            point of this type, see the <see cref="T:Robust.Shared.Serialization.FlagsForAttribute"/>.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Dynamics.FixtureProxy.AABB">
            <summary>
                Grid-based AABB of this proxy.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Dynamics.FixtureProxy.Fixture">
            <summary>
                Our parent fixture
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Dynamics.FixtureProxy.ProxyId">
            <summary>
                ID of this proxy in the broadphase dynamictree.
            </summary>
        </member>
        <member name="T:Robust.Shared.Physics.Dynamics.Joints.DistanceJoint">
            <summary>
            A distance joint rains two points on two bodies
            to remain at a fixed distance from each other. You can view
            this as a massless, rigid rod.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Joints.DistanceJoint.#ctor(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.EntityUid,System.Numerics.Vector2,System.Numerics.Vector2,System.Single)">
            <summary>
            This requires defining an
            anchor point on both bodies and the non-zero length of the
            distance joint. If you don't supply a length, the local anchor points
            is used so that the initial configuration can violate the constraint
            slightly. This helps when saving and loading a game.
            Warning Do not use a zero or short length.
            </summary>
        </member>
        <member name="P:Robust.Shared.Physics.Dynamics.Joints.DistanceJoint.Length">
            <summary>
            The natural length between the anchor points.
            Manipulating the length can lead to non-physical behavior when the frequency is zero.
            </summary>
        </member>
        <member name="P:Robust.Shared.Physics.Dynamics.Joints.DistanceJoint.MaxLength">
            <summary>
                The upper limit allowed between the 2 bodies.
            </summary>
        </member>
        <member name="P:Robust.Shared.Physics.Dynamics.Joints.DistanceJoint.MinLength">
            <summary>
                The lower limit allowed between the 2 bodies.
            </summary>
        </member>
        <member name="P:Robust.Shared.Physics.Dynamics.Joints.DistanceJoint.Stiffness">
            <summary>
            The linear stiffness in N/m.
            </summary>
        </member>
        <member name="P:Robust.Shared.Physics.Dynamics.Joints.DistanceJoint.Damping">
            <summary>
            The linear damping in N*s/m.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Joints.DistanceJoint.GetReactionForce(System.Single)">
            <summary>
            Get the reaction force given the inverse time step. Unit is N.
            </summary>
            <param name="invDt"></param>
            <returns></returns>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Joints.DistanceJoint.GetReactionTorque(System.Single)">
            <summary>
            Get the reaction torque given the inverse time step.
            Unit is N*m. This is always zero for a distance joint.
            </summary>
            <param name="invDt"></param>
            <returns></returns>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Joints.DistanceJoint.InternalCopy(Robust.Shared.Physics.Dynamics.Joints.DistanceJoint@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Joints.DistanceJoint.Copy(Robust.Shared.Physics.Dynamics.Joints.DistanceJoint@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Joints.DistanceJoint.Copy(Robust.Shared.Physics.Dynamics.Joints.Joint@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Joints.DistanceJoint.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Joints.DistanceJoint.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Shared.Physics.Dynamics.Joints.FrictionJoint">
            <summary>
            Friction joint. This is used for top-down friction.
            It provides 2D translational friction and angular friction.
            </summary>
        </member>
        <member name="P:Robust.Shared.Physics.Dynamics.Joints.FrictionJoint.MaxForce">
            <summary>
                The maximum friction force in N.
            </summary>
        </member>
        <member name="P:Robust.Shared.Physics.Dynamics.Joints.FrictionJoint.MaxTorque">
            <summary>
                The maximum friction torque in N-m.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Joints.FrictionJoint.InternalCopy(Robust.Shared.Physics.Dynamics.Joints.FrictionJoint@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Joints.FrictionJoint.Copy(Robust.Shared.Physics.Dynamics.Joints.FrictionJoint@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Joints.FrictionJoint.Copy(Robust.Shared.Physics.Dynamics.Joints.Joint@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Joints.FrictionJoint.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Joints.FrictionJoint.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="P:Robust.Shared.Physics.Dynamics.Joints.Joint.ID">
            <summary>
            Network identifier of this joint.
            </summary>
        </member>
        <member name="P:Robust.Shared.Physics.Dynamics.Joints.Joint.Enabled">
            <summary>
            Indicate if this joint is enabled or not. Disabling a joint
            means it is still in the simulation, but inactive.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Dynamics.Joints.Joint.IslandFlag">
            <summary>
                Has this joint already been added to an island.
            </summary>
        </member>
        <member name="P:Robust.Shared.Physics.Dynamics.Joints.Joint.JointType">
            <summary>
                Gets the type of the joint.
            </summary>
            <value>The type of the joint.</value>
        </member>
        <member name="P:Robust.Shared.Physics.Dynamics.Joints.Joint.CollideConnected">
            <summary>
                Set this flag to true if the attached bodies should collide.
            </summary>
        </member>
        <member name="P:Robust.Shared.Physics.Dynamics.Joints.Joint.Breakpoint">
            <summary>
                The Breakpoint simply indicates the maximum Value the JointError can be before it breaks.
                The default value is float.MaxValue, which means it never breaks.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Joints.Joint.GetOther(Robust.Shared.GameObjects.EntityUid)">
            <summary>
            Gets the other entity on this joint or throws if it's not related.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Joints.Joint.GetState(Robust.Shared.Physics.Dynamics.Joints.JointState,Robust.Shared.GameObjects.IEntityManager)">
            <summary>
            Applies our properties to the provided state
            </summary>
            <param name="state"></param>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Joints.Joint.GetReactionForce(System.Single)">
            <summary>
            Get the reaction force on body at the joint anchor in Newtons.
            </summary>
            <param name="invDt">The inverse delta time.</param>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Joints.Joint.GetReactionTorque(System.Single)">
            <summary>
            Get the reaction torque on the body at the joint anchor in N*m.
            </summary>
            <param name="invDt">The inverse delta time.</param>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Joints.Joint.SolvePositionConstraints(Robust.Shared.Physics.Dynamics.SolverData@,System.Numerics.Vector2[],System.Single[])">
            <summary>
            Solves the position constraints.
            </summary>
            <returns>returns true if the position errors are within tolerance.</returns>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Joints.Joint.Clone">
            <summary>
            Copies the networked data for a joint. Does not copy warmstarting.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Joints.Joint.CopyTo(Robust.Shared.Physics.Dynamics.Joints.Joint)">
            <summary>
            Copies all joint data including warm starting.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Joints.Joint.InternalCopy(Robust.Shared.Physics.Dynamics.Joints.Joint@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Joints.Joint.Copy(Robust.Shared.Physics.Dynamics.Joints.Joint@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Joints.Joint.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Joints.Joint.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Shared.Physics.Dynamics.Joints.JointEdge">
            <summary>
            A joint edge is used to connect bodies and joints together
            in a joint graph where each body is a node and each joint
            is an edge. A joint edge belongs to a doubly linked list
            maintained in each attached body. Each joint has two joint
            nodes, one for each attached body.
            </summary>
        </member>
        <member name="P:Robust.Shared.Physics.Dynamics.Joints.JointEdge.Joint">
            <summary>
            The joint.
            </summary>
        </member>
        <member name="P:Robust.Shared.Physics.Dynamics.Joints.JointEdge.Next">
            <summary>
            The next joint edge in the body's joint list.
            </summary>
        </member>
        <member name="P:Robust.Shared.Physics.Dynamics.Joints.JointEdge.Other">
            <summary>
            Provides quick access to the other body attached.
            </summary>
        </member>
        <member name="P:Robust.Shared.Physics.Dynamics.Joints.JointEdge.Prev">
            <summary>
            The previous joint edge in the body's joint list.
            </summary>
        </member>
        <member name="P:Robust.Shared.Physics.Dynamics.Joints.MouseJoint.MaxForce">
            <summary>
            The maximum constraint force that can be exerted
            to move the candidate body. Usually you will express
            as some multiple of the weight (multiplier * mass * gravity).
            </summary>
        </member>
        <member name="P:Robust.Shared.Physics.Dynamics.Joints.MouseJoint.Stiffness">
            <summary>
            The linear stiffness in N/m.
            </summary>
        </member>
        <member name="P:Robust.Shared.Physics.Dynamics.Joints.MouseJoint.Damping">
            <summary>
            The linear damping in N*s/m.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Joints.MouseJoint.InternalCopy(Robust.Shared.Physics.Dynamics.Joints.MouseJoint@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Joints.MouseJoint.Copy(Robust.Shared.Physics.Dynamics.Joints.MouseJoint@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Joints.MouseJoint.Copy(Robust.Shared.Physics.Dynamics.Joints.Joint@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Joints.MouseJoint.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Joints.MouseJoint.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="F:Robust.Shared.Physics.Dynamics.Joints.PrismaticJointState.LocalAxisA">
            The local translation unit axis in bodyA.
        </member>
        <member name="F:Robust.Shared.Physics.Dynamics.Joints.PrismaticJointState.ReferenceAngle">
            The constrained angle between the bodies: bodyB_angle - bodyA_angle.
        </member>
        <member name="F:Robust.Shared.Physics.Dynamics.Joints.PrismaticJointState.EnableLimit">
            Enable/disable the joint limit.
        </member>
        <member name="F:Robust.Shared.Physics.Dynamics.Joints.PrismaticJointState.LowerTranslation">
            The lower translation limit, usually in meters.
        </member>
        <member name="F:Robust.Shared.Physics.Dynamics.Joints.PrismaticJointState.UpperTranslation">
            The upper translation limit, usually in meters.
        </member>
        <member name="F:Robust.Shared.Physics.Dynamics.Joints.PrismaticJointState.EnableMotor">
            Enable/disable the joint motor.
        </member>
        <member name="F:Robust.Shared.Physics.Dynamics.Joints.PrismaticJointState.MaxMotorForce">
            The maximum motor torque, usually in N-m.
        </member>
        <member name="F:Robust.Shared.Physics.Dynamics.Joints.PrismaticJointState.MotorSpeed">
            The desired motor speed in radians per second.
        </member>
        <member name="T:Robust.Shared.Physics.Dynamics.Joints.PrismaticJoint">
            <summary>
            Prismatic joint definition. This requires defining a line of
            motion using an axis and an anchor point. The definition uses local
            anchor points and a local axis so that the initial configuration
            can violate the constraint slightly. The joint translation is zero
            when the local anchor points coincide in world space.
            </summary>
        </member>
        <member name="P:Robust.Shared.Physics.Dynamics.Joints.PrismaticJoint.LocalAxisA">
            <summary>
            The local translation unit axis in bodyA.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Dynamics.Joints.PrismaticJoint.ReferenceAngle">
            <summary>
            The constrained angle between the bodies: bodyB_angle - bodyA_angle.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Dynamics.Joints.PrismaticJoint.EnableLimit">
            <summary>
            Enable/disable the joint limit.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Dynamics.Joints.PrismaticJoint.LowerTranslation">
            <summary>
            The lower translation limit, usually in meters.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Dynamics.Joints.PrismaticJoint.UpperTranslation">
            <summary>
            The upper translation limit, usually in meters.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Dynamics.Joints.PrismaticJoint.EnableMotor">
            <summary>
            Enable/disable the joint motor.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Dynamics.Joints.PrismaticJoint.MaxMotorForce">
            <summary>
            The maximum motor torque, usually in N-m.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Dynamics.Joints.PrismaticJoint.MotorSpeed">
            <summary>
            The desired motor speed in radians per second.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Joints.PrismaticJoint.InternalCopy(Robust.Shared.Physics.Dynamics.Joints.PrismaticJoint@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Joints.PrismaticJoint.Copy(Robust.Shared.Physics.Dynamics.Joints.PrismaticJoint@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Joints.PrismaticJoint.Copy(Robust.Shared.Physics.Dynamics.Joints.Joint@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Joints.PrismaticJoint.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Joints.PrismaticJoint.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="F:Robust.Shared.Physics.Dynamics.Joints.RevoluteJoint.EnableMotor">
            <summary>
            A flag to enable the joint motor.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Dynamics.Joints.RevoluteJoint.ReferenceAngle">
            <summary>
            The bodyB angle minus bodyA angle in the reference state (radians).
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Dynamics.Joints.RevoluteJoint.LowerAngle">
            <summary>
            The lower angle for the joint limit (radians).
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Dynamics.Joints.RevoluteJoint.UpperAngle">
            <summary>
            The upper angle for the joint limit (radians).
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Dynamics.Joints.RevoluteJoint.MotorSpeed">
            <summary>
            The desired motor speed. Usually in radians per second.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Dynamics.Joints.RevoluteJoint.MaxMotorTorque">
            <summary>
            The maximum motor torque used to achieve the desired motor speed.
            Usually in N-m.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Joints.RevoluteJoint.InternalCopy(Robust.Shared.Physics.Dynamics.Joints.RevoluteJoint@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Joints.RevoluteJoint.Copy(Robust.Shared.Physics.Dynamics.Joints.RevoluteJoint@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Joints.RevoluteJoint.Copy(Robust.Shared.Physics.Dynamics.Joints.Joint@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Joints.RevoluteJoint.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Joints.RevoluteJoint.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="F:Robust.Shared.Physics.Dynamics.Joints.WeldJoint.ReferenceAngle">
            <summary>
            The bodyB angle minus bodyA angle in the reference state (radians).
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Joints.WeldJoint.#ctor">
            <summary>
            Used for Serv3 reasons
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Joints.WeldJoint.InternalCopy(Robust.Shared.Physics.Dynamics.Joints.WeldJoint@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Joints.WeldJoint.Copy(Robust.Shared.Physics.Dynamics.Joints.WeldJoint@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Joints.WeldJoint.Copy(Robust.Shared.Physics.Dynamics.Joints.Joint@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Joints.WeldJoint.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Joints.WeldJoint.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="F:Robust.Shared.Physics.Dynamics.MassData.Mass">
            The mass of the shape, usually in kilograms.
        </member>
        <member name="F:Robust.Shared.Physics.Dynamics.MassData.Center">
            The position of the shape's centroid relative to the shape's origin.
        </member>
        <member name="F:Robust.Shared.Physics.Dynamics.MassData.I">
            The rotational inertia of the shape about the local origin.
        </member>
        <member name="T:Robust.Shared.Physics.Dynamics.SolverData">
            <summary>
                Easy way of passing around the data required for the contact solver.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.SolverData.#ctor(System.Single,System.Single,System.Single,System.Boolean,System.Single,System.Single,System.Int32,System.Int32,System.Single,System.Single,System.Single,System.Single,System.Boolean,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
                Easy way of passing around the data required for the contact solver.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Dynamics.PhysicsMapComponent.LerpData">
            <summary>
            When substepping the client needs to know about the first position to use for lerping.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Dynamics.PhysicsMapComponent.MoveBuffer">
            <summary>
            Keep a buffer of everything that moved in a tick. This will be used to check for physics contacts.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Dynamics.PhysicsMapComponent.AwakeBodies">
            <summary>
                All awake bodies on this map.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Dynamics.PhysicsMapComponent._invDt0">
            <summary>
                Store last tick's invDT
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.PhysicsMapComponent.InternalCopy(Robust.Shared.Physics.Dynamics.PhysicsMapComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.PhysicsMapComponent.Copy(Robust.Shared.Physics.Dynamics.PhysicsMapComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.PhysicsMapComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.PhysicsMapComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.PhysicsMapComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.PhysicsMapComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.PhysicsMapComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Shared.Physics.Dynamics.Sweep">
            This describes the motion of a body/shape for TOI computation.
            Shapes are defined with respect to the body origin, which may
            no coincide with the center of mass. However, to support dynamics
            we must interpolate the center of mass position.
        </member>
        <member name="F:Robust.Shared.Physics.Dynamics.Sweep.LocalCenter">
            <summary>
            Local center of mass position
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Dynamics.Sweep.Angle0">
            <summary>
            Fraction of the current time step in the range [0,1]
            c0 and a0 are the positions at alpha0.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Sweep.GetTransform(System.Single)">
            <summary>
            Get the interpolated transform at a specific time.
            </summary>
            <param name="beta">beta is a factor in [0,1], where 0 indicates alpha0.</param>
            <returns>the output transform</returns>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Sweep.Advance(System.Single)">
            <summary>
            Advance the sweep forward, yielding a new initial state.
            </summary>
            <param name="alpha">the new initial time.</param>
        </member>
        <member name="M:Robust.Shared.Physics.Dynamics.Sweep.Normalize">
            <summary>
            Normalize the angles.
            </summary>
        </member>
        <member name="T:Robust.Shared.Physics.Events.CollisionChangeEvent">
            <summary>
                These events are broadcast (not directed) whenever an entity's ability to collide changes.
            </summary>
        </member>
        <member name="T:Robust.Shared.Physics.Events.CollisionLayerChangeEvent">
            <summary>
                These events are broadcast (not directed) whenever an entity's ability to collide changes.
            </summary>
        </member>
        <member name="T:Robust.Shared.Physics.Events.MassDataChangedEvent">
            <summary>
            By-ref directed event raised when the mass or angular inertia or center of mass of a physics body changes.
            </summary>
            <param name="Entity">The physics body that changed.</param>
            <param name="OldMass">The old mass of the physics body.</param>
            <param name="OldInertia">The old angular inertia of the physics body.</param>
            <param name="OldCenter">The old (local) center of mass of the physics body.</param>
        </member>
        <member name="M:Robust.Shared.Physics.Events.MassDataChangedEvent.#ctor(Robust.Shared.GameObjects.Entity{Robust.Shared.Physics.Components.PhysicsComponent,Robust.Shared.Physics.FixturesComponent},System.Single,System.Single,System.Numerics.Vector2)">
            <summary>
            By-ref directed event raised when the mass or angular inertia or center of mass of a physics body changes.
            </summary>
            <param name="Entity">The physics body that changed.</param>
            <param name="OldMass">The old mass of the physics body.</param>
            <param name="OldInertia">The old angular inertia of the physics body.</param>
            <param name="OldCenter">The old (local) center of mass of the physics body.</param>
        </member>
        <member name="P:Robust.Shared.Physics.Events.MassDataChangedEvent.Entity">
            <summary>The physics body that changed.</summary>
        </member>
        <member name="P:Robust.Shared.Physics.Events.MassDataChangedEvent.OldMass">
            <summary>The old mass of the physics body.</summary>
        </member>
        <member name="P:Robust.Shared.Physics.Events.MassDataChangedEvent.OldInertia">
            <summary>The old angular inertia of the physics body.</summary>
        </member>
        <member name="P:Robust.Shared.Physics.Events.MassDataChangedEvent.OldCenter">
            <summary>The old (local) center of mass of the physics body.</summary>
        </member>
        <member name="T:Robust.Shared.Physics.Events.PhysicsBodyTypeChangedEvent">
            <summary>
                Directed event raised when an entity's physics BodyType changes.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Events.PhysicsBodyTypeChangedEvent.New">
            <summary>
                New BodyType of the entity.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Events.PhysicsBodyTypeChangedEvent.Old">
            <summary>
                Old BodyType of the entity.
            </summary>
        </member>
        <member name="T:Robust.Shared.Physics.Events.PreventCollideEvent">
            <summary>
            An event used to prevent a physics collision between two physics bodies.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Events.PreventCollideEvent.OurEntity">
            <summary>
            The entity that this event was directed at. Owner of <see cref="F:Robust.Shared.Physics.Events.PreventCollideEvent.OurBody"/>
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Events.PreventCollideEvent.OtherEntity">
            <summary>
            The other colliding entity. Owner of <see cref="F:Robust.Shared.Physics.Events.PreventCollideEvent.OtherBody"/>
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Events.PreventCollideEvent.OurBody">
            <summary>
            The body of the entity that this event was directed at.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Events.PreventCollideEvent.OtherBody">
            <summary>
            The other body..
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Events.PreventCollideEvent.OurFixture">
            <summary>
            The fixture on the first body to prevent the collision of if specified.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Events.PreventCollideEvent.OtherFixture">
            <summary>
            The fixture on the other body to prevent the collision of if specified.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Events.PreventCollideEvent.Cancelled">
            <summary>
            Whether or not to prevent the collision between the physics bodies.
            </summary>
        </member>
        <member name="T:Robust.Shared.Physics.FixturesComponent">
            <summary>
            Storage for physics fixtures
            </summary>
            <remarks>
            In its own component to decrease physics comp state size significantly.
            </remarks>
        </member>
        <member name="F:Robust.Shared.Physics.FixturesComponent.Fixtures">
            <summary>
            Allows us to reference a specific fixture when we contain multiple
            This is useful for stuff like slippery objects that might have a non-hard layer for mob collisions and
            a hard layer for wall collisions.
            <remarks>
            We can also use this for networking to make cross-referencing fixtures easier.
            Won't call Dirty() by default
            </remarks>
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.FixturesComponent.InternalCopy(Robust.Shared.Physics.FixturesComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.FixturesComponent.Copy(Robust.Shared.Physics.FixturesComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.FixturesComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.FixturesComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.FixturesComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.FixturesComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.FixturesComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Shared.Physics.FixtureSerializer">
            <summary>
            Special-case to avoid writing grid fixtures.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.JointComponent.Relay">
            <summary>
            Are we relaying our joints to a parent entity.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.JointComponent.InternalCopy(Robust.Shared.Physics.JointComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.JointComponent.Copy(Robust.Shared.Physics.JointComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.JointComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.JointComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.JointComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.JointComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Physics.JointComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="F:Robust.Shared.Physics.PhysicsConstants.PolygonRadius">
            <summary>
            The radius of the polygon/edge shape skin. This should not be modified. Making
            this smaller means polygons will have an insufficient buffer for continuous collision.
            Making it larger may create artifacts for vertex collision.
            </summary>
            <remarks>
                Default is set to be 2 x linearslop.
            </remarks>
        </member>
        <member name="F:Robust.Shared.Physics.PhysicsConstants.LinearSlop">
            <summary>
            Minimum buffer distance for positions.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.PhysicsConstants.AngularSlop">
            <summary>
            Minimum buffer distance for angles.
            </summary>
        </member>
        <member name="T:Robust.Shared.Physics.Ray">
            <summary>
                A representation of a 2D ray.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Ray.Position">
            <summary>
                Specifies the starting point of the ray.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Ray.Direction">
            <summary>
                Specifies the direction the ray is pointing.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Ray.#ctor(System.Numerics.Vector2,System.Numerics.Vector2)">
            <summary>
                Creates a new instance of a Ray.
            </summary>
            <param name="position">Starting position of the ray.</param>
            <param name="direction">Unit direction vector that the ray is pointing.</param>
        </member>
        <member name="M:Robust.Shared.Physics.Ray.Equals(Robust.Shared.Physics.Ray)">
            <summary>
                Determines if this Ray and another Ray are equivalent.
            </summary>
            <param name="other">Ray to compare to.</param>
        </member>
        <member name="M:Robust.Shared.Physics.Ray.Equals(System.Object)">
            <summary>
                Determines if this ray and another object is equivalent.
            </summary>
            <param name="obj">Object to compare to.</param>
        </member>
        <member name="M:Robust.Shared.Physics.Ray.GetHashCode">
            <summary>
                Calculates the hash code of this Ray.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Ray.op_Equality(Robust.Shared.Physics.Ray,Robust.Shared.Physics.Ray)">
            <summary>
                Determines if two instances of Ray are equal.
            </summary>
            <param name="a">Ray on the left side of the operator.</param>
            <param name="b">Ray on the right side of the operator.</param>
        </member>
        <member name="M:Robust.Shared.Physics.Ray.op_Inequality(Robust.Shared.Physics.Ray,Robust.Shared.Physics.Ray)">
            <summary>
                Determines if two instances of Ray are not equal.
            </summary>
            <param name="a">Ray on the left side of the operator.</param>
            <param name="b">Ray on the right side of the operator.</param>
        </member>
        <member name="P:Robust.Shared.Physics.RayCastResults.HitEntity">
            <summary>
                The entity that was hit.
            </summary>
        </member>
        <member name="P:Robust.Shared.Physics.RayCastResults.HitPos">
            <summary>
                The point of contact where the entity was hit. Defaults to <see cref="P:System.Numerics.Vector2.Zero"/> if no entity was hit.
            </summary>
        </member>
        <member name="P:Robust.Shared.Physics.RayCastResults.Distance">
            <summary>
                The distance from point of origin to the context point. 0.0f if nothing was hit.
            </summary>
        </member>
        <member name="T:Robust.Shared.Physics.Systems.FixtureSystem">
            <summary>
            Manages physics fixtures.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.FixtureSystem.GetFixtureOrNull(Robust.Shared.GameObjects.EntityUid,System.String,Robust.Shared.Physics.FixturesComponent)">
            <summary>
            Attempts to get the <see cref="T:Robust.Shared.Physics.Dynamics.Fixture"/> with the specified ID for this body.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.FixtureSystem.DestroyFixture(Robust.Shared.GameObjects.EntityUid,System.String,System.Boolean,Robust.Shared.Physics.Components.PhysicsComponent,Robust.Shared.Physics.FixturesComponent,Robust.Shared.GameObjects.TransformComponent)">
            <summary>
            Destroys the specified <see cref="T:Robust.Shared.Physics.Dynamics.Fixture"/> attached to the body.
            </summary>
            <param name="body">The specified body</param>
            <param name="id">The fixture ID</param>
            <param name="updates">Whether to update mass etc. Set false if you're doing a bulk operation</param>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.FixtureSystem.DestroyFixture(Robust.Shared.GameObjects.EntityUid,System.String,Robust.Shared.Physics.Dynamics.Fixture,System.Boolean,Robust.Shared.Physics.Components.PhysicsComponent,Robust.Shared.Physics.FixturesComponent,Robust.Shared.GameObjects.TransformComponent)">
            <summary>
            Destroys the specified <see cref="T:Robust.Shared.Physics.Dynamics.Fixture"/>
            </summary>
            <param name="updates">Whether to update mass etc. Set false if you're doing a bulk operation</param>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.FixtureSystem.FixtureUpdate(Robust.Shared.GameObjects.EntityUid,System.Boolean,System.Boolean,Robust.Shared.Physics.FixturesComponent,Robust.Shared.Physics.Components.PhysicsComponent)">
            <summary>
            Updates all of the cached physics information on the body derived from fixtures.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.FixtureSystem.TestPoint(Robust.Shared.Physics.Collision.Shapes.IPhysShape,Robust.Shared.Physics.Transform,System.Numerics.Vector2)">
            <summary>
            Tests whether a particular point is contained in the shape.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.SharedBroadphaseSystem.FindGridContacts(Robust.Shared.Physics.Dynamics.PhysicsMapComponent,Robust.Shared.Map.MapId,System.Collections.Generic.HashSet{Robust.Shared.GameObjects.EntityUid},System.Collections.Generic.Dictionary{Robust.Shared.Physics.Dynamics.FixtureProxy,Robust.Shared.Maths.Box2})">
            <summary>
            Check the AABB for each moved broadphase fixture and add any colliding entities to the movebuffer in case.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.SharedBroadphaseSystem.FindNewContacts(Robust.Shared.Physics.Dynamics.PhysicsMapComponent,Robust.Shared.Map.MapId)">
            <summary>
            Go through every single created, moved, or touched proxy on the map and try to find any new contacts that should be created.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.SharedJointSystem.CreateDistanceJoint(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.EntityUid,System.Nullable{System.Numerics.Vector2},System.Nullable{System.Numerics.Vector2},System.String,Robust.Shared.GameObjects.TransformComponent,Robust.Shared.GameObjects.TransformComponent)">
            <summary>
            Create a DistanceJoint between 2 bodies. This should be called content-side whenever you need one.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.SharedJointSystem.CreateMouseJoint(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.EntityUid,System.Nullable{System.Numerics.Vector2},System.Nullable{System.Numerics.Vector2},System.String)">
            <summary>
            Create a MouseJoint between 2 bodies. This should be called content-side whenever you need one.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.SharedJointSystem.RecursiveClearJoints(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.TransformComponent,Robust.Shared.Physics.JointComponent,Robust.Shared.Physics.Components.JointRelayTargetComponent)">
            <summary>
            Removes joints on this entity and anything relaying to it.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.SharedJointSystem.ClearJoints(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Physics.JointComponent)">
            <summary>
            Clears any joints for this entity, excluding relayed joints.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.SharedJointSystem.RefreshRelay(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Physics.JointComponent)">
            <summary>
            Refreshes the joint relay for this entity, prefering its containing container or nothing.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.SharedJointSystem.SetRelay(Robust.Shared.GameObjects.EntityUid,System.Nullable{Robust.Shared.GameObjects.EntityUid},Robust.Shared.Physics.JointComponent)">
            <summary>
            Refreshes the joint relay for this entity.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.SharedPhysicsSystem.ResetDynamics(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Physics.Components.PhysicsComponent,System.Boolean)">
            <summary>
            Completely resets a dynamic body.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.SharedPhysicsSystem.SetLinearVelocity(Robust.Shared.GameObjects.EntityUid,System.Numerics.Vector2,System.Boolean,System.Boolean,Robust.Shared.Physics.FixturesComponent,Robust.Shared.Physics.Components.PhysicsComponent)">
            <summary>
            Attempts to set the body to collidable, wake it, then move it.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.SharedPhysicsSystem.SetCanCollide(Robust.Shared.GameObjects.EntityUid,System.Boolean,System.Boolean,System.Boolean,Robust.Shared.Physics.FixturesComponent,Robust.Shared.Physics.Components.PhysicsComponent)">
            <summary>
            Sets the <see cref="F:Robust.Shared.Physics.Components.PhysicsComponent.CanCollide"/> property; this handles whether the body is enabled.
            </summary>
            <returns>CanCollide</returns>
            <param name="force">Bypasses fixture and container checks</param>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.SharedPhysicsSystem.WakeBody(Robust.Shared.GameObjects.EntityUid,System.Boolean,Robust.Shared.Physics.FixturesComponent,Robust.Shared.Physics.Components.PhysicsComponent)">
            <summary>
            Tries to enable the body and also set it awake.
            </summary>
            <param name="force">Bypasses fixture and container checks</param>
            <returns>true if the body is collidable and awake</returns>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.SharedPhysicsSystem.GetRelativePhysicsTransform(Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.TransformComponent},Robust.Shared.GameObjects.Entity{Robust.Shared.GameObjects.TransformComponent})">
            <summary>
            Gets the physics transform relative to another entity.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.SharedPhysicsSystem.GetLocalPhysicsTransform(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.TransformComponent)">
            <summary>
            Gets broadphase relevant transform.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.SharedPhysicsSystem.GetWorldAABB(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Physics.FixturesComponent,Robust.Shared.Physics.Components.PhysicsComponent,Robust.Shared.GameObjects.TransformComponent)">
            <summary>
            Gets the physics World AABB, only considering fixtures.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Systems.SharedPhysicsSystem._registers">
            <summary>
                Ordering is under <see cref="T:Robust.Shared.Physics.Collision.Shapes.ShapeType"/>
                uses enum to work out which collision evaluation to use.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.SharedPhysicsSystem.AddPair(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.EntityUid,System.String,System.String,Robust.Shared.Physics.Dynamics.Fixture,System.Int32,Robust.Shared.Physics.Dynamics.Fixture,System.Int32,Robust.Shared.Physics.Components.PhysicsComponent,Robust.Shared.Physics.Components.PhysicsComponent,Robust.Shared.Physics.Dynamics.Contacts.ContactFlags)">
            <summary>
            Try to create a contact between these 2 fixtures.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.SharedPhysicsSystem.AddPair(System.String,System.String,Robust.Shared.Physics.Dynamics.FixtureProxy@,Robust.Shared.Physics.Dynamics.FixtureProxy@)">
            <summary>
                Go through the cached broadphase movement and update contacts.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.SharedPhysicsSystem.ShouldCollide(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.EntityUid,Robust.Shared.Physics.Components.PhysicsComponent,Robust.Shared.Physics.Components.PhysicsComponent,Robust.Shared.Physics.Dynamics.Fixture,Robust.Shared.Physics.Dynamics.Fixture,Robust.Shared.GameObjects.TransformComponent,Robust.Shared.GameObjects.TransformComponent)">
            <summary>
                Used to prevent bodies from colliding; may lie depending on joints.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.SharedPhysicsSystem.RegenerateContacts(Robust.Shared.GameObjects.Entity{Robust.Shared.Physics.Components.PhysicsComponent})">
            <summary>
            Will destroy all contacts and queue for rebuild.
            Useful if you have one that may no longer be relevant and don't want to destroy it directly.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.SharedPhysicsSystem.GetTouchingContacts(Robust.Shared.GameObjects.Entity{Robust.Shared.Physics.FixturesComponent},System.String)">
            <summary>
            Returns the number of touching contacts this entity has.
            </summary>
            <param name="ignoredFixtureId">Fixture we should ignore if applicable</param>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.SharedPhysicsSystem.GetContacts(Robust.Shared.GameObjects.Entity{Robust.Shared.Physics.FixturesComponent})">
            <summary>
            Returns all of this entity's contacts.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Systems.SharedPhysicsSystem.EffectiveCurTime">
            <summary>
            A variation of <see cref="P:Robust.Shared.Timing.IGameTiming.CurTime"/> that takes into account the current physics sub-step.
            Useful for some entities that need to interpolate their positions during sub-steps.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.SharedPhysicsSystem.HandleMapChange(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.TransformComponent,Robust.Shared.Physics.Components.PhysicsComponent,System.Nullable{Robust.Shared.GameObjects.EntityUid},System.Nullable{Robust.Shared.GameObjects.EntityUid})">
            <summary>
                Recursively add/remove from awake bodies, clear joints, remove from move buffer, and update broadphase.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.SharedPhysicsSystem.RecursiveMapUpdate(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.TransformComponent,Robust.Shared.Physics.Components.PhysicsComponent,Robust.Shared.Physics.Dynamics.PhysicsMapComponent,Robust.Shared.Physics.Dynamics.PhysicsMapComponent)">
            <summary>
                Recursively add/remove from awake bodies, clear joints, remove from move buffer, and update broadphase.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.SharedPhysicsSystem.SimulateWorld(System.Single,System.Boolean)">
            <summary>
                Simulates the physical world for a given amount of time.
            </summary>
            <param name="deltaTime">Delta Time in seconds of how long to simulate the world.</param>
            <param name="prediction">Should only predicted entities be considered in this simulation step?</param>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.SharedPhysicsSystem.IsCurrentlyHardCollidable(Robust.Shared.GameObjects.Entity{Robust.Shared.Physics.FixturesComponent,Robust.Shared.Physics.Components.PhysicsComponent},Robust.Shared.GameObjects.Entity{Robust.Shared.Physics.FixturesComponent,Robust.Shared.Physics.Components.PhysicsComponent})">
            <summary>
            Similar to IsHardCollidable but also checks whether both entities are set to CanCollide
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.SharedPhysicsSystem.IsHardCollidable(Robust.Shared.GameObjects.Entity{Robust.Shared.Physics.FixturesComponent,Robust.Shared.Physics.Components.PhysicsComponent},Robust.Shared.GameObjects.Entity{Robust.Shared.Physics.FixturesComponent,Robust.Shared.Physics.Components.PhysicsComponent})">
            <summary>
            Returns true if both entities are hard-collidable with each other.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Systems.SharedPhysicsSystem._islandJointPool">
            <summary>
            Due to joint relays we need to track the dummy joint and the original joint.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Systems.SharedPhysicsSystem.IslandData.Index">
            <summary>
            Island index to be used for bodies to identify which island they're in.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Systems.SharedPhysicsSystem.IslandData.LoneIsland">
            <summary>
            Are we the special island that has all contact-less bodies in it?
            This is treated separately for sleep purposes.
            </summary>
        </member>
        <member name="F:Robust.Shared.Physics.Systems.SharedPhysicsSystem.IslandData.Offset">
            <summary>
            Offset in the data arrays
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.SharedPhysicsSystem.Step(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Physics.Dynamics.PhysicsMapComponent,System.Single,System.Boolean)">
            <summary>
                Where the magic happens.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.SharedPhysicsSystem.UpdateLerpData(Robust.Shared.Physics.Dynamics.PhysicsMapComponent,System.Collections.Generic.List{Robust.Shared.Physics.Components.PhysicsComponent},Robust.Shared.GameObjects.EntityQuery{Robust.Shared.GameObjects.TransformComponent})">
            <summary>
            If this is the first time a body has been updated this tick update its position for lerping.
            Due to substepping we have to check it every time.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.SharedPhysicsSystem.InternalParallel(Robust.Shared.Physics.Systems.SharedPhysicsSystem.IslandData)">
            <summary>
            Can we run the island in parallel internally, otherwise solve it in parallel with the rest.
            </summary>
            <param name="island"></param>
            <returns></returns>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.SharedPhysicsSystem.SolveIsland(Robust.Shared.Physics.Systems.SharedPhysicsSystem.IslandData@,Robust.Shared.Physics.Dynamics.SolverData@,System.Threading.Tasks.ParallelOptions,System.Numerics.Vector2,System.Boolean,System.Numerics.Vector2[],System.Single[],System.Numerics.Vector2[],System.Single[],System.Boolean[])">
            <summary>
                Go through all the bodies in this island and solve.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.SharedPhysicsSystem.UpdateBodies(Robust.Shared.Physics.Systems.SharedPhysicsSystem.IslandData@,System.Numerics.Vector2[],System.Single[],System.Numerics.Vector2[],System.Single[],Robust.Shared.GameObjects.EntityQuery{Robust.Shared.GameObjects.TransformComponent})">
            <summary>
            Updates the positions, rotations, and velocities of all of the solved bodies.
            Run sequentially to avoid threading issues.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.SharedPhysicsSystem.TryCollideRect(Robust.Shared.Maths.Box2,Robust.Shared.Map.MapId,System.Boolean)">
            <summary>
            Checks to see if the specified collision rectangle collides with any of the physBodies under management.
            Also fires the OnCollide event of the first managed physBody to intersect with the collider.
            </summary>
            <param name="collider">Collision rectangle to check</param>
            <param name="mapId">Map to check on</param>
            <param name="approximate"></param>
            <returns>true if collides, false if not</returns>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.SharedPhysicsSystem.GetEntitiesIntersectingBody(Robust.Shared.GameObjects.EntityUid,System.Int32,System.Boolean,Robust.Shared.Physics.Components.PhysicsComponent,Robust.Shared.Physics.FixturesComponent,Robust.Shared.GameObjects.TransformComponent)">
            <summary>
                Get all the entities whose fixtures intersect the fixtures of the given entity. Basically a variant of
                <see cref="!:GetCollidingEntities(PhysicsComponent, Vector2, bool)"/> that allows the user to specify
                their own collision mask.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.SharedPhysicsSystem.GetCollidingEntities(Robust.Shared.Map.MapId,Robust.Shared.Maths.Box2@)">
            <summary>
            Get all entities colliding with a certain body.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.SharedPhysicsSystem.GetCollidingEntities(Robust.Shared.Map.MapId,Robust.Shared.Maths.Box2Rotated@)">
            <summary>
            Get all entities colliding with a certain body.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.SharedPhysicsSystem.IsInContact(Robust.Shared.Physics.Components.PhysicsComponent,System.Boolean)">
            <summary>
                Checks whether a body is colliding
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.SharedPhysicsSystem.IntersectRayWithPredicate(Robust.Shared.Map.MapId,Robust.Shared.Physics.CollisionRay,System.Single,System.Func{Robust.Shared.GameObjects.EntityUid,System.Boolean},System.Boolean)">
            <summary>
                Casts a ray in the world, returning the first entity it hits (or all entities it hits, if so specified)
            </summary>
            <param name="mapId"></param>
            <param name="ray">Ray to cast in the world.</param>
            <param name="maxLength">Maximum length of the ray in meters.</param>
            <param name="predicate">A predicate to check whether to ignore an entity or not. If it returns true, it will be ignored.</param>
            <param name="returnOnFirstHit">If true, will only include the first hit entity in results. Otherwise, returns all of them.</param>
            <returns>A result object describing the hit, if any.</returns>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.SharedPhysicsSystem.IntersectRayWithPredicate``1(Robust.Shared.Map.MapId,Robust.Shared.Physics.CollisionRay,``0,System.Func{Robust.Shared.GameObjects.EntityUid,``0,System.Boolean},System.Single,System.Boolean)">
            <summary>
                Casts a ray in the world, returning the first entity it hits (or all entities it hits, if so specified)
            </summary>
            <param name="mapId"></param>
            <param name="ray">Ray to cast in the world.</param>
            <param name="maxLength">Maximum length of the ray in meters.</param>
            <param name="state">A custom state to pass to the predicate.</param>
            <param name="predicate">A predicate to check whether to ignore an entity or not. If it returns true, it will be ignored.</param>
            <param name="returnOnFirstHit">If true, will only include the first hit entity in results. Otherwise, returns all of them.</param>
            <remarks>You can avoid variable capture in many cases by using this method and passing a custom state to the predicate.</remarks>
            <returns>A result object describing the hit, if any.</returns>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.SharedPhysicsSystem.IntersectRay(Robust.Shared.Map.MapId,Robust.Shared.Physics.CollisionRay,System.Single,System.Nullable{Robust.Shared.GameObjects.EntityUid},System.Boolean)">
            <summary>
                Casts a ray in the world and returns the first entity it hits, or a list of all entities it hits.
            </summary>
            <param name="mapId"></param>
            <param name="ray">Ray to cast in the world.</param>
            <param name="maxLength">Maximum length of the ray in meters.</param>
            <param name="ignoredEnt">A single entity that can be ignored by the RayCast. Useful if the ray starts inside the body of an entity.</param>
            <param name="returnOnFirstHit">If false, will return a list of everything it hits, otherwise will just return a list of the first entity hit</param>
            <returns>An enumerable of either the first entity hit or everything hit</returns>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.SharedPhysicsSystem.IntersectRayPenetration(Robust.Shared.Map.MapId,Robust.Shared.Physics.CollisionRay,System.Single,System.Nullable{Robust.Shared.GameObjects.EntityUid})">
            <summary>
                Casts a ray in the world and returns the distance the ray traveled while colliding with entities
            </summary>
            <param name="mapId"></param>
            <param name="ray">Ray to cast in the world.</param>
            <param name="maxLength">Maximum length of the ray in meters.</param>
            <param name="ignoredEnt">A single entity that can be ignored by the RayCast. Useful if the ray starts inside the body of an entity.</param>
            <returns>The distance the ray traveled while colliding with entities</returns>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.SharedPhysicsSystem.TryGetDistance(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.EntityUid,System.Single@,Robust.Shared.GameObjects.TransformComponent,Robust.Shared.GameObjects.TransformComponent,Robust.Shared.Physics.FixturesComponent,Robust.Shared.Physics.FixturesComponent,Robust.Shared.Physics.Components.PhysicsComponent,Robust.Shared.Physics.Components.PhysicsComponent)">
            <summary>
            Gets the nearest distance of 2 entities, ignoring any sensor proxies.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.SharedPhysicsSystem.TryGetNearestPoints(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.EntityUid,System.Numerics.Vector2@,System.Numerics.Vector2@,Robust.Shared.GameObjects.TransformComponent,Robust.Shared.GameObjects.TransformComponent,Robust.Shared.Physics.FixturesComponent,Robust.Shared.Physics.FixturesComponent,Robust.Shared.Physics.Components.PhysicsComponent,Robust.Shared.Physics.Components.PhysicsComponent)">
            <summary>
            Get the nearest non-sensor points on entity A and entity B to each other.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.SharedPhysicsSystem.TryGetNearest(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Map.MapCoordinates,System.Numerics.Vector2@,System.Single@,Robust.Shared.GameObjects.TransformComponent,Robust.Shared.Physics.FixturesComponent,Robust.Shared.Physics.Components.PhysicsComponent)">
            <summary>
            Gets the nearest points in map terms and the distance between them.
            If a body is hard it only considers hard fixtures.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.SharedPhysicsSystem.TryGetNearest(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.EntityUid,System.Numerics.Vector2@,System.Numerics.Vector2@,System.Single@,Robust.Shared.GameObjects.TransformComponent,Robust.Shared.GameObjects.TransformComponent,Robust.Shared.Physics.FixturesComponent,Robust.Shared.Physics.FixturesComponent,Robust.Shared.Physics.Components.PhysicsComponent,Robust.Shared.Physics.Components.PhysicsComponent)">
            <summary>
            Gets the nearest points in map terms and the distance between them.
            If a body is hard it only considers hard fixtures.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.SharedPhysicsSystem.SolvePositionConstraints(Robust.Shared.Physics.Dynamics.SolverData,System.Int32,System.Int32,Robust.Shared.Physics.Dynamics.Contacts.ContactPositionConstraint[],System.Numerics.Vector2[],System.Single[])">
            <summary>
                Tries to solve positions for all contacts specified.
            </summary>
            <returns>true if all positions solved</returns>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.SharedPhysicsSystem.InitializeManifold(Robust.Shared.Physics.Collision.Manifold@,Robust.Shared.Physics.Transform@,Robust.Shared.Physics.Transform@,System.Single,System.Single,System.Numerics.Vector2@,System.Span{System.Numerics.Vector2})">
            <summary>
            Evaluate the manifold with supplied transforms. This assumes
            modest motion from the original state. This does not change the
            point count, impulses, etc. The radii must come from the Shapes
            that generated the manifold.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.SharedPhysicsSystem.GetLinearVelocity(Robust.Shared.GameObjects.EntityUid,System.Numerics.Vector2,Robust.Shared.Physics.Components.PhysicsComponent,Robust.Shared.GameObjects.TransformComponent)">
            <summary>
            Gets the linear velocity of a particular body at the specified point.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.SharedPhysicsSystem.GetMapLinearVelocity(Robust.Shared.Map.EntityCoordinates)">
            <summary>
                This is the total rate of change of the coordinate's map position.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.SharedPhysicsSystem.GetMapLinearVelocity(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Physics.Components.PhysicsComponent,Robust.Shared.GameObjects.TransformComponent)">
            <summary>
                This is the total rate of change of the entity's map-position, resulting from the linear and angular
                velocities of this entity and any parents.
            </summary>
            <remarks>
                Use <see cref="M:Robust.Shared.Physics.Systems.SharedPhysicsSystem.GetMapVelocities(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Physics.Components.PhysicsComponent,Robust.Shared.GameObjects.TransformComponent)"/> if you need linear and angular at the same time.
            </remarks>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.SharedPhysicsSystem.GetMapAngularVelocity(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Physics.Components.PhysicsComponent,Robust.Shared.GameObjects.TransformComponent)">
            <summary>
            Get the body's total angular velocity. This is the rate of change of the entity's world rotation.
            </summary>
            <remarks>
            Consider using <see cref="M:Robust.Shared.Physics.Systems.SharedPhysicsSystem.GetMapVelocities(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Physics.Components.PhysicsComponent,Robust.Shared.GameObjects.TransformComponent)"/> if you need linear and angular at the same time.
            </remarks>
        </member>
        <member name="M:Robust.Shared.Physics.Systems.SharedPhysicsSystem.GetMapVelocities(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Physics.Components.PhysicsComponent,Robust.Shared.GameObjects.TransformComponent)">
            <summary>
            Gets the linear and angular velocity for this entity in map terms.
            </summary>
        </member>
        <member name="M:Robust.Shared.Physics.Transform.MulT(Robust.Shared.Physics.Quaternion2D@,Robust.Shared.Physics.Quaternion2D@)">
            Transpose multiply two rotations: qT * r
        </member>
        <member name="M:Robust.Shared.Physics.Transform.MulT(Robust.Shared.Physics.Quaternion2D,System.Numerics.Vector2)">
            <summary>
                Inverse rotate a vector
            </summary>
            <param name="q"></param>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:Robust.Shared.Physics.Transform.Mul(Robust.Shared.Physics.Quaternion2D@,System.Numerics.Vector2@)">
            <summary>
                Rotate a vector
            </summary>
            <param name="quaternion2D"></param>
            <param name="vector"></param>
            <returns></returns>
        </member>
        <member name="M:Robust.Shared.Physics.Vertices.GetSignedArea(System.Span{System.Numerics.Vector2})">
            <summary>
            Gets the signed area.
            If the area is less than 0, it indicates that the polygon is clockwise winded.
            </summary>
            <returns>The signed area</returns>
        </member>
        <member name="T:Robust.Shared.Physics.IVerticesSimplifier">
            <summary>
            Takes in a list of vertices and removes any that are redundant (within tolerance).
            </summary>
        </member>
        <member name="T:Robust.Shared.Physics.CollinearSimplifier">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Physics.CollinearSimplifier.Simplify(System.Collections.Generic.List{System.Numerics.Vector2},System.Single)">
            <summary>
            Removes all collinear points on the polygon.
            </summary>
        </member>
        <member name="T:Robust.Shared.Physics.RamerDouglasPeuckerSimplifier">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Physics.RamerDouglasPeuckerSimplifier.Simplify(System.Collections.Generic.List{System.Numerics.Vector2},System.Single)">
             <summary>
             Ramer-Douglas-Peucker polygon simplification algorithm. This is the general recursive version that does not use the
             speed-up technique by using the Melkman convex hull.
            
             If you pass in 0, it will remove all collinear points.
             </summary>
             <returns>The simplified polygon</returns>
        </member>
        <member name="M:Robust.Shared.Player.ActorComponent.InternalCopy(Robust.Shared.Player.ActorComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Player.ActorComponent.Copy(Robust.Shared.Player.ActorComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Player.ActorComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Player.ActorComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Player.ActorComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Player.ActorComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Player.ActorComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Shared.Player.ActorSystem">
            <summary>
                System that handles <see cref="T:Robust.Shared.Player.ActorComponent"/>.
            </summary>
        </member>
        <member name="T:Robust.Shared.Player.DummySession">
            <summary>
            This is a mock session for use with integration tests and benchmarks. It uses a <see cref="F:Robust.Shared.Player.DummySession.DummyChannel"/> as
            its <see cref="T:Robust.Shared.Network.INetChannel"/>, which doesn't support actually sending any messages.
            </summary>
        </member>
        <member name="T:Robust.Shared.Player.DummyChannel">
            <summary>
            A mock NetChannel for use in integration tests and benchmarks.
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.DummyChannel.#ctor(Robust.Shared.Player.DummySession)">
            <summary>
            A mock NetChannel for use in integration tests and benchmarks.
            </summary>
        </member>
        <member name="T:Robust.Shared.Player.PlayerAttachedEvent">
            <summary>
            Event that gets raised when a player has been attached to an entity. This event is both raised directed at the
            entity and broadcast.
            </summary>
        </member>
        <member name="T:Robust.Shared.Player.PlayerDetachedEvent">
            <summary>
            Event that gets raised when a player has been detached from an entity. This event is both raised directed at the
            entity and broadcast.
            </summary>
        </member>
        <member name="T:Robust.Shared.Player.LocalPlayerAttachedEvent">
            <summary>
            Variant of <see cref="T:Robust.Shared.Player.PlayerAttachedEvent"/> that gets raised by the client when the local session gets attached to
            a new entity. This event will also get raised if the local session changes.
            </summary>
        </member>
        <member name="T:Robust.Shared.Player.LocalPlayerDetachedEvent">
            <summary>
            Variant of <see cref="T:Robust.Shared.Player.PlayerDetachedEvent"/> that gets raised by the client when the local session gets attached to
            a new entity. This event will also get raised if the local session changes.
            </summary>
        </member>
        <member name="T:Robust.Shared.Player.Filter">
            <summary>
                Contains a set of recipients for a networked method call.
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.Filter.AddPlayer(Robust.Shared.Player.ICommonSession)">
            <summary>
                Adds a single player to the filter.
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.Filter.AddPlayersByPvs(Robust.Shared.GameObjects.EntityUid,System.Single,Robust.Shared.GameObjects.IEntityManager,Robust.Shared.Player.ISharedPlayerManager,Robust.Shared.Configuration.IConfigurationManager)">
            <summary>
                Adds all players inside an entity's PVS.
                The current PVS range will be multiplied by <see cref="!:rangeMultiplier"/>.
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.Filter.AddPlayersByPvs(Robust.Shared.GameObjects.TransformComponent,System.Single)">
            <summary>
                Adds all players inside an entity's PVS.
                The current PVS range will be multiplied by <see cref="!:rangeMultiplier"/>.
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.Filter.AddPlayersByPvs(Robust.Shared.Map.EntityCoordinates,System.Single,Robust.Shared.GameObjects.IEntityManager,Robust.Shared.Player.ISharedPlayerManager)">
            <summary>
                Adds all players inside an entity's PVS.
                The current PVS range will be multiplied by <see cref="!:rangeMultiplier"/>.
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.Filter.AddPlayersByPvs(Robust.Shared.Map.MapCoordinates,System.Single,Robust.Shared.GameObjects.IEntityManager,Robust.Shared.Player.ISharedPlayerManager,Robust.Shared.Configuration.IConfigurationManager)">
            <summary>
                Adds all players inside an entity's PVS.
                The current PVS range will be multiplied by <see cref="!:rangeMultiplier"/>.
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.Filter.AddPlayers(System.Collections.Generic.IEnumerable{Robust.Shared.Player.ICommonSession})">
            <summary>
                Adds a set of players to the filter.
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.Filter.AddAllPlayers(Robust.Shared.Player.ISharedPlayerManager)">
            <summary>
                Adds all players to the filter.
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.Filter.AddWhere(System.Predicate{Robust.Shared.Player.ICommonSession},Robust.Shared.Player.ISharedPlayerManager)">
            <summary>
                Adds all players that match a predicate.
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.Filter.AddWhereAttachedEntity(System.Predicate{Robust.Shared.GameObjects.EntityUid})">
            <summary>
                Add all players whose attached entity match a predicate.
                Doesn't consider players without an attached entity.
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.Filter.AddInGrid(Robust.Shared.GameObjects.EntityUid,Robust.Shared.GameObjects.IEntityManager)">
            <summary>
                Add all players whose entity is on a certain grid.
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.Filter.AddInMap(Robust.Shared.Map.MapId,Robust.Shared.GameObjects.IEntityManager)">
            <summary>
                Add all players whose entity is on a certain map.
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.Filter.AddInRange(Robust.Shared.Map.MapCoordinates,System.Single,Robust.Shared.Player.ISharedPlayerManager,Robust.Shared.GameObjects.IEntityManager)">
            <summary>
                Adds all players in range of a position.
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.Filter.RemoveByVisibility(System.UInt32,Robust.Shared.GameObjects.IEntityManager)">
            <summary>
                Removes all players without the specified visibility flag.
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.Filter.RemovePlayer(Robust.Shared.Player.ICommonSession)">
            <summary>
                Removes a single player from the filter.
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.Filter.RemovePlayers(System.Collections.Generic.IEnumerable{Robust.Shared.Player.ICommonSession})">
            <summary>
               Removes players from the filter.
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.Filter.RemovePlayers(Robust.Shared.Player.ICommonSession[])">
            <summary>
               Removes players from the filter.
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.Filter.RemovePlayerByAttachedEntity(Robust.Shared.GameObjects.EntityUid)">
            <summary>
                Removes a single player from the filter, specified by the entity to which they are attached.
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.Filter.RemovePlayersByAttachedEntity(System.Collections.Generic.IEnumerable{Robust.Shared.GameObjects.EntityUid})">
            <summary>
                Removes players from the filter, specified by the entities to which they are attached.
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.Filter.RemovePlayersByAttachedEntity(Robust.Shared.GameObjects.EntityUid[])">
            <summary>
                Removes players from the filter, specified by the entities to which they are attached.
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.Filter.RemoveWhere(System.Predicate{Robust.Shared.Player.ICommonSession})">
            <summary>
                Removes all players from the filter that match a predicate.
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.Filter.RemoveWhereAttachedEntity(System.Predicate{Robust.Shared.GameObjects.EntityUid})">
            <summary>
                Removes all players whose attached entity match a predicate.
                Doesn't consider players without an attached entity.
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.Filter.RemoveInRange(Robust.Shared.Map.MapCoordinates,System.Single,Robust.Shared.GameObjects.IEntityManager)">
            <summary>
                Removes all players in range of a position.
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.Filter.Merge(Robust.Shared.Player.Filter)">
            <summary>
                Adds all players from a different filter into this one.
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.Filter.FromEntities(Robust.Shared.GameObjects.EntityUid[])">
            <summary>
                Adds all players attached to the given entities to this filter, then returns it.
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.Filter.Clone">
            <summary>
                Returns a new filter with the same parameters as this one.
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.Filter.Unpredicted">
            <summary>
                Normally a filter will properly handle client side prediction. Calling this
                function disables that, and the event will be spammed during every prediction
                tick.
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.Filter.SendReliably">
            <summary>
                Should it be guaranteed that recipients receive the message?
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.Filter.Empty">
            <summary>
                A new filter that is empty.
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.Filter.SinglePlayer(Robust.Shared.Player.ICommonSession)">
            <summary>
                A new filter with a single player in it.
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.Filter.Broadcast">
            <summary>
                A new filter with all players in it.
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.Filter.BroadcastGrid(Robust.Shared.GameObjects.EntityUid)">
            <summary>
                A new filter with all players whose attached entity is on a certain grid.
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.Filter.BroadcastMap(Robust.Shared.Map.MapId)">
            <summary>
                A new filter with all players whose attached entity is on a certain map.
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.Filter.Pvs(Robust.Shared.GameObjects.EntityUid,System.Single,Robust.Shared.GameObjects.IEntityManager,Robust.Shared.Player.ISharedPlayerManager,Robust.Shared.Configuration.IConfigurationManager)">
            <summary>
                A filter with every player whose PVS overlaps this entity.
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.Filter.Pvs(Robust.Shared.GameObjects.TransformComponent,System.Single)">
            <summary>
                A filter with every player whose PVS overlaps this point.
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.Filter.Pvs(Robust.Shared.Map.EntityCoordinates,System.Single,Robust.Shared.GameObjects.IEntityManager,Robust.Shared.Player.ISharedPlayerManager)">
            <summary>
                A filter with every player whose PVS overlaps this point.
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.Filter.Pvs(Robust.Shared.Map.MapCoordinates,System.Single)">
            <summary>
                A filter with every player whose PVS overlaps this point.
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.Filter.PvsExcept(Robust.Shared.GameObjects.EntityUid,System.Single,Robust.Shared.GameObjects.IEntityManager)">
            <summary>
                A filter with every player whose PVS overlaps this point except the original player.
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.Filter.Entities(Robust.Shared.GameObjects.EntityUid[])">
            <summary>
                A filter with every player attached to the given entities.
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.Filter.Local">
            <summary>
                A filter with only the local player.
            </summary>
        </member>
        <member name="T:Robust.Shared.Player.ICommonSession">
            <summary>
            Common info between client and server sessions.
            </summary>
        </member>
        <member name="P:Robust.Shared.Player.ICommonSession.Status">
            <summary>
            Status of the session.
            </summary>
        </member>
        <member name="P:Robust.Shared.Player.ICommonSession.AttachedEntity">
            <summary>
            Entity UID that this session is represented by in the world, if any.
            </summary>
        </member>
        <member name="P:Robust.Shared.Player.ICommonSession.UserId">
            <summary>
            The UID of this session.
            </summary>
        </member>
        <member name="P:Robust.Shared.Player.ICommonSession.Name">
            <summary>
            Current name of this player.
            </summary>
        </member>
        <member name="P:Robust.Shared.Player.ICommonSession.Ping">
            <summary>
            Current connection latency of this session from the server to their client.
            </summary>
        </member>
        <member name="P:Robust.Shared.Player.ICommonSession.Channel">
            <summary>
            The current network channel for this session.
            </summary>
            <remarks>
            On the Server every player has a network channel,
            on the Client only the LocalPlayer has a network channel, and that channel points to the server.
            </remarks>
        </member>
        <member name="P:Robust.Shared.Player.ICommonSession.ViewSubscriptions">
            <summary>
            List of "eyes" to use for PVS range checks.
            </summary>
        </member>
        <member name="P:Robust.Shared.Player.ICommonSession.State">
            <summary>
            Session state, for sending player lists to clients.
            </summary>
        </member>
        <member name="P:Robust.Shared.Player.ICommonSession.Data">
            <summary>
            Class for storing arbitrary session-specific data that is not lost upon reconnect.
            </summary>
        </member>
        <member name="P:Robust.Shared.Player.ICommonSession.ClientSide">
            <summary>
            If true, this indicates that this is a client-side session, and should be ignored when applying a server's
            game state.
            </summary>
        </member>
        <member name="P:Robust.Shared.Player.ISharedPlayerManager.Sessions">
            <summary>
            list of connected sessions.
            </summary>
        </member>
        <member name="P:Robust.Shared.Player.ISharedPlayerManager.NetworkedSessions">
            <summary>
            Sessions with a remote endpoint. On the server, this is equivalent to <see cref="P:Robust.Shared.Player.ISharedPlayerManager.Sessions"/>. On the client,
            this will only ever contain <see cref="P:Robust.Shared.Player.ISharedPlayerManager.LocalSession"/>
            </summary>
        </member>
        <member name="P:Robust.Shared.Player.ISharedPlayerManager.SessionsDict">
            <summary>
            Dictionary mapping connected users to their sessions.
            </summary>
        </member>
        <member name="P:Robust.Shared.Player.ISharedPlayerManager.PlayerCount">
            <summary>
                Number of players currently connected to this server.
            </summary>
        </member>
        <member name="P:Robust.Shared.Player.ISharedPlayerManager.MaxPlayers">
            <summary>
                Maximum number of players that can connect to this server at one time.
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.ISharedPlayerManager.Initialize(System.Int32)">
            <summary>
            Initializes the manager.
            </summary>
            <param name="maxPlayers">Maximum number of players that can connect to this server at one time. Does nothing
            on the client.</param>
        </member>
        <member name="M:Robust.Shared.Player.ISharedPlayerManager.Dirty">
            <summary>
            Indicates that some session's networked data has changed. This will cause an updated player list to be sent to
            all players.
            </summary>
        </member>
        <member name="P:Robust.Shared.Player.ISharedPlayerManager.LocalSession">
            <summary>
            The session of the local player. This will be null on the server.
            </summary>
        </member>
        <member name="P:Robust.Shared.Player.ISharedPlayerManager.LocalUser">
            <summary>
            The user Id of the local player. This will be null on the server.
            </summary>
        </member>
        <member name="P:Robust.Shared.Player.ISharedPlayerManager.LocalEntity">
            <summary>
            The entity currently controlled by the local player. This will be null on the server.
            </summary>
        </member>
        <member name="E:Robust.Shared.Player.ISharedPlayerManager.PlayerStatusChanged">
            <summary>
            This gets invoked when a session's <see cref="P:Robust.Shared.Player.ICommonSession.Status"/> changes.
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.ISharedPlayerManager.TryGetUserId(System.String,Robust.Shared.Network.NetUserId@)">
            <summary>
            Attempts to resolve a username into a <see cref="T:Robust.Shared.Network.NetUserId"/>.
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.ISharedPlayerManager.TryGetSessionByEntity(Robust.Shared.GameObjects.EntityUid,Robust.Shared.Player.ICommonSession@)">
            <summary>
            Attempts to get the session that is currently attached to a given entity.
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.ISharedPlayerManager.TryGetSessionById(System.Nullable{Robust.Shared.Network.NetUserId},Robust.Shared.Player.ICommonSession@)">
            <summary>
            Attempts to get the session with the given <see cref="T:Robust.Shared.Network.NetUserId"/>.
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.ISharedPlayerManager.TryGetSessionByUsername(System.String,Robust.Shared.Player.ICommonSession@)">
            <summary>
            Attempts to get the session with the given <see cref="P:Robust.Shared.Player.ICommonSession.Name"/>.
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.ISharedPlayerManager.TryGetSessionByChannel(Robust.Shared.Network.INetChannel,Robust.Shared.Player.ICommonSession@)">
            <summary>
            Attempts to get the session that corresponds to the given channel.
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.ISharedPlayerManager.ValidSessionId(Robust.Shared.Network.NetUserId)">
            <summary>
            Check if the given user id has an active session.
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.ISharedPlayerManager.SetAttachedEntity(Robust.Shared.Player.ICommonSession,System.Nullable{Robust.Shared.GameObjects.EntityUid},Robust.Shared.Player.ICommonSession@,System.Boolean)">
            <summary>
            Sets a session's attached entity, optionally kicking any sessions already attached to it.
            </summary>
            <param name="session">The player whose attached entity should get updated</param>
            <param name="entity">The entity to attach the player to, if any.</param>
            <param name="force">Whether to kick any existing players that are already attached to the entity</param>
            <param name="kicked">The player that was forcefully kicked, if any.</param>
            <returns>Whether the attach succeeded, or not.</returns>
        </member>
        <member name="M:Robust.Shared.Player.ISharedPlayerManager.SetAttachedEntity(Robust.Shared.Player.ICommonSession,System.Nullable{Robust.Shared.GameObjects.EntityUid},System.Boolean)">
            <summary>
            Sets a session's attached entity, optionally kicking any sessions already attached to it.
            </summary>
            <param name="session">The player whose attached entity should get updated</param>
            <param name="entity">The entity to attach the player to, if any.</param>
            <param name="force">Whether to kick any existing players that are already attached to the entity</param>
            <returns>Whether the attach succeeded, or not.</returns>
        </member>
        <member name="M:Robust.Shared.Player.ISharedPlayerManager.SetStatus(Robust.Shared.Player.ICommonSession,Robust.Shared.Enums.SessionStatus)">
            <summary>
            Updates a session's <see cref="P:Robust.Shared.Player.ICommonSession.Status"/>
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.ISharedPlayerManager.SetPing(Robust.Shared.Player.ICommonSession,System.Int16)">
            <summary>
            Updates a session's <see cref="P:Robust.Shared.Player.ICommonSession.Ping"/>
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.ISharedPlayerManager.SetName(Robust.Shared.Player.ICommonSession,System.String)">
            <summary>
            Updates a session's <see cref="P:Robust.Shared.Player.ICommonSession.Name"/>
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.ISharedPlayerManager.JoinGame(Robust.Shared.Player.ICommonSession)">
            <summary>
            Set the session's status to <see cref="F:Robust.Shared.Enums.SessionStatus.InGame"/>.
            </summary>
        </member>
        <member name="T:Robust.Shared.Player.SessionData">
            <summary>
                Stores session-specific data that is not lost upon reconnect.
            </summary>
        </member>
        <member name="P:Robust.Shared.Player.SessionData.UserId">
            <summary>
                The session ID of the player owning this data.
            </summary>
        </member>
        <member name="P:Robust.Shared.Player.SessionData.ContentDataUncast">
            <summary>
                Custom field that content can assign anything to.
                Go wild.
            </summary>
        </member>
        <member name="T:Robust.Shared.Player.SharedFilterSystem">
            <summary>
                EntitySystem used for any Filters that require different behaviors on the server and client.
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.SharedFilterSystem.FromEntities(Robust.Shared.Player.Filter,Robust.Shared.GameObjects.EntityUid[])">
            <summary>
                Adds all players attached to the given entities to the given filter, then returns it.
            </summary>
        </member>
        <member name="M:Robust.Shared.Player.SharedPlayerManager.SetAttachedEntity(Robust.Shared.Player.ICommonSession,System.Nullable{Robust.Shared.GameObjects.EntityUid},Robust.Shared.Player.ICommonSession@,System.Boolean)">
            <inheritdoc cref="M:Robust.Shared.Player.ISharedPlayerManager.SetAttachedEntity(Robust.Shared.Player.ICommonSession,System.Nullable{Robust.Shared.GameObjects.EntityUid},Robust.Shared.Player.ICommonSession@,System.Boolean)"/>
        </member>
        <member name="T:Robust.Shared.Profiling.ProfData">
            <summary>
            Static helper class to help with profiling data values.
            </summary>
        </member>
        <member name="T:Robust.Shared.Profiling.ProfBuffer">
            <summary>
            A buffer containing a set of profiling data.
            </summary>
        </member>
        <member name="M:Robust.Shared.Profiling.ProfBuffer.Snapshot">
            <summary>
            Create a deep clone of this snapshot.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Robust.Shared.Profiling.ProfIndex">
            <summary>
            An index into the profiling log buffer.
            </summary>
        </member>
        <member name="F:Robust.Shared.Profiling.ProfIndex.Type">
            <summary>
            What type of data this index covers.
            </summary>
        </member>
        <member name="F:Robust.Shared.Profiling.ProfIndex.StartPos">
            <summary>
            The position immediately after the last log event covered by the index.
            </summary>
        </member>
        <member name="F:Robust.Shared.Profiling.ProfIndex.EndPos">
            <summary>
            The position immediately after the last log event covered by the index.
            </summary>
        </member>
        <member name="T:Robust.Shared.Profiling.ProfIndexType">
            <summary>
            Types of profile indices.
            </summary>
        </member>
        <member name="F:Robust.Shared.Profiling.ProfIndexType.Frame">
            <summary>
            Index covers a full game loop iteration/render frame.
            </summary>
        </member>
        <member name="T:Robust.Shared.Profiling.ProfLog">
            <summary>
            A single log entry in the profiling system.
            </summary>
            <remarks>
            This is a tagged union, use it appropriately.
            </remarks>
        </member>
        <member name="T:Robust.Shared.Profiling.ProfLogValue">
            <summary>
            Data for value log events.
            </summary>
        </member>
        <member name="T:Robust.Shared.Profiling.ProfLogGroupEnd">
            <summary>
            Data for group end log events.
            </summary>
        </member>
        <member name="T:Robust.Shared.Profiling.ProfLogType">
            <summary>
            Types of profile log entries.
            </summary>
        </member>
        <member name="T:Robust.Shared.Profiling.ProfValue">
            <summary>
            A single logged value in the profiling system.
            </summary>
            <remarks>
            This is a tagged union, use it appropriately.
            </remarks>
        </member>
        <member name="T:Robust.Shared.Profiling.ProfValueType">
            <summary>
            Types of profiling values.
            </summary>
        </member>
        <member name="T:Robust.Shared.Profiling.TimeAndAllocSample">
            <summary>
            A sample containing time (in seconds) and amount allocated.
            </summary>
        </member>
        <member name="P:Robust.Shared.Profiling.ProfManager.IsEnabled">
            <summary>
            Proxy to <c>prof.enabled</c> CVar.
            </summary>
        </member>
        <member name="M:Robust.Shared.Profiling.ProfManager.MarkIndex(System.Int64,Robust.Shared.Profiling.ProfIndexType)">
            <summary>
            Write an index covering the region from <paramref name="start"/> to the current write position.
            </summary>
            <param name="start">The absolute start index of </param>
            <param name="type">The type of index to mark.</param>
        </member>
        <member name="M:Robust.Shared.Profiling.ProfManager.WriteValue(System.String,Robust.Shared.Profiling.ProfValue@)">
            <summary>
            Write a single profiling value to the log.
            </summary>
            <param name="text">The name of the entry.</param>
            <param name="value">The value to write.</param>
            <returns>The absolute position of the written log entry.</returns>
        </member>
        <member name="M:Robust.Shared.Profiling.ProfManager.WriteValue(System.String,Robust.Shared.Profiling.ProfSampler@)">
            <summary>
            Write a single profiling value to the log. Automatically samples the given sampler.
            </summary>
            <param name="text">The name of the entry.</param>
            <param name="sampler">The value of the sampler is measured to store a <see cref="T:Robust.Shared.Profiling.TimeAndAllocSample"/>.</param>
            <returns>The absolute position of the written log entry.</returns>
        </member>
        <member name="M:Robust.Shared.Profiling.ProfManager.WriteValue(System.String,System.Int32)">
            <summary>
            Write a single profiling value to the log.
            </summary>
            <param name="text">The name of the entry.</param>
            <param name="int32">The value to write.</param>
            <returns>The absolute position of the written log entry.</returns>
        </member>
        <member name="M:Robust.Shared.Profiling.ProfManager.WriteValue(System.String,System.Int64)">
            <summary>
            Write a single profiling value to the log.
            </summary>
            <param name="text">The name of the entry.</param>
            <param name="int64">The value to write.</param>
            <returns>The absolute position of the written log entry.</returns>
        </member>
        <member name="M:Robust.Shared.Profiling.ProfManager.WriteGroupStart">
            <summary>
            Write the start of a new log group.
            </summary>
            <returns>The absolute position of the written log entry.</returns>
        </member>
        <member name="M:Robust.Shared.Profiling.ProfManager.WriteGroupEnd(System.Int64,System.String,Robust.Shared.Profiling.ProfValue@)">
            <summary>
            Write the end of a log group.
            </summary>
            <param name="startIndex">The index of the matching group start.</param>
            <param name="text">The name of the group.</param>
            <param name="value">The value of the group.</param>
        </member>
        <member name="M:Robust.Shared.Profiling.ProfManager.WriteGroupEnd(System.Int64,System.String,Robust.Shared.Profiling.ProfSampler@)">
            <summary>
            Write the end of a log group.
            </summary>
            <param name="startIndex">The index of the matching group start.</param>
            <param name="text">The name of the group.</param>
            <param name="sampler">The value of the sampler is measured to store a <see cref="T:Robust.Shared.Profiling.TimeAndAllocSample"/>.</param>
        </member>
        <member name="M:Robust.Shared.Profiling.ProfManager.Group(System.String)">
            <summary>
            Make a guarded group for usage with using blocks.
            </summary>
        </member>
        <member name="M:Robust.Shared.Profiling.ProfManager.GetString(System.Int32)">
            <summary>
            Get the value for a string in the string tree.
            </summary>
        </member>
        <member name="M:Robust.Shared.Profiling.ProfManager.GetStringIdx(System.String)">
            <summary>
            Get the index of a string in the string tree.
            </summary>
        </member>
        <member name="T:Robust.Shared.Profiling.ProfSampler">
            <summary>
            Wrapper around <see cref="T:Robust.Shared.Timing.RStopwatch"/> that also does allocations tracking using <see cref="M:System.GC.GetAllocatedBytesForCurrentThread"/>.
            </summary>
        </member>
        <member name="T:Robust.Shared.Prototypes.PrototypeAttribute">
            <summary>
            Quick attribute to give the prototype its type string.
            To prevent needing to instantiate it because interfaces can't declare statics.
            </summary>
        </member>
        <member name="T:Robust.Shared.Prototypes.EntityCategoryAttribute">
            <summary>
            Attribute that can be applied to components to force any entity prototypes with that component to automatically
            get added to an <see cref="T:Robust.Shared.Prototypes.EntityCategoryPrototype"/> instance.
            </summary>
        </member>
        <member name="M:Robust.Shared.Prototypes.EntityCategoryAttribute.#ctor(System.String[])">
            <summary>
            Attribute that can be applied to components to force any entity prototypes with that component to automatically
            get added to an <see cref="T:Robust.Shared.Prototypes.EntityCategoryPrototype"/> instance.
            </summary>
        </member>
        <member name="T:Robust.Shared.Prototypes.EntityCategoryPrototype">
            <summary>
            Prototype that represents some entity prototype category.
            Useful for sorting or grouping entity prototypes for mapping/spawning UIs.
            </summary>
        </member>
        <member name="F:Robust.Shared.Prototypes.EntityCategoryPrototype.Name">
            <summary>
            Localized name of the category, for use in entity spawn menus.
            </summary>
        </member>
        <member name="F:Robust.Shared.Prototypes.EntityCategoryPrototype.Description">
            <summary>
            Localized description of the category, for use in entity spawn menus.
            </summary>
        </member>
        <member name="F:Robust.Shared.Prototypes.EntityCategoryPrototype.Suffix">
            <summary>
            Default suffix to give all entities that belong to this prototype.
            See <see cref="P:Robust.Shared.Prototypes.EntityPrototype.EditorSuffix"/>.
            </summary>
        </member>
        <member name="F:Robust.Shared.Prototypes.EntityCategoryPrototype.HideSpawnMenu">
            <summary>
            If true, any entity prototypes that belong to this category should not be shown in general entity spawning UIs.
            Useful for various entities that shouldn't be spawned directly.
            </summary>
        </member>
        <member name="F:Robust.Shared.Prototypes.EntityCategoryPrototype.Components">
            <summary>
            List of components that will cause an entity prototype to be automatically included in this category.
            </summary>
        </member>
        <member name="F:Robust.Shared.Prototypes.EntityCategoryPrototype.Inheritable">
            <summary>
            If true, then an entity prototype will automatically get added to this category if any of its parent belonged to
            it category.
            </summary>
        </member>
        <member name="T:Robust.Shared.Prototypes.EntityPrototype">
            <summary>
            Prototype that represents game entities.
            </summary>
        </member>
        <member name="P:Robust.Shared.Prototypes.EntityPrototype.ID">
            <summary>
            The "in code name" of the object. Must be unique.
            </summary>
        </member>
        <member name="P:Robust.Shared.Prototypes.EntityPrototype.SetName">
            <summary>
                The name set on this level of the prototype. This does NOT handle localization or inheritance.
                You probably want <see cref="P:Robust.Shared.Prototypes.EntityPrototype.Name"/> instead.
            </summary>
            <seealso cref="P:Robust.Shared.Prototypes.EntityPrototype.Name"/>
        </member>
        <member name="P:Robust.Shared.Prototypes.EntityPrototype.Categories">
            <summary>
            What categories this prototype belongs to. This includes categories inherited from parents and categories
            that were automatically inferred from the prototype's components.
            </summary>
        </member>
        <member name="P:Robust.Shared.Prototypes.EntityPrototype.Name">
            <summary>
            The "in game name" of the object. What is displayed to most players.
            </summary>
        </member>
        <member name="P:Robust.Shared.Prototypes.EntityPrototype.Description">
            <summary>
            The description of the object that shows upon using examine
            </summary>
        </member>
        <member name="P:Robust.Shared.Prototypes.EntityPrototype.EditorSuffix">
            <summary>
                Optional suffix to display in development menus like the entity spawn panel,
                to provide additional info without ruining the Name property itself.
            </summary>
        </member>
        <member name="P:Robust.Shared.Prototypes.EntityPrototype.CustomLocalizationID">
            <summary>
            Fluent messageId used to lookup the entity's name and localization attributes.
            </summary>
        </member>
        <member name="P:Robust.Shared.Prototypes.EntityPrototype.NoSpawn">
            <summary>
                If true, this object should not show up in the entity spawn panel.
            </summary>
        </member>
        <member name="P:Robust.Shared.Prototypes.EntityPrototype.MountingPoints">
            <summary>
            The different mounting points on walls. (If any).
            </summary>
        </member>
        <member name="P:Robust.Shared.Prototypes.EntityPrototype.PlacementMode">
            <summary>
            The Placement mode used for client-initiated placement. This is used for admin and editor placement. The serverside version controls what type the server assigns in normal gameplay.
            </summary>
        </member>
        <member name="P:Robust.Shared.Prototypes.EntityPrototype.PlacementRange">
            <summary>
            The Range this entity can be placed from. This is only used serverside since the server handles normal gameplay. The client uses unlimited range since it handles things like admin spawning and editing.
            </summary>
        </member>
        <member name="P:Robust.Shared.Prototypes.EntityPrototype.PlacementOffset">
            <summary>
            Offset that is added to the position when placing. (if any). Client only.
            </summary>
        </member>
        <member name="P:Robust.Shared.Prototypes.EntityPrototype.MapSavable">
            <summary>
            True if this entity will be saved by the map loader.
            </summary>
        </member>
        <member name="P:Robust.Shared.Prototypes.EntityPrototype.Parents">
            <summary>
            The prototype we inherit from.
            </summary>
        </member>
        <member name="P:Robust.Shared.Prototypes.EntityPrototype.Components">
            <summary>
            A dictionary mapping the component type list to the YAML mapping containing their settings.
            </summary>
        </member>
        <member name="M:Robust.Shared.Prototypes.EntityPrototype.EntityPlacementProperties.InternalCopy(Robust.Shared.Prototypes.EntityPrototype.EntityPlacementProperties@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Prototypes.EntityPrototype.EntityPlacementProperties.Copy(Robust.Shared.Prototypes.EntityPrototype.EntityPlacementProperties@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Prototypes.EntityPrototype.EntityPlacementProperties.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Prototypes.EntityPrototype.EntityPlacementProperties.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Shared.Prototypes.EntProtoId">
            <summary>
                Wrapper type for an <see cref="T:Robust.Shared.Prototypes.EntityPrototype"/> with a given id.
            </summary>
            <param name="Id">The id of the prototype.</param>
            <remarks>
                This will be automatically validated by <see cref="T:Robust.Shared.Serialization.TypeSerializers.Implementations.EntProtoIdSerializer"/> if used in data fields.
            </remarks>
            <remarks><seealso cref="T:Robust.Shared.Prototypes.ProtoId`1"/> for a wrapper of other prototype kinds.</remarks>
        </member>
        <member name="M:Robust.Shared.Prototypes.EntProtoId.#ctor(System.String)">
            <summary>
                Wrapper type for an <see cref="T:Robust.Shared.Prototypes.EntityPrototype"/> with a given id.
            </summary>
            <param name="Id">The id of the prototype.</param>
            <remarks>
                This will be automatically validated by <see cref="T:Robust.Shared.Serialization.TypeSerializers.Implementations.EntProtoIdSerializer"/> if used in data fields.
            </remarks>
            <remarks><seealso cref="T:Robust.Shared.Prototypes.ProtoId`1"/> for a wrapper of other prototype kinds.</remarks>
        </member>
        <member name="P:Robust.Shared.Prototypes.EntProtoId.Id">
            <summary>The id of the prototype.</summary>
        </member>
        <member name="T:Robust.Shared.Prototypes.EntProtoId`1">
            <inheritdoc cref="T:Robust.Shared.Prototypes.EntProtoId"/>
        </member>
        <member name="M:Robust.Shared.Prototypes.EntProtoId`1.#ctor(System.String)">
            <inheritdoc cref="T:Robust.Shared.Prototypes.EntProtoId"/>
        </member>
        <member name="T:Robust.Shared.Prototypes.IPrototype">
            <summary>
                An IPrototype is a prototype that can be loaded from the global YAML prototypes.
            </summary>
            <remarks>
                To use this, the prototype must be accessible through IoC with <see cref="!:IoCTargetAttribute"/>
                and it must have a <see cref="T:Robust.Shared.Prototypes.PrototypeAttribute"/> to give it a type string.
            </remarks>
        </member>
        <member name="P:Robust.Shared.Prototypes.IPrototype.ID">
            <summary>
            An ID for this prototype instance.
            If this is a duplicate, an error will be thrown.
            </summary>
        </member>
        <member name="T:Robust.Shared.Prototypes.IPrototypeManager">
            <summary>
            Handle storage and loading of YAML prototypes.
            </summary>
            <remarks>
            Terminology:
            "Kinds" are the types of prototypes there are, like <see cref="T:Robust.Shared.Prototypes.EntityPrototype"/>.
            "Prototypes" are simply filled-in prototypes from YAML.
            </remarks>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.GetPrototypeKinds">
            <summary>
            Returns an <see cref="T:System.Collections.Generic.IEnumerable`1"/> of all registered prototype kinds by their ID.
            </summary>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.Count``1">
            <summary>
            Returns the count of the specified prototype.
            </summary>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.EnumeratePrototypes``1">
            <summary>
            Return an <see cref="T:System.Collections.Generic.IEnumerable`1"/> of all prototypes of a certain kind.
            </summary>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">
            Thrown if the type of prototype is not registered.
            </exception>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.EnumeratePrototypes(System.Type)">
            <summary>
            Return an <see cref="T:System.Collections.Generic.IEnumerable`1"/> of all prototypes of a certain kind.
            </summary>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">
            Thrown if the kind of prototype is not registered.
            </exception>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.EnumeratePrototypes(System.String)">
            <summary>
            Return an <see cref="T:System.Collections.Generic.IEnumerable`1"/> of all prototypes of a certain kind.
            </summary>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">
            Thrown if the kind of prototype is not registered.
            </exception>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.EnumerateParents``1(``0,System.Boolean)">
            <summary>
            Returns an <see cref="T:System.Collections.Generic.IEnumerable`1"/> of all parents of a prototype of a certain kind.
            </summary>
            <remarks>
            Note that this will skip abstract parents, even if the abstract parent may have concrete grand-parents.
            </remarks>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.EnumerateParents``1(System.String,System.Boolean)">
            <inheritdoc cref="M:Robust.Shared.Prototypes.IPrototypeManager.EnumerateParents``1(``0,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.EnumerateParents(System.Type,System.String,System.Boolean)">
            <inheritdoc cref="M:Robust.Shared.Prototypes.IPrototypeManager.EnumerateParents``1(``0,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.EnumerateAllParents``1(System.String,System.Boolean)">
            <summary>
            Variant of <see cref="M:Robust.Shared.Prototypes.IPrototypeManager.EnumerateParents``1(``0,System.Boolean)"/> that includes abstract parents.
            </summary>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.EnumeratePrototypeKinds">
            <summary>
            Returns all of the registered prototype kinds.
            </summary>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.Index``1(System.String)">
            <summary>
            Index for a <see cref="T:Robust.Shared.Prototypes.IPrototype"/> by ID.
            </summary>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">
            Thrown if the type of prototype is not registered.
            </exception>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.Index(Robust.Shared.Prototypes.EntProtoId)">
            <inheritdoc cref="M:Robust.Shared.Prototypes.IPrototypeManager.Index``1(System.String)"/>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.Index``1(Robust.Shared.Prototypes.ProtoId{``0})">
            <inheritdoc cref="M:Robust.Shared.Prototypes.IPrototypeManager.Index``1(System.String)"/>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.Index(System.Type,System.String)">
            <summary>
            Index for a <see cref="T:Robust.Shared.Prototypes.IPrototype"/> by ID.
            </summary>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">
            Thrown if the ID does not exist or the kind of prototype is not registered.
            </exception>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.HasIndex``1(System.String)">
            <summary>
                Returns whether a prototype of type <typeparamref name="T"/> with the specified <param name="id"/> exists.
            </summary>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.HasIndex(Robust.Shared.Prototypes.EntProtoId)">
            <inheritdoc cref="M:Robust.Shared.Prototypes.IPrototypeManager.HasIndex``1(System.String)"/>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.HasIndex``1(Robust.Shared.Prototypes.ProtoId{``0})">
            <inheritdoc cref="M:Robust.Shared.Prototypes.IPrototypeManager.HasIndex``1(System.String)"/>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.HasIndex(System.Nullable{Robust.Shared.Prototypes.EntProtoId})">
            <inheritdoc cref="M:Robust.Shared.Prototypes.IPrototypeManager.HasIndex``1(System.String)"/>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.HasIndex``1(System.Nullable{Robust.Shared.Prototypes.ProtoId{``0}})">
            <inheritdoc cref="M:Robust.Shared.Prototypes.IPrototypeManager.HasIndex``1(System.String)"/>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.TryGetInstances``1(System.Collections.Frozen.FrozenDictionary{System.String,``0}@)">
            <summary>
            Attempts to get a dictionary containing all current instances of a given prototype kind.
            The dictionary will be valid up until prototypes are next reloaded.
            </summary>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.GetInstances``1">
            <summary>
            Gets a dictionary containing all current instances of a given prototype kind.
            The dictionary will be valid up until prototypes are next reloaded.
            </summary>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.TryIndex(Robust.Shared.Prototypes.EntProtoId,Robust.Shared.Prototypes.EntityPrototype@,System.Boolean)">
            <inheritdoc cref="M:Robust.Shared.Prototypes.IPrototypeManager.TryIndex``1(Robust.Shared.Prototypes.ProtoId{``0},``0@,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.TryIndex``1(Robust.Shared.Prototypes.ProtoId{``0},``0@,System.Boolean)">
            <summary>
            Attempt to retrieve the prototype corresponding to the given prototype id.
            Unless otherwise specified, this will log an error if the id does not match any known prototype.
            </summary>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.TryIndex(System.Nullable{Robust.Shared.Prototypes.EntProtoId},Robust.Shared.Prototypes.EntityPrototype@,System.Boolean)">
            <inheritdoc cref="M:Robust.Shared.Prototypes.IPrototypeManager.TryIndex``1(Robust.Shared.Prototypes.ProtoId{``0},``0@,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.TryIndex``1(System.Nullable{Robust.Shared.Prototypes.ProtoId{``0}},``0@,System.Boolean)">
            <inheritdoc cref="M:Robust.Shared.Prototypes.IPrototypeManager.TryIndex``1(Robust.Shared.Prototypes.ProtoId{``0},``0@,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.HasVariant(System.String)">
            <summary>
                Returns whether a prototype variant <param name="variant"/> exists.
            </summary>
            <param name="variant">Identifier for the prototype variant.</param>
            <returns>Whether the prototype variant exists.</returns>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.GetVariantType(System.String)">
            <summary>
                Returns the Type for a prototype variant.
            </summary>
            <param name="variant">Identifier for the prototype variant.</param>
            <returns>The specified prototype Type.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">
                Thrown when the specified prototype variant isn't registered or doesn't exist.
            </exception>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.TryGetVariantType(System.String,System.Type@)">
            <summary>
                Attempts to get the Type for a prototype variant.
            </summary>
            <param name="variant">Identifier for the prototype variant.</param>
            <param name="prototype">The specified prototype Type, or null.</param>
            <returns>Whether the prototype type was found and <see cref="!:prototype"/> isn't null.</returns>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.TryGetVariantFrom(System.Type,System.String@)">
            <summary>
                Attempts to get a prototype's variant.
            </summary>
            <param name="type"></param>
            <param name="variant"></param>
            <returns></returns>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.TryGetVariantFrom(Robust.Shared.Prototypes.IPrototype,System.String@)">
            <summary>
                Attempts to get a prototype's variant.
            </summary>
            <param name="prototype">The prototype in question.</param>
            <param name="variant">Identifier for the prototype variant, or null.</param>
            <returns>Whether the prototype variant was successfully retrieved.</returns>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.TryGetVariantFrom``1(System.String@)">
            <summary>
                Attempts to get a prototype's variant.
            </summary>
            <param name="variant">Identifier for the prototype variant, or null.</param>
            <typeparam name="T">The prototype in question.</typeparam>
            <returns>Whether the prototype variant was successfully retrieved.</returns>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.HasKind(System.String)">
            <summary>
                Returns whether a prototype kind <param name="kind"/> exists.
            </summary>
            <param name="kind">Identifier for the prototype kind.</param>
            <returns>Whether the prototype kind exists.</returns>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.GetKindType(System.String)">
            <summary>
                Returns the Type for a prototype kind.
            </summary>
            <param name="kind">Identifier for the prototype kind.</param>
            <returns>The specified prototype Type.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">
                Thrown when the specified prototype kind isn't registered or doesn't exist.
            </exception>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.TryGetKindType(System.String,System.Type@)">
            <summary>
                Attempts to get the Type for a prototype kind.
            </summary>
            <param name="kind">Identifier for the prototype kind.</param>
            <param name="prototype">The specified prototype Type, or null.</param>
            <returns>Whether the prototype type was found and <see cref="!:prototype"/> isn't null.</returns>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.TryGetKindFrom(System.Type,System.String@)">
            <summary>
                Attempts to get a prototype's kind.
            </summary>
            <param name="type"></param>
            <param name="kind"></param>
            <returns></returns>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.TryGetKindFrom(Robust.Shared.Prototypes.IPrototype,System.String@)">
            <summary>
                Attempts to get a prototype's kind.
            </summary>
            <param name="prototype">The prototype in question.</param>
            <param name="kind">Identifier for the prototype kind, or null.</param>
            <returns>Whether the prototype kind was successfully retrieved.</returns>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.TryGetKindFrom``1(System.String@)">
            <summary>
                Attempts to get a prototype's kind.
            </summary>
            <param name="kind">Identifier for the prototype kind, or null.</param>
            <typeparam name="T">The prototype in question.</typeparam>
            <returns>Whether the prototype kind was successfully retrieved.</returns>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.LoadDirectory(Robust.Shared.Utility.ResPath,System.Boolean,System.Collections.Generic.Dictionary{System.Type,System.Collections.Generic.HashSet{System.String}})">
            <summary>
            Load prototypes from files in a directory, recursively.
            </summary>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.ValidateDirectory(Robust.Shared.Utility.ResPath)">
            <summary>
            Validate all prototypes defined in yaml files contained in the given directory.
            </summary>
            <param name="path">The directory containing the yaml files that need validating.</param>
            <returns>A dictionary containing sets of errors for each file that failed validation.</returns>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.ValidateDirectory(Robust.Shared.Utility.ResPath,System.Collections.Generic.Dictionary{System.Type,System.Collections.Generic.HashSet{System.String}}@)">
            <summary>
            Validate all prototypes defined in yaml files contained in the given directory.
            </summary>
            <param name="path">The directory containing the yaml files that need validating.</param>
            <param name="prototypes">The prototypes ids that were present in the directory.</param>
            <returns>A dictionary containing sets of errors for each file that failed validation.</returns>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.ValidateStaticFields(System.Collections.Generic.Dictionary{System.Type,System.Collections.Generic.HashSet{System.String}})">
            <summary>
            This method uses reflection to validate that all static prototype id fields correspond to valid prototypes.
            This will validate all known to <see cref="T:Robust.Shared.Reflection.IReflectionManager"/>
            </summary>
            <remarks>
            This will validate any field that has either a <see cref="T:Robust.Shared.Serialization.Manager.Attributes.ValidatePrototypeIdAttribute`1"/> attribute, or a
            <see cref="T:Robust.Shared.Serialization.Manager.Attributes.DataFieldAttribute"/> with a <see cref="T:Robust.Shared.Serialization.TypeSerializers.Implementations.Custom.Prototype.PrototypeIdSerializer`1"/> serializer.
            </remarks>
            <param name="prototypes">A collection prototypes to use for validation. Any prototype not in this collection
            will be considered invalid.</param>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.ValidateStaticFields(System.Type,System.Collections.Generic.Dictionary{System.Type,System.Collections.Generic.HashSet{System.String}})">
            <summary>
            This is a variant of <see cref="M:Robust.Shared.Prototypes.IPrototypeManager.ValidateStaticFields(System.Collections.Generic.Dictionary{System.Type,System.Collections.Generic.HashSet{System.String}})"/> that only validates a single type.
            </summary>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.ValidateAllPrototypesSerializable(Robust.Shared.Serialization.Manager.ISerializationContext)">
            <summary>
            This method will serialize all loaded prototypes into yaml and then validate them. This can be used to ensure
            that hard coded default values for data-fields all pass the normal yaml validation steps.
            </summary>
            <returns>Returns a collection of yaml validation errors, sorted by prototype kind id. The outer dictionary is
            empty, everything was successfully validated.</returns>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.Clear">
            <summary>
            Clear out all prototypes and reset to a blank slate.
            </summary>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.ReloadPrototypeKinds">
            <summary>
            Calls <see cref="M:Robust.Shared.Prototypes.IPrototypeManager.Clear"/> and then rediscovers all prototype kinds.
            </summary>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.Reset">
            <summary>
            Calls <see cref="M:Robust.Shared.Prototypes.IPrototypeManager.ReloadPrototypeKinds"/> and then loads prototypes from the default directories.
            </summary>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.LoadDefaultPrototypes(System.Collections.Generic.Dictionary{System.Type,System.Collections.Generic.HashSet{System.String}})">
            <summary>
            Loads prototypes from the default directories.
            </summary>
            <param name="loaded">Dictionary that will be filled with all the loaded prototypes.</param>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.ResolveResults">
            <summary>
            Syncs all inter-prototype data. Call this when operations adding new prototypes are done.
            </summary>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.ReloadPrototypes(System.Collections.Generic.Dictionary{System.Type,System.Collections.Generic.HashSet{System.String}},System.Collections.Generic.Dictionary{System.Type,System.Collections.Generic.HashSet{System.String}})">
            <summary>
            Invokes <see cref="E:Robust.Shared.Prototypes.IPrototypeManager.PrototypesReloaded"/> with information about the modified prototypes.
            When built with development tools, this will also push inheritance for reloaded prototypes/
            </summary>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.RegisterIgnore(System.String)">
            <summary>
                Registers a specific prototype name to be ignored.
            </summary>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.RegisterType(System.Type)">
            <summary>
            Loads a single prototype class type into the manager.
            </summary>
            <param name="protoClass">A prototype class type that implements IPrototype. This type also
            requires a <see cref="T:Robust.Shared.Prototypes.PrototypeAttribute"/> with a non-empty class string.</param>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.RegisterKind(System.Type[])">
            <summary>
            Loads several prototype kinds into the manager. Note that this will re-build a frozen dictionary and should be avoided if possible.
            </summary>
            <param name="kind">
            The type of the prototype kind that implements <see cref="T:Robust.Shared.Prototypes.IPrototype"/>. This type also
            requires a <see cref="T:Robust.Shared.Prototypes.PrototypeAttribute"/> with a non-empty class string.
            </param>
        </member>
        <member name="E:Robust.Shared.Prototypes.IPrototypeManager.PrototypesReloaded">
            <summary>
                Fired when prototype are reloaded. The event args contain the modified and removed prototypes.
            </summary>
            <remarks>
                This does NOT fire on initial prototype load.
            </remarks>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.GetPrototypeData(Robust.Shared.Prototypes.EntityPrototype)">
            <summary>
            Get the yaml data for a given prototype.
            </summary>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.AbstractFile(Robust.Shared.Utility.ResPath)">
            <summary>
                Forces all prototypes in the given file to be abstract.
                This makes them be read as abstract prototypes (mappings) instead of regular prototype instances.
                Calling this method will not retroactively abstract prototypes that have already been read.
            </summary>
            <param name="path">
                The file to force prototypes to be abstract in.
                This must start from the Resources-level directory, but not include Resources itself.
                For example: /Prototypes/Guidebook/antagonist.yml
            </param>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.AbstractDirectory(Robust.Shared.Utility.ResPath)">
            <summary>
                Forces all prototypes in files recursively within this directory to be abstract.
                This makes them be read as abstract prototypes (mappings) instead of regular prototype instances.
                Calling this method will not retroactively abstract prototypes that have already been read.
            </summary>
            <param name="path">
                The directory to force prototypes to be abstract in.
                This must start from the Resources-level directory, but not include Resources itself.
                For example: /Prototypes/Guidebook
            </param>
        </member>
        <member name="M:Robust.Shared.Prototypes.IPrototypeManager.TryGetRandom``1(Robust.Shared.Random.IRobustRandom,Robust.Shared.Prototypes.IPrototype@)">
            <summary>
            Tries to get a random prototype.
            </summary>
        </member>
        <member name="P:Robust.Shared.Prototypes.IPrototypeManager.Categories">
            <summary>
            Entity prototypes grouped by their categories.
            </summary>
        </member>
        <member name="T:Robust.Shared.Prototypes.PrototypesReloadedEventArgs">
            <summary>
            This is event contains information about prototypes that have been modified. It is broadcast as a system event,
            whenever <see cref="E:Robust.Shared.Prototypes.IPrototypeManager.PrototypesReloaded"/> gets invoked.
            </summary>
        </member>
        <member name="M:Robust.Shared.Prototypes.PrototypesReloadedEventArgs.#ctor(System.Collections.Generic.HashSet{System.Type},System.Collections.Generic.IReadOnlyDictionary{System.Type,Robust.Shared.Prototypes.PrototypesReloadedEventArgs.PrototypeChangeSet},System.Collections.Generic.IReadOnlyDictionary{System.Type,System.Collections.Generic.HashSet{System.String}})">
            <summary>
            This is event contains information about prototypes that have been modified. It is broadcast as a system event,
            whenever <see cref="E:Robust.Shared.Prototypes.IPrototypeManager.PrototypesReloaded"/> gets invoked.
            </summary>
        </member>
        <member name="M:Robust.Shared.Prototypes.PrototypesReloadedEventArgs.WasModified``1">
            <summary>
            Checks whether a given prototype kind was modified at all. This includes both changes and removals.
            </summary>
        </member>
        <member name="M:Robust.Shared.Prototypes.PrototypesReloadedEventArgs.TryGetModified``1(System.Collections.Generic.HashSet{System.String}@)">
            <summary>
            Returns a set of all modified prototype instances of a given kind. This includes both changes and removals.
            </summary>
        </member>
        <member name="T:Robust.Shared.Prototypes.ProtoId`1">
            <summary>
                Wrapper type for a prototype id of kind <see cref="!:T"/>.
            </summary>
            <param name="Id">The id of the prototype.</param>
            <typeparam name="T">The kind of prototype to wrap, for example <see cref="T:Robust.Shared.Prototypes.TileAliasPrototype"/></typeparam>
            <remarks>
                This will be automatically validated by <see cref="T:Robust.Shared.Serialization.TypeSerializers.Implementations.Generic.ProtoIdSerializer`1"/> if used in data fields.
            </remarks>
            <remarks><seealso cref="T:Robust.Shared.Prototypes.EntProtoId"/> for an <see cref="T:Robust.Shared.Prototypes.EntityPrototype"/> alias.</remarks>
        </member>
        <member name="M:Robust.Shared.Prototypes.ProtoId`1.#ctor(System.String)">
            <summary>
                Wrapper type for a prototype id of kind <see cref="!:T"/>.
            </summary>
            <param name="Id">The id of the prototype.</param>
            <typeparam name="T">The kind of prototype to wrap, for example <see cref="T:Robust.Shared.Prototypes.TileAliasPrototype"/></typeparam>
            <remarks>
                This will be automatically validated by <see cref="T:Robust.Shared.Serialization.TypeSerializers.Implementations.Generic.ProtoIdSerializer`1"/> if used in data fields.
            </remarks>
            <remarks><seealso cref="T:Robust.Shared.Prototypes.EntProtoId"/> for an <see cref="T:Robust.Shared.Prototypes.EntityPrototype"/> alias.</remarks>
        </member>
        <member name="P:Robust.Shared.Prototypes.ProtoId`1.Id">
            <summary>The id of the prototype.</summary>
        </member>
        <member name="F:Robust.Shared.Prototypes.PrototypeManager._autoComps">
            <summary>
            Cached array of components with the <see cref="T:Robust.Shared.Prototypes.EntityCategoryAttribute"/>
            </summary>
        </member>
        <member name="M:Robust.Shared.Prototypes.PrototypeManager.GetPrototypeKinds">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Prototypes.PrototypeManager.Count``1">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Prototypes.PrototypeManager.EnumeratePrototypes``1">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Prototypes.PrototypeManager.EnumeratePrototypes(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Prototypes.PrototypeManager.EnumeratePrototypes(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Prototypes.PrototypeManager.EnumerateParents``1(``0,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Prototypes.PrototypeManager.EnumerateParents``1(System.String,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Prototypes.PrototypeManager.EnumerateParents(System.Type,System.String,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Prototypes.PrototypeManager.EnumerateAllParents``1(System.String,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Prototypes.PrototypeManager.Index``1(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Prototypes.PrototypeManager.Index(Robust.Shared.Prototypes.EntProtoId)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Prototypes.PrototypeManager.Index``1(Robust.Shared.Prototypes.ProtoId{``0})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Prototypes.PrototypeManager.Index(System.Type,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Prototypes.PrototypeManager.Clear">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Prototypes.PrototypeManager.Reset">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Prototypes.PrototypeManager.LoadDefaultPrototypes(System.Collections.Generic.Dictionary{System.Type,System.Collections.Generic.HashSet{System.String}})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Prototypes.PrototypeManager.ReloadPrototypes(System.Collections.Generic.Dictionary{System.Type,System.Collections.Generic.HashSet{System.String}},System.Collections.Generic.Dictionary{System.Type,System.Collections.Generic.HashSet{System.String}})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Prototypes.PrototypeManager.ResolveResults">
            <summary>
            Resolves the mappings stored in memory to actual prototypeinstances.
            </summary>
        </member>
        <member name="M:Robust.Shared.Prototypes.PrototypeManager.ReloadPrototypeKinds">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Prototypes.PrototypeManager.HasIndex``1(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Prototypes.PrototypeManager.HasIndex(Robust.Shared.Prototypes.EntProtoId)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Prototypes.PrototypeManager.HasIndex``1(Robust.Shared.Prototypes.ProtoId{``0})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Prototypes.PrototypeManager.HasIndex(System.Nullable{Robust.Shared.Prototypes.EntProtoId})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Prototypes.PrototypeManager.HasIndex``1(System.Nullable{Robust.Shared.Prototypes.ProtoId{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Prototypes.PrototypeManager.TryIndex``1(System.String,``0@)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Prototypes.PrototypeManager.TryIndex(System.Type,System.String,Robust.Shared.Prototypes.IPrototype@)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Prototypes.PrototypeManager.TryIndex(Robust.Shared.Prototypes.EntProtoId,Robust.Shared.Prototypes.EntityPrototype@,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Prototypes.PrototypeManager.TryIndex``1(Robust.Shared.Prototypes.ProtoId{``0},``0@,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Prototypes.PrototypeManager.TryIndex(System.Nullable{Robust.Shared.Prototypes.EntProtoId},Robust.Shared.Prototypes.EntityPrototype@,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Prototypes.PrototypeManager.TryIndex``1(System.Nullable{Robust.Shared.Prototypes.ProtoId{``0}},``0@,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Prototypes.PrototypeManager.HasMapping``1(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Prototypes.PrototypeManager.TryGetMapping(System.Type,System.String,Robust.Shared.Serialization.Markdown.Mapping.MappingDataNode@)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Prototypes.PrototypeManager.RegisterIgnore(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Prototypes.PrototypeManager.RegisterKind(System.Type[])">
            <inheritdoc />
        </member>
        <member name="E:Robust.Shared.Prototypes.PrototypeManager.PrototypesReloaded">
            <inheritdoc />
        </member>
        <member name="F:Robust.Shared.Prototypes.PrototypeManager.KindData.InstancesDirect">
            <summary>
            Variant of <see cref="F:Robust.Shared.Prototypes.PrototypeManager.KindData.Instances"/> that has a direct mapping to the prototype kind. I.e., no IPrototype interface.
            </summary>
        </member>
        <member name="M:Robust.Shared.Prototypes.PrototypeManager.ValidateStaticFields(System.Collections.Generic.Dictionary{System.Type,System.Collections.Generic.HashSet{System.String}})">
            <inheritdoc/>
        </member>
        <member name="M:Robust.Shared.Prototypes.PrototypeManager.ValidateStaticFields(System.Type,System.Collections.Generic.Dictionary{System.Type,System.Collections.Generic.HashSet{System.String}})">
            <inheritdoc/>
        </member>
        <member name="M:Robust.Shared.Prototypes.PrototypeManager.ValidateStaticFieldsInternal(System.Type,System.Collections.Generic.List{System.String},System.Collections.Generic.Dictionary{System.Type,System.Collections.Generic.HashSet{System.String}})">
            <summary>
            Validate all static fields defined on this type and all base types.
            </summary>
        </member>
        <member name="M:Robust.Shared.Prototypes.PrototypeManager.TryGetIds(System.Reflection.FieldInfo,System.Type,System.String[]@)">
            <summary>
            Extract prototype ids from a string, IEnumerable{string}, EntProtoId, IEnumerable{EntProtoId}, ProtoId{T}, or IEnumerable{ProtoId{T}} field.
            </summary>
        </member>
        <member name="F:Robust.Shared.Prototypes.PrototypeManager._abstractFiles">
            <summary>
                Which files to force all prototypes within to be abstract.
            </summary>
        </member>
        <member name="F:Robust.Shared.Prototypes.PrototypeManager._abstractDirectories">
            <summary>
                Which directories to force all prototypes recursively within to be abstract.
            </summary>
        </member>
        <member name="M:Robust.Shared.Prototypes.PrototypeManager.LoadDirectory(Robust.Shared.Utility.ResPath,System.Boolean,System.Collections.Generic.Dictionary{System.Type,System.Collections.Generic.HashSet{System.String}})">
            <inheritdoc />
        </member>
        <member name="T:Robust.Shared.Prototypes.TileAliasPrototype">
            <summary>
            Prototype that represents an alias from one tile ID to another.
            Tile alias prototypes, unlike tile prototypes, are implemented here, as they're really just fed to TileDefinitionManager.
            </summary>
        </member>
        <member name="P:Robust.Shared.Prototypes.TileAliasPrototype.Target">
            <summary>
            The target tile ID to alias to.
            </summary>
        </member>
        <member name="P:Robust.Shared.Prototypes.TileAliasPrototype.ID">
            <summary>
            The source tile ID (and the ID of this tile alias).
            </summary>
        </member>
        <member name="T:Robust.Shared.Random.IRobustRandom">
            <summary>
            Wrapper around random number generator helping methods.
            </summary>
        </member>
        <member name="M:Robust.Shared.Random.IRobustRandom.GetRandom">
            <summary> Get the underlying <see cref="N:Robust.Shared.Random"/>.</summary>
        </member>
        <member name="M:Robust.Shared.Random.IRobustRandom.SetSeed(System.Int32)">
            <summary> Set seed for underlying <see cref="N:Robust.Shared.Random"/>. </summary>
        </member>
        <member name="M:Robust.Shared.Random.IRobustRandom.NextFloat">
            <summary> Get random <see cref="T:System.Single"/> value between 0 (included) and 1 (excluded). </summary>
        </member>
        <member name="M:Robust.Shared.Random.IRobustRandom.NextFloat(System.Single,System.Single)">
            <summary> Get random <see cref="T:System.Single"/> value in range of <paramref name="minValue"/> (included) and <paramref name="maxValue"/> (excluded). </summary>
            <param name="minValue">Random value should be greater or equal to this value.</param>
            <param name="maxValue">Random value should be less then this value.</param>
        </member>
        <member name="M:Robust.Shared.Random.IRobustRandom.NextFloat(System.Single)">
            <summary> Get random <see cref="T:System.Single"/> value in range of 0 (included) and <paramref name="maxValue"/> (excluded). </summary>
            <param name="maxValue">Random value should be less then this value.</param>
        </member>
        <member name="M:Robust.Shared.Random.IRobustRandom.Next">
            <summary> Get random <see cref="T:System.Int32"/> value. </summary>
        </member>
        <member name="M:Robust.Shared.Random.IRobustRandom.Next(System.Int32)">
            <summary> Get random <see cref="T:System.Int32"/> value in range of 0 (included) and <paramref name="maxValue"/> (excluded). </summary>
            <param name="maxValue">Random value should be less then this value.</param>
        </member>
        <member name="M:Robust.Shared.Random.IRobustRandom.Next(System.Int32,System.Int32)">
            <summary> Get random <see cref="T:System.Int32"/> value in range of <paramref name="minValue"/> (included) and <paramref name="maxValue"/> (excluded). </summary>
            <param name="minValue">Random value should be greater or equal to this value.</param>
            <param name="maxValue">Random value should be less then this value.</param>
        </member>
        <member name="M:Robust.Shared.Random.IRobustRandom.NextByte">
            <summary> Get random <see cref="T:System.Byte"/> value between 0 (included) and <see cref="F:System.Byte.MaxValue"/> (excluded). </summary>
        </member>
        <member name="M:Robust.Shared.Random.IRobustRandom.NextByte(System.Byte)">
            <summary> Get random <see cref="T:System.Byte"/> value in range of 0 (included) and <paramref name="maxValue"/> (excluded). </summary>
            <param name="maxValue">Random value should be less then this value.</param>
        </member>
        <member name="M:Robust.Shared.Random.IRobustRandom.NextByte(System.Byte,System.Byte)">
            <summary> Get random <see cref="T:System.Byte"/> value in range of <paramref name="minValue"/> (included) and <paramref name="maxValue"/> (excluded). </summary>
            <param name="minValue">Random value should be greater or equal to this value.</param>
            <param name="maxValue">Random value should be less then this value.</param>
        </member>
        <member name="M:Robust.Shared.Random.IRobustRandom.NextDouble">
            <summary> Get random <see cref="T:System.Double"/> value between 0 (included) and 1 (excluded). </summary>
        </member>
        <member name="M:Robust.Shared.Random.IRobustRandom.Next(System.Double)">
            <summary> Get random <see cref="T:System.Double"/> value in range of 0 (included) and <paramref name="maxValue"/> (excluded). </summary>
            <param name="maxValue">Random value should be less then this value.</param>
        </member>
        <member name="M:Robust.Shared.Random.IRobustRandom.NextDouble(System.Double,System.Double)">
            <summary> Get random <see cref="T:System.Double"/> value in range of <paramref name="minValue"/> (included) and <paramref name="maxValue"/> (excluded). </summary>
            <param name="minValue">Random value should be greater or equal to this value.</param>
            <param name="maxValue">Random value should be less then this value.</param>
        </member>
        <member name="M:Robust.Shared.Random.IRobustRandom.Next(System.TimeSpan)">
            <summary> Get random <see cref="T:System.TimeSpan"/> value in range of <see cref="F:System.TimeSpan.Zero"/> (included) and <paramref name="maxTime"/> (excluded). </summary>
            <param name="maxTime">Random value should be less then this value.</param>
        </member>
        <member name="M:Robust.Shared.Random.IRobustRandom.Next(System.TimeSpan,System.TimeSpan)">
            <summary> Get random <see cref="T:System.TimeSpan"/> value in range of <paramref name="minTime"/> (included) and <paramref name="maxTime"/> (excluded). </summary>
            <param name="minTime">Random value should be greater or equal to this value.</param>
            <param name="maxTime">Random value should be less then this value.</param>
        </member>
        <member name="M:Robust.Shared.Random.IRobustRandom.NextBytes(System.Byte[])">
            <summary> Fill buffer with random bytes (values). </summary>
        </member>
        <member name="M:Robust.Shared.Random.IRobustRandom.NextAngle">
            <summary> Get random <see cref="T:Robust.Shared.Maths.Angle"/> value in range of 0 (included) and <see cref="F:System.MathF.Tau"/> (excluded). </summary>
        </member>
        <member name="M:Robust.Shared.Random.IRobustRandom.NextAngle(Robust.Shared.Maths.Angle)">
            <summary> Get random <see cref="T:Robust.Shared.Maths.Angle"/> value in range of 0 (included) and <paramref name="maxValue"/> (excluded). </summary>
            <param name="maxValue">Random value should be less then this value.</param>
        </member>
        <member name="M:Robust.Shared.Random.IRobustRandom.NextAngle(Robust.Shared.Maths.Angle,Robust.Shared.Maths.Angle)">
            <summary> Get random <see cref="T:Robust.Shared.Maths.Angle"/> value in range of <paramref name="minValue"/> (included) and <paramref name="maxValue"/> (excluded). </summary>
            <param name="minValue">Random value should be greater or equal to this value.</param>
            <param name="maxValue">Random value should be less then this value.</param>
        </member>
        <member name="M:Robust.Shared.Random.IRobustRandom.NextVector2(System.Single)">
            <summary>
                Random vector, created from a uniform distribution of magnitudes and angles.
            </summary>
            <param name="maxMagnitude">Max value for randomized vector magnitude (excluded).</param>
        </member>
        <member name="M:Robust.Shared.Random.IRobustRandom.NextVector2(System.Single,System.Single)">
            <summary>
                Random vector, created from a uniform distribution of magnitudes and angles.
            </summary>
            <param name="minMagnitude">Min value for randomized vector magnitude (included).</param>
            <param name="maxMagnitude">Max value for randomized vector magnitude (excluded).</param>
            <remarks>
                In general, NextVector2(1) will tend to result in vectors with smaller magnitudes than
                NextVector2Box(1,1), even if you ignored any vectors with a magnitude larger than one.
            </remarks>
        </member>
        <member name="M:Robust.Shared.Random.IRobustRandom.NextVector2Box(System.Single,System.Single,System.Single,System.Single)">
            <summary>
                Random vector, created from a uniform distribution of x and y coordinates lying inside some box.
            </summary>
        </member>
        <member name="M:Robust.Shared.Random.IRobustRandom.NextVector2Box(System.Single,System.Single)">
            <summary>
                Random vector, created from a uniform distribution of x and y coordinates lying inside some box.
                Box will have coordinates starting at [-<paramref name="maxAbsX"/> , -<paramref name="maxAbsY"/>]
                and ending in [<paramref name="maxAbsX"/> , <paramref name="maxAbsY"/>]
            </summary>
        </member>
        <member name="M:Robust.Shared.Random.IRobustRandom.Shuffle``1(System.Collections.Generic.IList{``0})">
            <summary> Randomly switches positions in collection. </summary>
        </member>
        <member name="M:Robust.Shared.Random.IRobustRandom.Shuffle``1(System.Span{``0})">
            <summary> Randomly switches positions in collection. </summary>
        </member>
        <member name="M:Robust.Shared.Random.IRobustRandom.Shuffle``1(Robust.Shared.Collections.ValueList{``0})">
            <summary> Randomly switches positions in collection. </summary>
        </member>
        <member name="M:Robust.Shared.Random.RandomExtensions.NextGaussian(Robust.Shared.Random.IRobustRandom,System.Double,System.Double)">
            <summary>
                Generate a random number from a normal (gaussian) distribution.
            </summary>
            <param name="random">The random object to generate the number from.</param>
            <param name="">The average or "center" of the normal distribution.</param>
            <param name="">The standard deviation of the normal distribution.</param>
        </member>
        <member name="M:Robust.Shared.Random.RandomExtensions.Pick``1(Robust.Shared.Random.IRobustRandom,System.Collections.Generic.IReadOnlyList{``0})">
            <summary>Picks a random element from a collection.</summary>
        </member>
        <member name="M:Robust.Shared.Random.RandomExtensions.Pick``1(Robust.Shared.Random.IRobustRandom,Robust.Shared.Collections.ValueList{``0})">
            <summary>Picks a random element from a collection.</summary>
        </member>
        <member name="M:Robust.Shared.Random.RandomExtensions.Pick``1(System.Random,Robust.Shared.Collections.ValueList{``0})">
            <summary>Picks a random element from a collection.</summary>
        </member>
        <member name="M:Robust.Shared.Random.RandomExtensions.Pick``1(Robust.Shared.Random.IRobustRandom,System.Collections.Generic.IReadOnlyCollection{``0})">
            <summary>Picks a random element from a collection.</summary>
            <remarks>
                This is O(n).
            </remarks>
        </member>
        <member name="M:Robust.Shared.Random.RandomExtensions.PickAndTake``1(Robust.Shared.Random.IRobustRandom,System.Collections.Generic.IList{``0})">
            <summary>
            Picks a random element from a list, removes it from list and returns it.
            This is O(n) as it preserves the order of other items in the list.
            </summary>
        </member>
        <member name="M:Robust.Shared.Random.RandomExtensions.Pick``1(System.Random,System.Collections.Generic.ICollection{``0})">
            <summary>
            Picks a random element from a set and returns it.
            This is O(n) as it has to iterate the collection until the target index.
            </summary>
        </member>
        <member name="M:Robust.Shared.Random.RandomExtensions.PickAndTake``1(System.Random,System.Collections.Generic.ICollection{``0})">
            <summary>
            Picks a random from a collection then removes it and returns it.
            This is O(n) as it has to iterate the collection until the target index.
            </summary>
        </member>
        <member name="M:Robust.Shared.Random.RandomExtensions.NextGaussian(System.Random,System.Double,System.Double)">
            <summary>
                Generate a random number from a normal (gaussian) distribution.
            </summary>
            <param name="random">The random object to generate the number from.</param>
            <param name="">The average or "center" of the normal distribution.</param>
            <param name="">The standard deviation of the normal distribution.</param>
        </member>
        <member name="M:Robust.Shared.Random.RandomExtensions.Prob(Robust.Shared.Random.IRobustRandom,System.Single)">
            <summary>
                Have a certain chance to return a boolean.
            </summary>
            <param name="random">The random instance to run on.</param>
            <param name="chance">The chance to pass, from 0 to 1.</param>
        </member>
        <member name="M:Robust.Shared.Random.RandomExtensions.GetItems``1(Robust.Shared.Random.IRobustRandom,System.Collections.Generic.IList{``0},System.Int32,System.Boolean)">
            <summary>
            Get set amount of random items from a collection.
            If <paramref name="allowDuplicates"/> is false and <paramref name="source"/>
            is smaller then <paramref name="count"/> - returns shuffled <paramref name="source"/> clone.
            If <paramref name="source"/> is empty, and/or <paramref name="count"/> is 0, returns empty.
            </summary>
            <param name="random">Instance of random to invoke upon.</param>
            <param name="source">Collection from which items should be picked.</param>
            <param name="count">Number of random items to be picked.</param>
            <param name="allowDuplicates">If true, items are allowed to be picked more than once.</param>
        </member>
        <member name="M:Robust.Shared.Random.RandomExtensions.GetItems``1(Robust.Shared.Random.IRobustRandom,Robust.Shared.Collections.ValueList{``0},System.Int32,System.Boolean)">
            <inheritdoc cref="M:Robust.Shared.Random.RandomExtensions.GetItems``1(Robust.Shared.Random.IRobustRandom,System.Collections.Generic.IList{``0},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Random.RandomExtensions.GetItems``1(Robust.Shared.Random.IRobustRandom,``0[],System.Int32,System.Boolean)">
            <inheritdoc cref="M:Robust.Shared.Random.RandomExtensions.GetItems``1(Robust.Shared.Random.IRobustRandom,System.Collections.Generic.IList{``0},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Random.RandomExtensions.GetItems``1(Robust.Shared.Random.IRobustRandom,System.Span{``0},System.Int32,System.Boolean)">
            <inheritdoc cref="M:Robust.Shared.Random.RandomExtensions.GetItems``1(Robust.Shared.Random.IRobustRandom,System.Collections.Generic.IList{``0},System.Int32,System.Boolean)"/>
        </member>
        <member name="T:Robust.Shared.Random.RobustRandom">
            <summary>
            Wrapper for <see cref="N:Robust.Shared.Random"/>.
            </summary>
            <remarks>
            This should not contain any logic, not directly related to calling specific methods of <see cref="N:Robust.Shared.Random"/>.
            To write additional logic, attached to random roll, please create interface-implemented methods on <see cref="T:Robust.Shared.Random.IRobustRandom"/>
            or add it to <see cref="T:Robust.Shared.Random.RandomExtensions"/>.
            </remarks>
        </member>
        <member name="T:Robust.Shared.Reflection.IReflectionManager">
            <summary>
            Manages common reflection operations, such as iterating over all subtypes of something.
            This is distinctly different from IoC: IoC manages services and DI.
            </summary>
            <remarks>
            <para>
            By default, all classes are "discoverable" by <see cref="T:Robust.Shared.Reflection.IReflectionManager"/>.
            This can be overriden by assigning a <see cref="T:Robust.Shared.Reflection.ReflectAttribute"/> and disabling discoverability.
            Classes which cannot be instantiated are also ignored (interfaces, abstracts)
            </para>
            <para>
            Types only become accessible when loaded using <see cref="!:LoadAssembly"/>.
            This is to prevent non-game assemblies from cluttering everything.
            </para>
            </remarks>
            <seealso cref="T:Robust.Shared.IoC.IoCManager"/>
            <seealso cref="T:Robust.Shared.Reflection.ReflectAttribute"/>
        </member>
        <member name="M:Robust.Shared.Reflection.IReflectionManager.GetAllChildren``1(System.Boolean)">
            <summary>
            Gets all known types that are assignable to <typeparamref name="T"/>.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="inclusive">
            When <code>true</code>, include <typeparamref name="T"/> in the returned results
            if it is a known type.
            </param>
            <returns>An enumerable over all the types. Order is in no way guaranteed.</returns>
        </member>
        <member name="M:Robust.Shared.Reflection.IReflectionManager.GetAllChildren(System.Type,System.Boolean)">
            <summary>
            Gets all known types that are assignable to the given type.
            </summary>
            <param name="baseType">The base type to search for.</param>
            <param name="inclusive">When <code>true</code>, include <typeparamref name="T"/> in the
            returned results if it is a known type.</param>
            <returns>An enumerable over all the types. Order is in no way guaranteed.</returns>
        </member>
        <member name="P:Robust.Shared.Reflection.IReflectionManager.Assemblies">
            <summary>
            All loaded assemblies.
            </summary>
        </member>
        <member name="M:Robust.Shared.Reflection.IReflectionManager.GetType(System.String)">
            <summary>
            Attempts to get a type by string name in the loaded assemblies.
            </summary>
            <param name="name">
            The type name to look up. Anything accepted by <see cref="M:System.Type.GetType"/> works.
            However, if the type does not start with <code>Robust.*</code> and cannot be found,
            it will add <code>Robust.Client</code>, <code>Robust.Shared</code>, etc... in front of it.
            </param>
            <returns></returns>
        </member>
        <member name="M:Robust.Shared.Reflection.IReflectionManager.FindTypesWithAttribute``1">
            <summary>
            Finds all Types in all Assemblies that have a specific Attribute.
            </summary>
            <typeparam name="T">Attribute to search for.</typeparam>
            <returns>Enumeration of all types with the specified attribute.</returns>
        </member>
        <member name="M:Robust.Shared.Reflection.IReflectionManager.FindTypesWithAttribute(System.Type)">
            <summary>
            Finds all Types in all Assemblies that have a specific Attribute.
            </summary>
            <param name="attributeType">Attribute to search for.</param>
            <returns>Enumeration of all types with the specified attribute.</returns>
        </member>
        <member name="M:Robust.Shared.Reflection.IReflectionManager.LoadAssemblies(System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary>
            Loads assemblies into the manager and get all the types.
            </summary>
        </member>
        <member name="M:Robust.Shared.Reflection.IReflectionManager.LoadAssemblies(System.Reflection.Assembly[])">
            <summary>
            Loads assemblies into the manager and get all the types.
            </summary>
        </member>
        <member name="E:Robust.Shared.Reflection.IReflectionManager.OnAssemblyAdded">
            <summary>
            Fired whenever an assembly is added through <see cref="M:Robust.Shared.Reflection.IReflectionManager.LoadAssemblies(System.Collections.Generic.IEnumerable{System.Reflection.Assembly})"/>,
            this means more types might be available from <see cref="M:Robust.Shared.Reflection.IReflectionManager.GetType(System.String)"/> and <see cref="M:Robust.Shared.Reflection.IReflectionManager.GetAllChildren``1(System.Boolean)"/>
            </summary>
        </member>
        <member name="M:Robust.Shared.Reflection.IReflectionManager.TryParseEnumReference(System.String,System.Enum@,System.Boolean)">
            <summary>
                Tries to parse an enum in the form "enum.PowerStorageAppearance.Charge", for use in prototyping.
            </summary>
            <param name="reference">
                The string enum reference, including the "enum." prefix.
                If this prefix does not exist, it is assumed to not be a reference and ignored.</param>
            <param name="enum"></param>
            <param name="shouldThrow">If true, the function will throw an exception if the given string is an invalid enum reference</param>
            <returns>
                True if the string was an enum reference that parsed correctly, false if it was not a reference.
                Note that if it was a reference and it could not be resolved, the function throws a <see cref="T:System.ArgumentException"/> instead.
            </returns>
            <exception cref="T:System.ArgumentException">
                Thrown if this string is an enum reference, but the enum could not be resolved.
            </exception>
        </member>
        <member name="M:Robust.Shared.Reflection.IReflectionManager.GetEnumReference(System.Enum)">
            <summary>
                Turns an enum into a string that can be resolved back into an enum via <see cref="!:TryParseEnumReference(string, out Enum?)"/>.
            </summary>
        </member>
        <member name="T:Robust.Shared.Reflection.ReflectAttribute">
            <summary>
            Controls additional info about discoverability from the <see cref="T:Robust.Shared.Reflection.IReflectionManager"/>.
            Note that this attribute is implicit.
            Values are assumed to be their default if this attribute is not specified.
            </summary>
            <seealso cref="T:Robust.Shared.Reflection.IReflectionManager"/>
        </member>
        <member name="F:Robust.Shared.Reflection.ReflectAttribute.DEFAULT_DISCOVERABLE">
            <summary>
            Default value for <see cref="P:Robust.Shared.Reflection.ReflectAttribute.Discoverable"/> if the attribute is not specified.
            </summary>
        </member>
        <member name="P:Robust.Shared.Reflection.ReflectAttribute.Discoverable">
            <summary>
            Controls whether this type can be seen by the <see cref="T:Robust.Shared.Reflection.IReflectionManager"/>.
            If this is false it cannot be, and will be ignored.
            </summary>
            <value><see cref="F:Robust.Shared.Reflection.ReflectAttribute.DEFAULT_DISCOVERABLE"/></value>
            <seealso cref="M:Robust.Shared.Reflection.ReflectAttribute.#ctor(System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Reflection.ReflectAttribute.#ctor(System.Boolean)">
            <summary>
            Controls whether or not the type can be discovered.
            </summary>
            <param name="discoverable">The value that will be assigned to <see cref="P:Robust.Shared.Reflection.ReflectAttribute.Discoverable"/>. True is yes, false is no.</param>
            <seealso cref="P:Robust.Shared.Reflection.ReflectAttribute.Discoverable"/>
        </member>
        <member name="P:Robust.Shared.Reflection.ReflectionManager.TypePrefixes">
            <summary>
            Enumerable over prefixes that are added to the type provided to <see cref="M:Robust.Shared.Reflection.ReflectionManager.GetType(System.String)"/>
            if the type can't be found in any assemblies.
            </summary>
            <remarks>
            First prefix should probably be <code>""</code>.
            </remarks>
        </member>
        <member name="M:Robust.Shared.Reflection.ReflectionManager.GetAllChildren``1(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Reflection.ReflectionManager.GetAllChildren(System.Type,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Reflection.ReflectionManager.GetType(System.String)">
            <seealso cref="P:Robust.Shared.Reflection.ReflectionManager.TypePrefixes"/>
        </member>
        <member name="M:Robust.Shared.Reflection.ReflectionManager.LooseGetType(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Reflection.ReflectionManager.FindTypesWithAttribute``1">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Reflection.ReflectionManager.FindTypesWithAttribute(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Reflection.ReflectionManager.GetEnumReference(System.Enum)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Reflection.ReflectionManager.TryParseEnumReference(System.String,System.Enum@,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Replays.IReplayRecordingManager.CanStartRecording">
            <summary>
            Whether or not a replay recording can currently be started.
            </summary>
        </member>
        <member name="M:Robust.Shared.Replays.IReplayRecordingManager.RecordServerMessage(System.Object)">
            <summary>
            This is a convenience variation of <see cref="M:Robust.Shared.Replays.IReplayRecordingManager.RecordReplayMessage(System.Object)"/> that only records messages for server-side
            recordings.
            </summary>
        </member>
        <member name="M:Robust.Shared.Replays.IReplayRecordingManager.RecordClientMessage(System.Object)">
            <summary>
            This is a convenience variation of <see cref="M:Robust.Shared.Replays.IReplayRecordingManager.RecordReplayMessage(System.Object)"/> that only records messages for client-side
            recordings.
            </summary>
        </member>
        <member name="M:Robust.Shared.Replays.IReplayRecordingManager.RecordReplayMessage(System.Object)">
            <summary>
            Queues some net-serializable data to be saved by a replay recording. Does nothing if <see cref="P:Robust.Shared.Replays.IReplayRecordingManager.IsRecording"/>
            is false.
            </summary>
            <remarks>
            The queued object is typically something like an <see cref="T:Robust.Shared.GameObjects.EntityEventArgs"/>, so that replays can
            simulate receiving networked messages. However, this can really be any serializable data and could be used
            for saving server-exclusive data like power net or atmos pipe-net data for replaying. Alternatively, those
            could also just use networked component states on entities that are in null space and hidden from all
            players (but still saved to replays).
            </remarks>
        </member>
        <member name="P:Robust.Shared.Replays.IReplayRecordingManager.IsRecording">
            <summary>
                Whether the server is currently recording replay data.
            </summary>
        </member>
        <member name="P:Robust.Shared.Replays.IReplayRecordingManager.ActiveRecordingState">
            <summary>
            Gets the <c>state</c> object passed into <see cref="M:Robust.Shared.Replays.IReplayRecordingManager.TryStartRecording(Robust.Shared.ContentPack.IWritableDirProvider,System.String,System.Boolean,System.Nullable{System.TimeSpan},System.Object)"/> for the current recording.
            </summary>
            <remarks>
            Returns <see langword="null"/> if there is no active replay recording.
            </remarks>
        </member>
        <member name="M:Robust.Shared.Replays.IReplayRecordingManager.Update(Robust.Shared.GameStates.GameState)">
            <summary>
            Processes pending write tasks and saves the replay data for the current tick. This should be called even if a
            replay is not currently being recorded.
            </summary>
        </member>
        <member name="E:Robust.Shared.Replays.IReplayRecordingManager.RecordingStarted">
            <summary>
            This gets invoked whenever a replay recording is starting. Subscribers can use this to add extra yaml data
            to the recording's metadata file, as well as to provide serializable messages that get replayed when the replay
            is initially loaded. E.g., this should contain networked events that would get sent to a newly connected client.
            </summary>
        </member>
        <member name="E:Robust.Shared.Replays.IReplayRecordingManager.RecordingStopped">
            <summary>
            This gets invoked whenever a replay recording is stopping. Subscribers can use this to add extra yaml data to the
            recording's metadata file.
            </summary>
            <seealso cref="E:Robust.Shared.Replays.IReplayRecordingManager.RecordingStopped2"/>
        </member>
        <member name="E:Robust.Shared.Replays.IReplayRecordingManager.RecordingStopped2">
            <summary>
            This gets invoked whenever a replay recording is stopping. Subscribers can use this to add extra data to the replay.
            </summary>
            <remarks>
            This is effectively a more powerful version of <see cref="E:Robust.Shared.Replays.IReplayRecordingManager.RecordingStopped"/>.
            </remarks>
        </member>
        <member name="E:Robust.Shared.Replays.IReplayRecordingManager.RecordingFinished">
            <summary>
            This gets invoked after a replay recording has finished and provides information about where the replay data
            was saved. Note that this only means that all write tasks have started, however some of the file tasks may not
            have finished yet. See <see cref="M:Robust.Shared.Replays.IReplayRecordingManager.WaitWriteTasks"/>.
            </summary>
        </member>
        <member name="M:Robust.Shared.Replays.IReplayRecordingManager.TryStartRecording(Robust.Shared.ContentPack.IWritableDirProvider,System.String,System.Boolean,System.Nullable{System.TimeSpan},System.Object)">
            <summary>
            Tries to starts a replay recording.
            </summary>
            <param name="directory">
            The directory that the replay will be written to. E.g., <see cref="P:Robust.Shared.ContentPack.IResourceManager.UserData"/>.
            </param>
            <param name="name">
            The name of the replay. This will also determine the folder where the replay will be stored, which will be a
            subfolder within  <see cref="F:Robust.Shared.CVars.ReplayDirectory"/>. If not provided, will default to using the current time.
            </param>
            <param name="overwrite">
            Whether to overwrite the specified path if a folder already exists.
            </param>
            <param name="duration">
            Optional time limit for the recording.
            </param>
            <param name="state">
            An arbitrary object that is available in <see cref="P:Robust.Shared.Replays.IReplayRecordingManager.ActiveRecordingState"/> and <see cref="E:Robust.Shared.Replays.IReplayRecordingManager.RecordingFinished"/>.
            </param>
            <returns>Returns true if the recording was successfully started.</returns>
        </member>
        <member name="M:Robust.Shared.Replays.IReplayRecordingManager.StopRecording">
            <summary>
            Stops an ongoing replay recording.
            </summary>
        </member>
        <member name="M:Robust.Shared.Replays.IReplayRecordingManager.GetReplayStats">
            <summary>
            Returns information about the currently ongoing replay recording.
            </summary>
        </member>
        <member name="M:Robust.Shared.Replays.IReplayRecordingManager.WaitWriteTasks">
            <summary>
            Returns a task that will wait for all the current writing tasks to finish.
            </summary>
            <exception cref="T:System.InvalidOperationException">
            Thrown if we are currently recording (<see cref="P:Robust.Shared.Replays.IReplayRecordingManager.IsRecording"/> true).
            </exception>
        </member>
        <member name="M:Robust.Shared.Replays.IReplayRecordingManager.IsWriting">
            <summary>
            Returns true if there are any currently running write tasks.
            </summary>
        </member>
        <member name="T:Robust.Shared.Replays.ReplayRecordingStopped">
            <summary>
            Event object used by <see cref="E:Robust.Shared.Replays.IReplayRecordingManager.RecordingStopped2"/>.
            Allows modifying metadata and adding more data to replay files.
            </summary>
        </member>
        <member name="P:Robust.Shared.Replays.ReplayRecordingStopped.Metadata">
            <summary>
            Mutable metadata that will be saved to the replay's metadata file.
            </summary>
        </member>
        <member name="P:Robust.Shared.Replays.ReplayRecordingStopped.Writer">
            <summary>
            A writer that allows arbitrary file writing into the replay file.
            </summary>
        </member>
        <member name="T:Robust.Shared.Replays.ReplayRecordingFinished">
            <summary>
            Event data for <see cref="E:Robust.Shared.Replays.IReplayRecordingManager.RecordingFinished"/>.
            </summary>
            <param name="Directory">The writable dir provider in which the replay is being recorded.</param>
            <param name="Path">The path to the replay in <paramref name="Directory"/>.</param>
            <param name="State">The state object passed to <see cref="M:Robust.Shared.Replays.IReplayRecordingManager.TryStartRecording(Robust.Shared.ContentPack.IWritableDirProvider,System.String,System.Boolean,System.Nullable{System.TimeSpan},System.Object)"/>.</param>
        </member>
        <member name="M:Robust.Shared.Replays.ReplayRecordingFinished.#ctor(Robust.Shared.ContentPack.IWritableDirProvider,Robust.Shared.Utility.ResPath,System.Object)">
            <summary>
            Event data for <see cref="E:Robust.Shared.Replays.IReplayRecordingManager.RecordingFinished"/>.
            </summary>
            <param name="Directory">The writable dir provider in which the replay is being recorded.</param>
            <param name="Path">The path to the replay in <paramref name="Directory"/>.</param>
            <param name="State">The state object passed to <see cref="M:Robust.Shared.Replays.IReplayRecordingManager.TryStartRecording(Robust.Shared.ContentPack.IWritableDirProvider,System.String,System.Boolean,System.Nullable{System.TimeSpan},System.Object)"/>.</param>
        </member>
        <member name="P:Robust.Shared.Replays.ReplayRecordingFinished.Directory">
            <summary>The writable dir provider in which the replay is being recorded.</summary>
        </member>
        <member name="P:Robust.Shared.Replays.ReplayRecordingFinished.Path">
            <summary>The path to the replay in <paramref name="Directory"/>.</summary>
        </member>
        <member name="P:Robust.Shared.Replays.ReplayRecordingFinished.State">
            <summary>The state object passed to <see cref="M:Robust.Shared.Replays.IReplayRecordingManager.TryStartRecording(Robust.Shared.ContentPack.IWritableDirProvider,System.String,System.Boolean,System.Nullable{System.TimeSpan},System.Object)"/>.</summary>
        </member>
        <member name="T:Robust.Shared.Replays.ReplayRecordingStats">
            <summary>
            Statistics for an active replay recording.
            </summary>
            <param name="Time">The simulation time the replay has been recording for.</param>
            <param name="Ticks">The amount of simulation ticks the replay has recorded.</param>
            <param name="Size">The total compressed size of the replay data blobs.</param>
            <param name="UncompressedSize">The total uncompressed size of the replay data blobs.</param>
        </member>
        <member name="M:Robust.Shared.Replays.ReplayRecordingStats.#ctor(System.TimeSpan,System.UInt32,System.Int64,System.Int64)">
            <summary>
            Statistics for an active replay recording.
            </summary>
            <param name="Time">The simulation time the replay has been recording for.</param>
            <param name="Ticks">The amount of simulation ticks the replay has recorded.</param>
            <param name="Size">The total compressed size of the replay data blobs.</param>
            <param name="UncompressedSize">The total uncompressed size of the replay data blobs.</param>
        </member>
        <member name="P:Robust.Shared.Replays.ReplayRecordingStats.Time">
            <summary>The simulation time the replay has been recording for.</summary>
        </member>
        <member name="P:Robust.Shared.Replays.ReplayRecordingStats.Ticks">
            <summary>The amount of simulation ticks the replay has recorded.</summary>
        </member>
        <member name="P:Robust.Shared.Replays.ReplayRecordingStats.Size">
            <summary>The total compressed size of the replay data blobs.</summary>
        </member>
        <member name="P:Robust.Shared.Replays.ReplayRecordingStats.UncompressedSize">
            <summary>The total uncompressed size of the replay data blobs.</summary>
        </member>
        <member name="T:Robust.Shared.Replays.IReplayFileWriter">
            <summary>
            Allows writing extra files directly into the replay file.
            </summary>
            <seealso cref="T:Robust.Shared.Replays.ReplayRecordingStopped"/>
            <seealso cref="E:Robust.Shared.Replays.IReplayRecordingManager.RecordingStopped2"/>
        </member>
        <member name="P:Robust.Shared.Replays.IReplayFileWriter.BaseReplayPath">
            <summary>
            The base directory inside the replay directory you should generally be writing to.
            This is equivalent to <see cref="F:Robust.Shared.Replays.ReplayConstants.ReplayZipFolder"/>.
            </summary>
        </member>
        <member name="M:Robust.Shared.Replays.IReplayFileWriter.WriteBytes(Robust.Shared.Utility.ResPath,System.ReadOnlyMemory{System.Byte},System.IO.Compression.CompressionLevel)">
            <summary>
            Writes arbitrary data into a file in the replay.
            </summary>
            <param name="path">The file path to write to.</param>
            <param name="bytes">The bytes to write to the file.</param>
            <param name="compressionLevel">How much to compress the file.</param>
        </member>
        <member name="T:Robust.Shared.Replays.IReplayRecordingManagerInternal">
            <summary>
            Engine-internal functions for <see cref="T:Robust.Shared.Replays.IReplayRecordingManager"/>.
            </summary>
        </member>
        <member name="M:Robust.Shared.Replays.IReplayRecordingManagerInternal.Initialize">
            <summary>
            Initializes the replay manager.
            </summary>
        </member>
        <member name="M:Robust.Shared.Replays.IReplayRecordingManagerInternal.Shutdown">
            <summary>
            Shut down any active replay recording, at engine shutdown.
            </summary>
        </member>
        <member name="T:Robust.Shared.Replays.ReplayConstants">
            <summary>
            Contains various constants related to the replay recording subsystem.
            </summary>
        </member>
        <member name="F:Robust.Shared.Replays.ReplayConstants.Ext">
            <summary>
            File extension for data files that have to be deserialized and decompressed.
            </summary>
        </member>
        <member name="F:Robust.Shared.Replays.ReplayConstants.DataFilePrefix">
            <summary>
            Prefix used by serialized data messages.
            </summary>
        </member>
        <member name="F:Robust.Shared.Replays.ReplayConstants.FileMeta">
            <summary>
            File that contains primary replay metadata.
            </summary>
        </member>
        <member name="F:Robust.Shared.Replays.ReplayConstants.FileMetaFinal">
            <summary>
            File that contains final replay metadata written at the end of a successful recording.
            </summary>
        </member>
        <member name="F:Robust.Shared.Replays.ReplayConstants.FileCvars">
            <summary>
            File that contains CVars at the start of a recording.
            </summary>
        </member>
        <member name="F:Robust.Shared.Replays.ReplayConstants.FileStrings">
            <summary>
            File that contains the serialization string map (<see cref="T:Robust.Shared.Serialization.IRobustMappedStringSerializer"/>).
            </summary>
        </member>
        <member name="F:Robust.Shared.Replays.ReplayConstants.FileInit">
            <summary>
            File that contains extra initialization objects provided by content.
            </summary>
        </member>
        <member name="F:Robust.Shared.Replays.ReplayConstants.ReplayZipFolder">
            <summary>
            Folder inside replay zip files that replay data is contained in.
            </summary>
        </member>
        <member name="F:Robust.Shared.Replays.ReplayConstants.MetaKeyTypeHash">
            <summary>
            Type hash from <see cref="T:Robust.Shared.Serialization.IRobustSerializer"/>.
            </summary>
        </member>
        <member name="F:Robust.Shared.Replays.ReplayConstants.MetaKeyComponentHash">
            <summary>
            Component hash from <see cref="T:Robust.Shared.GameObjects.IComponentFactory"/>.
            </summary>
        </member>
        <member name="F:Robust.Shared.Replays.ReplayConstants.MetaKeyStringHash">
            <summary>
            String hash from <see cref="T:Robust.Shared.Serialization.IRobustMappedStringSerializer"/>.
            </summary>
        </member>
        <member name="F:Robust.Shared.Replays.ReplayConstants.MetaKeyTime">
            <summary>
            Time the recording was started, in UTC.
            </summary>
        </member>
        <member name="F:Robust.Shared.Replays.ReplayConstants.MetaKeyName">
            <summary>
            The name of the recording.
            </summary>
        </member>
        <member name="F:Robust.Shared.Replays.ReplayConstants.MetaKeyStartTick">
            <summary>
            The tick the recording was started at.
            </summary>
        </member>
        <member name="F:Robust.Shared.Replays.ReplayConstants.MetaKeyStartTime">
            <summary>
            The server time the recording was started at.
            </summary>
        </member>
        <member name="F:Robust.Shared.Replays.ReplayConstants.MetaKeyBaseTick">
            <summary>
            The base tick from <see cref="T:Robust.Shared.Timing.IGameTiming"/> when the recording was started.
            </summary>
        </member>
        <member name="F:Robust.Shared.Replays.ReplayConstants.MetaKeyBaseTime">
            <summary>
            The base time from <see cref="T:Robust.Shared.Timing.IGameTiming"/> when the recording was started.
            </summary>
        </member>
        <member name="F:Robust.Shared.Replays.ReplayConstants.MetaKeyEngineVersion">
            <summary>
            The engine version that was recorded on.
            </summary>
        </member>
        <member name="F:Robust.Shared.Replays.ReplayConstants.MetaKeyForkId">
            <summary>
            The build fork ID that was recorded on.
            </summary>
        </member>
        <member name="F:Robust.Shared.Replays.ReplayConstants.MetaKeyForkVersion">
            <summary>
            The build fork version that was recorded on.
            </summary>
        </member>
        <member name="F:Robust.Shared.Replays.ReplayConstants.MetaKeyIsClientRecording">
            <summary>
            Is this a client-side recording?
            </summary>
        </member>
        <member name="F:Robust.Shared.Replays.ReplayConstants.MetaKeyRecordedBy">
            <summary>
            If this is a client recording, what is the User ID player.
            </summary>
        </member>
        <member name="F:Robust.Shared.Replays.ReplayConstants.MetaFinalKeyFileCount">
            <summary>
            How many individual data files have been recorded in total.
            </summary>
        </member>
        <member name="F:Robust.Shared.Replays.ReplayConstants.MetaFinalKeyDuration">
            <summary>
            Length of the recording.
            </summary>
        </member>
        <member name="F:Robust.Shared.Replays.ReplayConstants.MetaFinalKeyCompressedSize">
            <summary>
            Compressed total size of the replay data files.
            </summary>
        </member>
        <member name="F:Robust.Shared.Replays.ReplayConstants.MetaFinalKeyUncompressedSize">
            <summary>
            Uncompressed total size of the replay data files.
            </summary>
        </member>
        <member name="F:Robust.Shared.Replays.ReplayConstants.MetaFinalKeyEndTick">
            <summary>
            Tick the recording ends at.
            </summary>
        </member>
        <member name="F:Robust.Shared.Replays.ReplayConstants.MetaFinalKeyEndTime">
            <summary>
            Time the recording ends at.
            </summary>
        </member>
        <member name="T:Robust.Shared.Replays.ReplayData">
            <summary>
                This class contains data read from some replay recording.
            </summary>
        </member>
        <member name="F:Robust.Shared.Replays.ReplayData.States">
            <summary>
            List of game states for each tick.
            </summary>
        </member>
        <member name="F:Robust.Shared.Replays.ReplayData.Messages">
            <summary>
            List of all networked messages and variables that were sent each tick.
            </summary>
        </member>
        <member name="F:Robust.Shared.Replays.ReplayData.ReplayTime">
            <summary>
            Replay recording time for each corresponding entry in <see cref="F:Robust.Shared.Replays.ReplayData.States"/>. Starts at 0.
            </summary>
            <remarks>
            This array exists mainly because the tickrate may change throughout a replay, so this makes it significantly
            easier to jump to some specific point in time.
            </remarks>
        </member>
        <member name="F:Robust.Shared.Replays.ReplayData.TickOffset">
            <summary>
            The first tick in this recording.
            </summary>
        </member>
        <member name="F:Robust.Shared.Replays.ReplayData.StartTime">
            <summary>
            The sever's time when the recording was started.
            </summary>
        </member>
        <member name="F:Robust.Shared.Replays.ReplayData.Duration">
            <summary>
            The length of this recording.
            </summary>
        </member>
        <member name="F:Robust.Shared.Replays.ReplayData.Checkpoints">
            <summary>
            Array of checkpoint states. These are full game states that make it faster to jump around in time.
            </summary>
        </member>
        <member name="P:Robust.Shared.Replays.ReplayData.CurrentIndex">
            <summary>
            This indexes the <see cref="F:Robust.Shared.Replays.ReplayData.States"/> and <see cref="F:Robust.Shared.Replays.ReplayData.Messages"/> lists. It is basically the "current tick"
            but without the <see cref="F:Robust.Shared.Replays.ReplayData.TickOffset"/> .
            </summary>
            <remarks>
            A negative value implies that the initial replay state has not yet been loaded (e.g., setting up cvars).
            </remarks>
        </member>
        <member name="F:Robust.Shared.Replays.ReplayData.Recorder">
            <summary>
            If this is a client-side recording, this is the user that recorded that replay. Useful for setting default
            observer spawn positions.
            </summary>
        </member>
        <member name="F:Robust.Shared.Replays.ReplayData.InitialMessages">
            <summary>
            The initial set of messages that were added to the recording before any tick was ever recorded. This might
            contain data required to properly parse the rest of the recording (e.g., prototype uploads)
            </summary>
        </member>
        <member name="T:Robust.Shared.Replays.CheckpointState">
            <summary>
            Checkpoints are full game states that make it faster to jump around in time. I.e., instead of having to apply 1000
            game states to get from tick 1 to 1001, you can jump directly to the nearest checkpoint and apply much fewer states.
            </summary>
        </member>
        <member name="F:Robust.Shared.Replays.CheckpointState.AttachedStates">
             <summary>
             This is a variant of <see cref="F:Robust.Shared.Replays.CheckpointState.FullState"/> for client-side replays that only contains information about entities
             not currently detached due to PVS range limits (see <see cref="F:Robust.Shared.Replays.CheckpointState.Detached"/>).
             </summary>
             <remarks>
             This is required because we need <see cref="F:Robust.Shared.Replays.CheckpointState.FullState"/> to update the full server state when jumping forward in
             time, but in general we do not want to apply the old-state from detached entities.
            
             To see why this is needed, consider a scenario where entity A parented to entity B. Then both leave PVS and
             ONLY entity B gets deleted. The client will not receive the new transform state for entity A, and if we blindly
             apply the full set of the most recent server states it will cause entity A to throw errors.
             </remarks>
        </member>
        <member name="M:Robust.Shared.Replays.CheckpointState.DummyState(System.Int32)">
            <summary>
                Get a dummy state for use with bisection searches.
            </summary>
        </member>
        <member name="T:Robust.Shared.Replays.ReplayMessage">
            <summary>
            Collection of all networked messages and variables that were sent in a given tick.
            </summary>
        </member>
        <member name="M:Robust.Shared.Replays.SharedReplayRecordingManager.StopRecording">
            <inheritdoc/>
        </member>
        <member name="M:Robust.Shared.Replays.SharedReplayRecordingManager.TryStartRecording(Robust.Shared.ContentPack.IWritableDirProvider,System.String,System.Boolean,System.Nullable{System.TimeSpan},System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Robust.Shared.Replays.SharedReplayRecordingManager.WriteInitialMetadata(System.String,Robust.Shared.Replays.SharedReplayRecordingManager.RecordingState)">
            <summary>
                Write general replay data required to read the rest of the replay. We write this at the beginning rather than at the end on the off-chance that something goes wrong along the way and the recording is incomplete.
            </summary>
        </member>
        <member name="M:Robust.Shared.Replays.SharedReplayRecordingManager.GetServerBuildInformation">
            <summary>
            Get information describing the server build.
            This will be embedded in replay content bundles to allow the launcher to directly load them.
            </summary>
            <returns>null if we do not have build information.</returns>
        </member>
        <member name="T:Robust.Shared.Replays.SharedReplayRecordingManager.RecordingState">
            <summary>
            Contains all state related to an active recording.
            </summary>
        </member>
        <member name="T:Robust.Shared.Resources.RsiLoading">
            <summary>
            RSI manipulation and loading behavior. Server (Packaging/ACZ) and client (loading).
            </summary>
        </member>
        <member name="F:Robust.Shared.Resources.RsiLoading.MINIMUM_RSI_VERSION">
            <summary>
                The minimum version of RSI we can load.
            </summary>
        </member>
        <member name="F:Robust.Shared.Resources.RsiLoading.MAXIMUM_RSI_VERSION">
            <summary>
                The maximum version of RSI we can load.
            </summary>
        </member>
        <member name="M:Robust.Shared.Sandboxing.ISandboxHelper.CreateInstance(System.Type)">
            <summary>
                Effectively equivalent to <see cref="M:System.Activator.CreateInstance(System.Type)"/> but safe for content use.
            </summary>
            <exception cref="T:Robust.Shared.SandboxArgumentException">
            Thrown if <paramref name="type"/> is not defined in content.
            </exception>
            <seealso cref="!:IDynamicTypeFactory.CreateInstance(System.Type)"/>
        </member>
        <member name="T:Robust.Shared.Serialization.ConstantsForAttribute">
             <summary>
             Attribute for marking an enum type as being the constant representation for a field.
            
             Some fields are arbitrary ints, but it's helpful for readability to have them be
             named constants instead. This allows for that.
            
             NB: AllowMultiple is <c>true</c> - don't assume the same representation cannot
             be reused between multiple fields.
             </summary>
        </member>
        <member name="M:Robust.Shared.Serialization.ConstantsForAttribute.#ctor(System.Type)">
            <summary>
            An attribute with tag type <paramref name="tag"/>
            </summary>
            <param name="tag">
            An arbitrary tag type used for coordinating between the data field and the
            representation. Not actually used for serialization/deserialization.
            </param>
        </member>
        <member name="T:Robust.Shared.Serialization.FlagsForAttribute">
             <summary>
             Attribute for marking an enum type as being the bitflag representation for a field.
            
             Some int values in the engine are bitflags, but the actual bitflag definitions
             are reserved for the content layer. This means that serialization/deserialization
             of those flags into readable YAML is impossible, unless the engine is notified
             that a certain representation should be used. That's the role of this attribute.
            
             NB: AllowMultiple is <c>true</c> - don't assume the same representation cannot
             be reused between multiple fields.
             </summary>
        </member>
        <member name="M:Robust.Shared.Serialization.FlagsForAttribute.#ctor(System.Type)">
            <summary>
            An attribute with tag type <paramref name="tag"/>
            </summary>
            <param name="tag">
            An arbitrary tag type used for coordinating between the data field and the
            representation. Not actually used for serialization/deserialization.
            </param>
        </member>
        <member name="P:Robust.Shared.Serialization.IRobustMappedStringSerializer.TypeSerializer">
            <summary>
                The type serializer to register with NetSerializer.
            </summary>
        </member>
        <member name="M:Robust.Shared.Serialization.IRobustMappedStringSerializer.Handshake(Robust.Shared.Network.INetChannel)">
            <summary>
            Starts the handshake from the server end of the given channel,
            sending a <see cref="T:Robust.Shared.Network.Messages.MsgMapStrServerHandshake"/>.
            </summary>
            <param name="channel">The network channel to perform the handshake over.</param>
            <remarks>
            Locks the string mapping if this is the first time the server is
            performing the handshake.
            </remarks>
            <seealso cref="T:Robust.Shared.Network.Messages.MsgMapStrClientHandshake"/>
            <seealso cref="T:Robust.Shared.Network.Messages.MsgMapStrStrings"/>
        </member>
        <member name="P:Robust.Shared.Serialization.IRobustMappedStringSerializer.MappedStringsHash">
            <value>
            The hash of the string mapping.
            </value>
            <exception cref="T:System.InvalidOperationException">
            Thrown if the mapping is not locked.
            </exception>
        </member>
        <member name="M:Robust.Shared.Serialization.IRobustMappedStringSerializer.AddString(System.String)">
            <summary>
            Add a string to the constant mapping.
            </summary>
            <remarks>
            If the string has multiple detectable subcomponents, such as a
            filepath, it may result in more than one string being added to
            the mapping. As string parts are commonly sent as subsets or
            scoped names, this increases the likelyhood of a successful
            string mapping.
            </remarks>
            <returns>
            <c>true</c> if the string was added to the mapping for the first
            time, <c>false</c> otherwise.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            Thrown if the string is not normalized (<see cref="M:System.String.IsNormalized"/>).
            </exception>
        </member>
        <member name="M:Robust.Shared.Serialization.IRobustMappedStringSerializer.AddStrings(System.Reflection.Assembly)">
            <summary>
            Add the constant strings from an <see cref="T:System.Reflection.Assembly"/> to the
            mapping.
            </summary>
            <param name="asm">The assembly from which to collect constant strings.</param>
        </member>
        <member name="M:Robust.Shared.Serialization.IRobustMappedStringSerializer.AddStrings(YamlDotNet.RepresentationModel.YamlStream)">
            <summary>
            Add strings from the given <see cref="T:YamlDotNet.RepresentationModel.YamlStream"/> to the mapping.
            </summary>
            <remarks>
            Strings are taken from YAML anchors, tags, and leaf nodes.
            </remarks>
            <param name="yaml">The YAML to collect strings from.</param>
        </member>
        <member name="M:Robust.Shared.Serialization.IRobustMappedStringSerializer.AddStrings(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Add strings from the given enumeration to the mapping.
            </summary>
            <param name="strings">The strings to add.</param>
        </member>
        <member name="E:Robust.Shared.Serialization.IRobustMappedStringSerializer.ClientHandshakeComplete">
            <summary>
            See <see cref="M:Robust.Shared.Serialization.RobustMappedStringSerializer.OnClientCompleteHandshake(Robust.Shared.Network.INetManager,Robust.Shared.Network.INetChannel)"/>.
            </summary>
        </member>
        <member name="M:Robust.Shared.Serialization.IRobustMappedStringSerializer.LockStrings">
            <summary>
                Lock the string mapping so that no new strings may be added,
                and generate the strings package that can be sent to clients.
            </summary>
        </member>
        <member name="M:Robust.Shared.Serialization.IRobustSerializer.SerializeDirect``1(System.IO.Stream,``0)">
            <summary>
            Serializes an object with exact known type to skip a type ID header.
            </summary>
            <remarks>
            This is more efficient than <see cref="M:Robust.Shared.Serialization.IRobustSerializer.Serialize(System.IO.Stream,System.Object)"/> because it does not use a few bytes on type ID header.
            Output from this method is not compatible with <see cref="M:Robust.Shared.Serialization.IRobustSerializer.Deserialize(System.IO.Stream)"/> or vice versa.
            The type argument of the <see cref="M:Robust.Shared.Serialization.IRobustSerializer.DeserializeDirect``1(System.IO.Stream,``0@)"/> call must also match, obviously.
            </remarks>
            <param name="stream">The stream to write into.</param>
            <param name="toSerialize">
            The object to serialize.
            The object MUST have the exact type of <typeparamref name="T"/>
            </param>
            <typeparam name="T">The type of object to serialize.</typeparam>
        </member>
        <member name="M:Robust.Shared.Serialization.IRobustSerializer.DeserializeDirect``1(System.IO.Stream,``0@)">
            <summary>
            Deserialize side of <see cref="M:Robust.Shared.Serialization.IRobustSerializer.DeserializeDirect``1(System.IO.Stream,``0@)"/>.
            </summary>
            <param name="stream">Stream to read from.</param>
            <param name="value">Value that was deserialized.</param>
            <typeparam name="T">Exact type of object to deserialize.</typeparam>
        </member>
        <member name="M:Robust.Shared.Serialization.IRobustSerializer.FindSerializedType(System.Type,System.String)">
            <summary>
            Searches for a type with a given SerializedName that can be assigned to another type.
            </summary>
            <param name="assignableType">object type that it can be assigned to, like a base class or interface.</param>
            <param name="serializedTypeName">The serializedName inside the <see cref="T:Robust.Shared.Serialization.NetSerializableAttribute"/>.</param>
            <returns>Type found, if any.</returns>
        </member>
        <member name="M:Robust.Shared.Serialization.ISerializationGenerated`1.Copy(`0@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref="M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Serialization.ISerializationGenerated`1.InternalCopy(`0@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref="M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Serialization.ISerializationGenerated`1.Instantiate">
            <seealso cref="M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Serialization.ISerializationGenerated.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref="M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Shared.Serialization.ISerializationHooks">
            <summary>
            Provides a method that gets executed after deserialization is complete and a method that gets executed before serialization
            </summary>
        </member>
        <member name="M:Robust.Shared.Serialization.ISerializationHooks.AfterDeserialization">
            <summary>
            Gets executed after deserialization is complete
            </summary>
        </member>
        <member name="T:Robust.Shared.Serialization.Manager.Attributes.AlwaysPushInheritanceAttribute">
            <summary>
            Adds the parent DataDefinition field to this field.
            </summary>
        </member>
        <member name="T:Robust.Shared.Serialization.Manager.Attributes.CopyByRefAttribute">
             <summary>
                 Makes a type always be copied by reference when using it as the generic parameter in
                 <see cref="M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/> and <see cref="M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>.
                 This means that the source instance is returned directly.
                 This attribute is not inherited.
                 <remarks>
                     Note that when calling any of the generic <see cref="M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo``1(``0,``0@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/> and
                     <see cref="M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy``1(``0,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/> methods, this attribute will only be respected
                     if the generic parameter passed to the copying methods has this attribute.
                     For example, if a copy method is called with a generic parameter T that is not annotated with this attribute,
                     but the actual type of the source parameter is annotated with this attribute, it will not be copied by ref.
                     Conversely, if the generic parameter T is annotated with this attribute, but the actual type of the source
                     is an inheritor which is not annotated with this attribute, it will still be copied by ref.
                     If the generic parameter T is a type derived from another that is annotated with the attribute,
                     but it itself is not annotated with this attribute, source will not be copied by ref as this attribute
                     is not inherited.
                     <code>
                         public class A {}
            
                         [CopyByRef]
                         public class B : A {}
            
                         public class C : B {}
            
                         public class Copier(ISerializationManager manager)
                         {
                             var a = new A();
                             var b = new B();
                             var c = new C();
            
                             // false, not copied by ref
                             manager.CreateCopy(a) == a
            
                             // false, not copied by ref
                             manager.CreateCopy&lt;A&gt;(b) == b
            
                             // true, copied by ref
                             manager.CreateCopy(b) == b
            
                             // false, not copied by ref
                             manager.CreateCopy(c) == c
            
                             // true, copied by ref
                             manager.CreateCopy&lt;B&gt;(c) == c
                         }
                     </code>
                 </remarks>
             </summary>
        </member>
        <member name="P:Robust.Shared.Serialization.Manager.Attributes.DataFieldAttribute.Tag">
            <summary>
                The name of this field in YAML.
                If null, the name of the C# field will be used instead, with the first letter lowercased.
            </summary>
        </member>
        <member name="F:Robust.Shared.Serialization.Manager.Attributes.DataFieldAttribute.Required">
            <summary>
                Whether or not this field being mapped is required for the component to function.
                This will not guarantee that the field is mapped when the program is run,
                it is meant to be used as metadata information.
            </summary>
        </member>
        <member name="T:Robust.Shared.Serialization.Manager.Attributes.DataRecordAttribute">
            <summary>
                Makes all properties in a record data fields with camel case naming.
                <seealso cref="T:Robust.Shared.Serialization.Manager.Attributes.DataFieldAttribute"/>
            </summary>
        </member>
        <member name="T:Robust.Shared.Serialization.Manager.Attributes.ImplicitDataRecordAttribute">
            <summary>
                Makes any inheritors data records.
                <seealso cref="T:Robust.Shared.Serialization.Manager.Attributes.DataRecordAttribute"/>
            </summary>
        </member>
        <member name="T:Robust.Shared.Serialization.Manager.Attributes.IncludeDataFieldAttribute">
            <summary>
            Inlines the datafield instead of putting it into its own node.
            </summary>
            <remarks>
            mapping:
              data1: 0
              data2: 0
            Becomes
            data1: 0
            data2: 0
            </remarks>
        </member>
        <member name="T:Robust.Shared.Serialization.Manager.Attributes.MeansDataRecordAttribute">
            <summary>
                <seealso cref="T:Robust.Shared.Serialization.Manager.Attributes.DataRecordAttribute"/>
            </summary>
        </member>
        <member name="T:Robust.Shared.Serialization.Manager.Attributes.ValidatePrototypeIdAttribute`1">
            <summary>
            This attribute should be used on static string or string collection fields to validate that they correspond to
            valid YAML prototype ids. This attribute is not required for static <see cref="T:Robust.Shared.Prototypes.ProtoId`1"/> and
            <see cref="T:Robust.Shared.Prototypes.EntProtoId"/> fields, as they automatically get validated.
            </summary>
        </member>
        <member name="P:Robust.Shared.Serialization.Manager.ISerializationContext.WritingReadingPrototypes">
            <summary>
            Are we currently iterating prototypes or entities for writing.
            </summary>
        </member>
        <member name="M:Robust.Shared.Serialization.Manager.ISerializationManager.Initialize">
            <summary>
                Initializes the serialization manager.
            </summary>
        </member>
        <member name="M:Robust.Shared.Serialization.Manager.ISerializationManager.Shutdown">
            <summary>
                Shuts down the serialization manager.
            </summary>
        </member>
        <member name="M:Robust.Shared.Serialization.Manager.ISerializationManager.ValidateNode(System.Type,Robust.Shared.Serialization.Markdown.DataNode,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <summary>
                Validates that a node has all the properties required by a certain type.
            </summary>
            <param name="type">The type to check for.</param>
            <param name="node">The node to check.</param>
            <param name="context">The context to use, if any.</param>
            <returns>
                A node with whether or not <see cref="!:node"/> is valid and which of its fields
                are invalid, if any.
            </returns>
        </member>
        <member name="M:Robust.Shared.Serialization.Manager.ISerializationManager.ValidateNode``1(Robust.Shared.Serialization.Markdown.DataNode,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <summary>
                Validates that a node has all the properties required by a certain type.
            </summary>
            <param name="node">The node to check.</param>
            <param name="context">The context to use, if any.</param>
            <typeparam name="T">The type this node should be able to be read into.</typeparam>
            <returns>
                A node with whether or not <see cref="!:node"/> is valid and which of its fields
                are invalid, if any.
            </returns>
        </member>
        <member name="M:Robust.Shared.Serialization.Manager.ISerializationManager.ValidateNode``2(Robust.Shared.Serialization.TypeSerializers.Interfaces.ITypeValidator{``0,``1},``1,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <summary>
                Validates that a node has all the properties required by a certain type using a specified <see cref="T:Robust.Shared.Serialization.TypeSerializers.Interfaces.ITypeValidator`2"/> instance.
            </summary>
            <param name="typeValidator">The <see cref="T:Robust.Shared.Serialization.TypeSerializers.Interfaces.ITypeValidator`2"/> instance to use.</param>
            <param name="node">The node to check.</param>
            <param name="context">The context to use, if any.</param>
            <typeparam name="T">The type this node should be able to be read into.</typeparam>
            <typeparam name="TNode">The node type</typeparam>
            <returns></returns>
        </member>
        <member name="M:Robust.Shared.Serialization.Manager.ISerializationManager.ValidateNode``3(``1,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <summary>
                Validates that a node has all the properties required by a certain type using a specified <see cref="T:Robust.Shared.Serialization.TypeSerializers.Interfaces.ITypeValidator`2"/> type.
            </summary>
            <param name="node">The node to check.</param>
            <param name="context">The context to use, if any.</param>
            <typeparam name="T">The type this node should be able to be read into.</typeparam>
            <typeparam name="TNode">The node type</typeparam>
            <typeparam name="TValidator">The type of the <see cref="T:Robust.Shared.Serialization.TypeSerializers.Interfaces.ITypeValidator`2"/>.</typeparam>
            <returns></returns>
        </member>
        <member name="M:Robust.Shared.Serialization.Manager.ISerializationManager.Read(System.Type,Robust.Shared.Serialization.Markdown.DataNode,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)">
            <summary>
                Deserializes a node into an object, populating it.
            </summary>
            <param name="type">The type of object to deserialize into.</param>
            <param name="node">The node to deserialize.</param>
            <param name="context">The context to use, if any.</param>
            <param name="skipHook">Whether or not to skip running <see cref="T:Robust.Shared.Serialization.ISerializationHooks"/></param>
            <param name="notNullableOverride">Set true if a reference Type should not allow null. Not necessary for value types.</param>
            <returns>The deserialized object or null.</returns>
        </member>
        <member name="M:Robust.Shared.Serialization.Manager.ISerializationManager.Read``1(Robust.Shared.Serialization.Markdown.DataNode,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,Robust.Shared.Serialization.Manager.ISerializationManager.InstantiationDelegate{``0},System.Boolean)">
            <summary>
                Deserializes a node into a populated object of the given generic type <see cref="!:T"/>
            </summary>
            <param name="node">The node to deserialize.</param>
            <param name="context">The context to use, if any.</param>
            <param name="skipHook">Whether or not to skip running <see cref="T:Robust.Shared.Serialization.ISerializationHooks"/></param>
            <param name="instanceProvider">The valueProvider which can provide a value to read into. If none is supplied, a new object will be created.</param>
            <param name="notNullableOverride">Set true if a reference Type should not allow null. Not necessary for value types.</param>
            <typeparam name="T">The type of object to create and populate.</typeparam>
            <returns>The deserialized object, or null.</returns>
        </member>
        <member name="M:Robust.Shared.Serialization.Manager.ISerializationManager.Read``2(Robust.Shared.Serialization.TypeSerializers.Interfaces.ITypeReader{``0,``1},``1,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,Robust.Shared.Serialization.Manager.ISerializationManager.InstantiationDelegate{``0},System.Boolean)">
            <summary>
                Deserializes a node into a populated object of the given generic type <see cref="!:T"/> using the provided <see cref="T:Robust.Shared.Serialization.TypeSerializers.Interfaces.ITypeReader`2"/> instance.
            </summary>
            <param name="reader">The <see cref="T:Robust.Shared.Serialization.TypeSerializers.Interfaces.ITypeReader`2"/> instance to use.</param>
            <param name="node">The node to deserialize.</param>
            <param name="context">The context to use, if any.</param>
            <param name="skipHook">Whether or not to skip running <see cref="T:Robust.Shared.Serialization.ISerializationHooks"/></param>
            <param name="instanceProvider">The valueProvider which can provide a value to read into. If none is supplied, a new object will be created.</param>
            <param name="notNullableOverride">Set true if a reference Type should not allow null. Not necessary for value types.</param>
            <typeparam name="T">The type of object to create and populate.</typeparam>
            <typeparam name="TNode">The node type that will be returned by the <see cref="T:Robust.Shared.Serialization.TypeSerializers.Interfaces.ITypeReader`2"/></typeparam>
            <returns>The deserialized object, or null.</returns>
        </member>
        <member name="M:Robust.Shared.Serialization.Manager.ISerializationManager.Read``3(``1,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,Robust.Shared.Serialization.Manager.ISerializationManager.InstantiationDelegate{``0},System.Boolean)">
            <summary>
                Deserializes a node into a populated object of the given generic type <see cref="!:T"/> using the provided <see cref="T:Robust.Shared.Serialization.TypeSerializers.Interfaces.ITypeReader`2"/> type.
            </summary>
            <param name="node">The node to deserialize.</param>
            <param name="context">The context to use, if any.</param>
            <param name="skipHook">Whether or not to skip running <see cref="T:Robust.Shared.Serialization.ISerializationHooks"/></param>
            <param name="instanceProvider">The valueProvider which can provide a value to read into. If none is supplied, a new object will be created.</param>
            <param name="notNullableOverride">Set true if a reference Type should not allow null. Not necessary for value types.</param>
            <typeparam name="T">The type of object to create and populate.</typeparam>
            <typeparam name="TNode">The node type that will be returned by the <see cref="T:Robust.Shared.Serialization.TypeSerializers.Interfaces.ITypeReader`2"/></typeparam>
            <typeparam name="TReader">The type of the <see cref="T:Robust.Shared.Serialization.TypeSerializers.Interfaces.ITypeReader`2"/>.</typeparam>
            <returns>The deserialized object, or null.</returns>
        </member>
        <member name="M:Robust.Shared.Serialization.Manager.ISerializationManager.WriteValue``1(``0,System.Boolean,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean)">
            <summary>
                Serializes a value into a node.
            </summary>
            <param name="value">The value to serialize.</param>
            <param name="alwaysWrite">
                Whether or not to always write the given values into the resulting node,
                even if they are the default.
            </param>
            <param name="context">The context to use, if any.</param>
            <param name="notNullableOverride">Set true if a reference Type should not allow null. Not necessary for value types.</param>
            <typeparam name="T">The type to serialize.</typeparam>
            <returns>A <see cref="T:Robust.Shared.Serialization.Markdown.DataNode"/> created from the given <see cref="!:value"/>.</returns>
        </member>
        <member name="M:Robust.Shared.Serialization.Manager.ISerializationManager.WriteValue``1(Robust.Shared.Serialization.TypeSerializers.Interfaces.ITypeWriter{``0},``0,System.Boolean,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean)">
            <summary>
                Serializes a value into a node using a <see cref="T:Robust.Shared.Serialization.TypeSerializers.Interfaces.ITypeWriter`1"/> instance.
            </summary>
            <param name="writer">The <see cref="T:Robust.Shared.Serialization.TypeSerializers.Interfaces.ITypeWriter`1"/> to use for serializing the value.</param>
            <param name="value">The value to serialize.</param>
            <param name="alwaysWrite">
                Whether or not to always write the given values into the resulting node,
                even if they are the default.
            </param>
            <param name="context">The context to use, if any.</param>
            <param name="notNullableOverride">Set true if a reference Type should not allow null. Not necessary for value types.</param>
            <typeparam name="T">The type to serialize.</typeparam>
            <returns>A serialized datanode created from the given <see cref="!:value"/> by using the typewriter.</returns>
        </member>
        <member name="M:Robust.Shared.Serialization.Manager.ISerializationManager.WriteValue``2(``0,System.Boolean,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean)">
            <summary>
                Serializes a value into a node using a <see cref="T:Robust.Shared.Serialization.TypeSerializers.Interfaces.ITypeWriter`1"/> type.
            </summary>
            <param name="value">The value to serialize.</param>
            <param name="alwaysWrite">
                Whether or not to always write the given values into the resulting node,
                even if they are the default.
            </param>
            <param name="context">The context to use, if any.</param>
            <param name="notNullableOverride">Set true if a reference Type should not allow null. Not necessary for value types.</param>
            <typeparam name="T">The type to serialize.</typeparam>
            <typeparam name="TWriter">The type of the <see cref="T:Robust.Shared.Serialization.TypeSerializers.Interfaces.ITypeWriter`1"/>.</typeparam>
            <returns>A serialized datanode created from the given <see cref="!:value"/> by using the typewriter.</returns>
        </member>
        <member name="M:Robust.Shared.Serialization.Manager.ISerializationManager.WriteValue(System.Type,System.Object,System.Boolean,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean)">
            <summary>
                Serializes a value into a node.
            </summary>
            <param name="type">The type of the <see cref="!:value"/> to serialize as.</param>
            <param name="value">The value to serialize.</param>
            <param name="alwaysWrite">
                Whether or not to always write the given values into the resulting node,
                even if they are the default.
            </param>
            <param name="context">The context to use, if any.</param>
            <param name="notNullableOverride">Set true if a reference Type should not allow null. Not necessary for value types.</param>
            <returns>
                A serialized datanode created from the given <see cref="!:value"/>
                of type <see cref="!:type"/>.
            </returns>
        </member>
        <member name="M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)">
            <summary>
                Copies the values of one object into another.
                This does not guarantee that the object passed as <see cref="!:target"/>
                is actually mutated.
            </summary>
            <param name="source">The object to copy values from.</param>
            <param name="target">The object to copy values into.</param>
            <param name="context">The context to use, if any.</param>
            <param name="skipHook">Whether or not to skip running <see cref="T:Robust.Shared.Serialization.ISerializationHooks"/></param>
            <param name="notNullableOverride">Set true if a reference Type should not allow null. Not necessary for value types.</param>
        </member>
        <member name="M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo``1(``0,``0@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)">
            <summary>
                Copies the values of one object into another.
                This does not guarantee that the object passed as <see cref="!:target"/>
                is actually mutated.
            </summary>
            <param name="source">The object to copy values from.</param>
            <param name="target">The object to copy values into.</param>
            <param name="context">The context to use, if any.</param>
            <param name="skipHook">Whether or not to skip running <see cref="T:Robust.Shared.Serialization.ISerializationHooks"/></param>
            <param name="notNullableOverride">Set true if a reference Type should not allow null. Not necessary for value types.</param>
            <typeparam name="T">The type of the objects to copy from and into.</typeparam>
        </member>
        <member name="M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo``1(Robust.Shared.Serialization.TypeSerializers.Interfaces.ITypeCopier{``0},``0,``0@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)">
            <summary>
                Copies the values of one object into another using a specified <see cref="T:Robust.Shared.Serialization.TypeSerializers.Interfaces.ITypeCopier`1"/> instance.
                This does not guarantee that the object passed as <see cref="!:target"/>
                is actually mutated.
            </summary>
            <param name="copier">the <see cref="T:Robust.Shared.Serialization.TypeSerializers.Interfaces.ITypeCopier`1"/> instance to use</param>
            <param name="source">The object to copy values from.</param>
            <param name="target">The object to copy values into.</param>
            <param name="context">The context to use, if any.</param>
            <param name="skipHook">Whether or not to skip running <see cref="T:Robust.Shared.Serialization.ISerializationHooks"/></param>
            <param name="notNullableOverride">Set true if a reference Type should not allow null. Not necessary for value types.</param>
            <typeparam name="T">The type of the objects to copy from and into.</typeparam>
        </member>
        <member name="M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo``2(``0,``0@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)">
            <summary>
                Copies the values of one object into another using a specified <see cref="T:Robust.Shared.Serialization.TypeSerializers.Interfaces.ITypeCopier`1"/> type.
                This does not guarantee that the object passed as <see cref="!:target"/>
                is actually mutated.
            </summary>
            <param name="source">The object to copy values from.</param>
            <param name="target">The object to copy values into.</param>
            <param name="context">The context to use, if any.</param>
            <param name="skipHook">Whether or not to skip running <see cref="T:Robust.Shared.Serialization.ISerializationHooks"/></param>
            <param name="notNullableOverride">Set true if a reference Type should not allow null. Not necessary for value types.</param>
            <typeparam name="T">The type of the objects to copy from and into.</typeparam>
            <typeparam name="TCopier">The type of the <see cref="T:Robust.Shared.Serialization.TypeSerializers.Interfaces.ITypeCopier`1"/>.</typeparam>
        </member>
        <member name="M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)">
            <summary>
                Creates a copy of the given object.
            </summary>
            <param name="source">The object to copy.</param>
            <param name="context">The context to use, if any.</param>
            <param name="skipHook">Whether or not to skip running <see cref="T:Robust.Shared.Serialization.ISerializationHooks"/></param>
            <param name="notNullableOverride">Set true if a reference Type should not allow null. Not necessary for value types.</param>
            <returns>A copy of the given object.</returns>
        </member>
        <member name="M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy``1(``0,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)">
            <summary>
                Creates a copy of the given object.
            </summary>
            <param name="source">The object to copy.</param>
            <param name="context">The context to use, if any.</param>
            <param name="skipHook">Whether or not to skip running <see cref="T:Robust.Shared.Serialization.ISerializationHooks"/></param>
            <param name="notNullableOverride">Set true if a reference Type should not allow null. Not necessary for value types.</param>
            <typeparam name="T">The type of the object to copy.</typeparam>
            <returns>A copy of the given object.</returns>
        </member>
        <member name="M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy``1(Robust.Shared.Serialization.TypeSerializers.Interfaces.ITypeCopyCreator{``0},``0,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)">
            <summary>
                Creates a copy of the given object using a specified <see cref="T:Robust.Shared.Serialization.TypeSerializers.Interfaces.ITypeCopyCreator`1"/> instance.
            </summary>
            <param name="copyCreator">The <see cref="T:Robust.Shared.Serialization.TypeSerializers.Interfaces.ITypeCopyCreator`1"/> instance.</param>
            <param name="source">The object to copy.</param>
            <param name="context">The context to use, if any.</param>
            <param name="skipHook">Whether or not to skip running <see cref="T:Robust.Shared.Serialization.ISerializationHooks"/></param>
            <param name="notNullableOverride">Set true if a reference Type should not allow null. Not necessary for value types.</param>
            <typeparam name="T">The type of the object to copy.</typeparam>
            <returns>A copy of the given object.</returns>
        </member>
        <member name="M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy``2(``0,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)">
            <summary>
                Creates a copy of the given object using a specified <see cref="T:Robust.Shared.Serialization.TypeSerializers.Interfaces.ITypeCopyCreator`1"/> type.
            </summary>
            <param name="source">The object to copy.</param>
            <param name="context">The context to use, if any.</param>
            <param name="skipHook">Whether or not to skip running <see cref="T:Robust.Shared.Serialization.ISerializationHooks"/></param>
            <param name="notNullableOverride">Set true if a reference Type should not allow null. Not necessary for value types.</param>
            <typeparam name="T">The type of the object to copy.</typeparam>
            <typeparam name="TCopyCreator">The type of the <see cref="T:Robust.Shared.Serialization.TypeSerializers.Interfaces.ITypeCopier`1"/> to use.</typeparam>
            <returns>A copy of the given object.</returns>
        </member>
        <member name="F:Robust.Shared.Serialization.Manager.SerializationManager.SerializerInterfaces">
            <summary>
                <see cref="F:Robust.Shared.Serialization.Manager.SerializationManager.CopyCreatorIndex"/>
                <see cref="F:Robust.Shared.Serialization.Manager.SerializationManager.CopierIndex"/>
            </summary>
        </member>
        <member name="F:Robust.Shared.Serialization.Manager.SerializationManager.CopyCreatorIndex">
            <summary>
                <see cref="F:Robust.Shared.Serialization.Manager.SerializationManager.SerializerInterfaces"/>
            </summary>
        </member>
        <member name="F:Robust.Shared.Serialization.Manager.SerializationManager.CopierIndex">
            <summary>
                <see cref="F:Robust.Shared.Serialization.Manager.SerializationManager.SerializerInterfaces"/>
            </summary>
        </member>
        <member name="F:Robust.Shared.Serialization.Manager.SerializationManager.SerializerProvider._typeSerializersArray">
            <summary>
                Type serializers indexed by their type serializer and type
                that they serialize.
                <see cref="F:Robust.Shared.Serialization.Manager.SerializationManager.SerializerInterfaces"/> for the first index.
            </summary>
        </member>
        <member name="M:Robust.Shared.Serialization.Markdown.DataNode.Except(Robust.Shared.Serialization.Markdown.DataNode)">
            <summary>
                This function will return a data node that contains only the elements within this data node that do not
                have an equivalent entry in some other data node.
            </summary>
        </member>
        <member name="M:Robust.Shared.Serialization.Markdown.Mapping.MappingDataNode.RecursiveExcept(Robust.Shared.Serialization.Markdown.Mapping.MappingDataNode)">
            <summary>
                Variant of <see cref="M:Robust.Shared.Serialization.Markdown.Mapping.MappingDataNode.Except(Robust.Shared.Serialization.Markdown.Mapping.MappingDataNode)"/> that will recursively call except rather than only checking equality.
            </summary>
        </member>
        <member name="P:Robust.Shared.Serialization.Markdown.Validation.FieldNotFoundErrorNode.FieldType">
            <summary>
            The Type in which the field was not found.
            </summary>
        </member>
        <member name="T:Robust.Shared.Serialization.NetSerializableAttribute">
            <summary>
            This attribute marks an object as able to be serialized by SS14's NetSerializer. It is required that objects
            that have this Attribute also have the <see cref="T:System.SerializableAttribute"/>. You can use
            <see cref="T:System.NonSerializedAttribute"/> to mark a field as non-serialized. Child classes are also NetSerializable.
            See the <see href="https://github.com/tomba/netserializer/blob/master/Doc.md">NetSerializer Documentation</see>
            for more info.
            </summary>
        </member>
        <member name="T:Robust.Shared.Serialization.RobustMappedStringSerializer">
             <summary>
             Serializer which manages a mapping of pre-loaded strings to constant
             values, for message compression. The mapping is shared between the
             server and client.
             </summary>
             <remarks>
             Strings are long and expensive to send over the wire, and lots of
             strings involved in messages are sent repeatedly between the server
             and client - such as filenames, icon states, constant strings, etc.
            
             To compress these strings, we use a constant string mapping, decided
             by the server when it starts up, that associates strings with a
             fixed value. The mapping is shared with clients when they connect.
            
             When sending these strings over the wire, the serializer can then
             send the constant value instead - and at the other end, the
             serializer can use the same mapping to recover the original string.
             </remarks>
        </member>
        <member name="F:Robust.Shared.Serialization.RobustMappedStringSerializer.MinMappedStringSize">
            <summary>
            The shortest a string can be in order to be inserted in the mapping.
            </summary>
            <remarks>
            Strings below a certain length aren't worth compressing.
            </remarks>
        </member>
        <member name="F:Robust.Shared.Serialization.RobustMappedStringSerializer.MaxMappedStringSize">
            <summary>
            The longest a string can be in order to be inserted in the mapping.
            </summary>
        </member>
        <member name="F:Robust.Shared.Serialization.RobustMappedStringSerializer.MappedNull">
            <summary>
            The special value corresponding to a <c>null</c> string in the
            encoding.
            </summary>
        </member>
        <member name="F:Robust.Shared.Serialization.RobustMappedStringSerializer.UnmappedString">
            <summary>
            The special value corresponding to a string which was not mapped.
            This is followed by the bytes of the unmapped string.
            </summary>
        </member>
        <member name="F:Robust.Shared.Serialization.RobustMappedStringSerializer.FirstMappedIndexStart">
            <summary>
            The first non-special value, used for encoding mapped strings.
            </summary>
            <remarks>
            Since previous values are taken by <see cref="F:Robust.Shared.Serialization.RobustMappedStringSerializer.MappedNull"/> and
            <see cref="F:Robust.Shared.Serialization.RobustMappedStringSerializer.UnmappedString"/>, this value is used to encode
            mapped strings at an offset - in the encoding, a value
            <c>>= FirstMappedIndexStart</c> represents the string with
            mapping of that value <c> - FirstMappedIndexStart</c>.
            </remarks>
        </member>
        <member name="P:Robust.Shared.Serialization.RobustMappedStringSerializer.MappedStringsHash">
            <value>
            The hash of the string mapping.
            </value>
            <exception cref="T:System.InvalidOperationException">
            Thrown if the mapping is not locked.
            </exception>
        </member>
        <member name="M:Robust.Shared.Serialization.RobustMappedStringSerializer.Handshake(Robust.Shared.Network.INetChannel)">
            <summary>
            Starts the handshake from the server end of the given channel,
            sending a <see cref="T:Robust.Shared.Network.Messages.MsgMapStrServerHandshake"/>.
            </summary>
            <param name="channel">The network channel to perform the handshake over.</param>
            <remarks>
            Locks the string mapping if this is the first time the server is
            performing the handshake.
            </remarks>
            <seealso cref="T:Robust.Shared.Network.Messages.MsgMapStrClientHandshake"/>
            <seealso cref="T:Robust.Shared.Network.Messages.MsgMapStrStrings"/>
        </member>
        <member name="M:Robust.Shared.Serialization.RobustMappedStringSerializer.NetworkInitialize">
             <summary>
             Performs the setup so that the serializer can perform the string-
             exchange protocol.
             </summary>
             <remarks>
             The string-exchange protocol is started by the server when the
             client first connects. The server sends the client a hash of the
             string mapping; the client checks that hash against any local
             caches; and if necessary, the client requests a new copy of the
             mapping from the server.
            
             Uncached flow: <code>
             Client      |      Server
             | &lt;-------------- Hash |
             | Need Strings ------&gt; |
             | &lt;----------- Strings |
             | Dont Need Strings -&gt; |
             </code>
            
             Cached flow: <code>
             Client      |      Server
             | &lt;-------------- Hash |
             | Dont Need Strings -&gt; |
             </code>
            
             Verification failure flow: <code>
             Client      |      Server
             | &lt;-------------- Hash |
             | Need Strings ------&gt; |
             | &lt;----------- Strings |
             + Hash Failed          |
             | Need Strings ------&gt; |
             | &lt;----------- Strings |
             | Dont Need Strings -&gt; |
              </code>
            
             NOTE: Verification failure flow is currently not implemented.
             </remarks>
             <param name="net">
             The <see cref="T:Robust.Shared.Network.INetManager"/> to perform the protocol steps over.
             </param>
             <seealso cref="T:Robust.Shared.Network.Messages.MsgMapStrServerHandshake"/>
             <seealso cref="T:Robust.Shared.Network.Messages.MsgMapStrClientHandshake"/>
             <seealso cref="T:Robust.Shared.Network.Messages.MsgMapStrStrings"/>
             <seealso cref="M:Robust.Shared.Serialization.RobustMappedStringSerializer.HandleServerHandshake(Robust.Shared.Network.Messages.MsgMapStrServerHandshake)"/>
             <seealso cref="M:Robust.Shared.Serialization.RobustMappedStringSerializer.HandleClientHandshake(Robust.Shared.Network.Messages.MsgMapStrClientHandshake)"/>
             <seealso cref="M:Robust.Shared.Serialization.RobustMappedStringSerializer.HandleStringsMessage(Robust.Shared.Network.Messages.MsgMapStrStrings)"/>
             <seealso cref="M:Robust.Shared.Serialization.RobustMappedStringSerializer.OnClientCompleteHandshake(Robust.Shared.Network.INetManager,Robust.Shared.Network.INetChannel)"/>
        </member>
        <member name="M:Robust.Shared.Serialization.RobustMappedStringSerializer.HandleStringsMessage(Robust.Shared.Network.Messages.MsgMapStrStrings)">
             <summary>
             Handles the reception, verification of a strings package
             and subsequent mapping of strings and initiator of
             receipt response.
            
             Uncached flow: <code>
             Client      |      Server
             | &lt;-------------- Hash |
             | Need Strings ------&gt; |
             | &lt;----------- Strings |
             | Dont Need Strings -&gt; | &lt;- you are here on client
            
             Verification failure flow: <code>
             Client      |      Server
             | &lt;-------------- Hash |
             | Need Strings ------&gt; |
             | &lt;----------- Strings |
             + Hash Failed          | &lt;- you are here on client
             | Need Strings ------&gt; |
             | &lt;----------- Strings |
             | Dont Need Strings -&gt; | &lt;- you are here on client
              </code>
            
             NOTE: Verification failure flow is currently not implemented.
             </code>
             </summary>
             <exception cref="T:System.InvalidOperationException">Unable to verify strings package by hash.</exception>
             <seealso cref="M:Robust.Shared.Serialization.RobustMappedStringSerializer.NetworkInitialize"/>
        </member>
        <member name="M:Robust.Shared.Serialization.RobustMappedStringSerializer.HandleClientHandshake(Robust.Shared.Network.Messages.MsgMapStrClientHandshake)">
             <summary>
             Interpret a client's handshake, either sending a package
             of strings or completing the handshake.
            
             Uncached flow: <code>
             Client      |      Server
             | &lt;-------------- Hash |
             | Need Strings ------&gt; | &lt;- you are here on server
             | &lt;----------- Strings |
             | Dont Need Strings -&gt; | &lt;- you are here on server
             </code>
            
             Cached flow: <code>
             Client      |      Server
             | &lt;-------------- Hash |
             | Dont Need Strings -&gt; | &lt;- you are here on server
             </code>
            
             Verification failure flow: <code>
             Client      |      Server
             | &lt;-------------- Hash |
             | Need Strings ------&gt; | &lt;- you are here on server
             | &lt;----------- Strings |
             + Hash Failed          |
             | Need Strings ------&gt; | &lt;- you are here on server
             | &lt;----------- Strings |
             | Dont Need Strings -&gt; |
              </code>
            
             NOTE: Verification failure flow is currently not implemented.
             </summary>
             <seealso cref="M:Robust.Shared.Serialization.RobustMappedStringSerializer.NetworkInitialize"/>
        </member>
        <member name="M:Robust.Shared.Serialization.RobustMappedStringSerializer.HandleServerHandshake(Robust.Shared.Network.Messages.MsgMapStrServerHandshake)">
             <summary>
             Interpret a server's handshake, either requesting a package
             of strings or completing the handshake.
            
             Uncached flow: <code>
             Client      |      Server
             | &lt;-------------- Hash | &lt;- you are here on client
             | Need Strings ------&gt; |
             | &lt;----------- Strings |
             | Dont Need Strings -&gt; |
             </code>
            
             Cached flow: <code>
             Client      |      Server
             | &lt;-------------- Hash | &lt;- you are here on client
             | Dont Need Strings -&gt; |
             </code>
            
             Verification failure flow: <code>
             Client      |      Server
             | &lt;-------------- Hash | &lt;- you are here on client
             | Need Strings ------&gt; |
             | &lt;----------- Strings |
             + Hash Failed          |
             | Need Strings ------&gt; |
             | &lt;----------- Strings |
             | Dont Need Strings -&gt; |
              </code>
            
             NOTE: Verification failure flow is currently not implemented.
             </summary>
             <exception cref="T:System.InvalidOperationException">Mapped strings are locked.</exception>
             <seealso cref="M:Robust.Shared.Serialization.RobustMappedStringSerializer.NetworkInitialize"/>
        </member>
        <member name="M:Robust.Shared.Serialization.RobustMappedStringSerializer.OnClientCompleteHandshake(Robust.Shared.Network.INetManager,Robust.Shared.Network.INetChannel)">
            <summary>
            Inform the server that the client has a complete copy of the
            mapping, and alert other code that the handshake is over.
            </summary>
            <seealso cref="E:Robust.Shared.Serialization.RobustMappedStringSerializer.ClientHandshakeComplete"/>
            <seealso cref="M:Robust.Shared.Serialization.RobustMappedStringSerializer.NetworkInitialize"/>
        </member>
        <member name="M:Robust.Shared.Serialization.RobustMappedStringSerializer.CacheForHash(System.String)">
            <summary>
            Gets the cache file associated with the given hash.
            </summary>
            <param name="hashStr">The hash to look up the cache for.</param>
            <returns>
            The filename where the cache for the given hash would be. The
            file itself may or may not exist. If it does not exist, no cache
            was made for the given hash.
            </returns>
        </member>
        <member name="M:Robust.Shared.Serialization.RobustMappedStringSerializer.WriteStringCache(System.IO.Stream)">
            <summary>
             Saves the string cache to a file based on it's hash.
            </summary>
        </member>
        <member name="M:Robust.Shared.Serialization.RobustMappedStringSerializer.AddString(System.String)">
            <summary>
            Add a string to the constant mapping.
            </summary>
            <remarks>
            If the string has multiple detectable subcomponents, such as a
            filepath, it may result in more than one string being added to
            the mapping. As string parts are commonly sent as subsets or
            scoped names, this increases the likelyhood of a successful
            string mapping.
            </remarks>
            <returns>
            <c>true</c> if the string was added to the mapping for the first
            time, <c>false</c> otherwise.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            Thrown if the string is not normalized (<see cref="M:System.String.IsNormalized"/>).
            </exception>
        </member>
        <member name="M:Robust.Shared.Serialization.RobustMappedStringSerializer.AddStrings(System.Reflection.Assembly)">
            <summary>
            Add the constant strings from an <see cref="T:System.Reflection.Assembly"/> to the
            mapping.
            </summary>
            <param name="asm">The assembly from which to collect constant strings.</param>
        </member>
        <member name="M:Robust.Shared.Serialization.RobustMappedStringSerializer.AddStrings(YamlDotNet.RepresentationModel.YamlStream)">
            <summary>
            Add strings from the given <see cref="T:YamlDotNet.RepresentationModel.YamlStream"/> to the mapping.
            </summary>
            <remarks>
            Strings are taken from YAML anchors, tags, and leaf nodes.
            </remarks>
            <param name="yaml">The YAML to collect strings from.</param>
        </member>
        <member name="M:Robust.Shared.Serialization.RobustMappedStringSerializer.AddStrings(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Add strings from the given enumeration to the mapping.
            </summary>
            <param name="strings">The strings to add.</param>
        </member>
        <member name="M:Robust.Shared.Serialization.RobustMappedStringSerializer.NetSerializer#ITypeSerializer#Handles(System.Type)">
            <summary>
            Implements <see cref="M:NetSerializer.ITypeSerializer.Handles(System.Type)"/>.
            Specifies that this implementation handles strings.
            </summary>
        </member>
        <member name="M:Robust.Shared.Serialization.RobustMappedStringSerializer.NetSerializer#ITypeSerializer#GetSubtypes(System.Type)">
            <summary>
            Implements <see cref="M:NetSerializer.ITypeSerializer.GetSubtypes(System.Type)"/>.
            </summary>
        </member>
        <member name="E:Robust.Shared.Serialization.RobustMappedStringSerializer.ClientHandshakeComplete">
            <summary>
            See <see cref="M:Robust.Shared.Serialization.RobustMappedStringSerializer.OnClientCompleteHandshake(Robust.Shared.Network.INetManager,Robust.Shared.Network.INetChannel)"/>.
            </summary>
        </member>
        <member name="M:Robust.Shared.Serialization.RobustMappedStringSerializer.MappedStringDict.WriteStringPackage(System.String[],System.IO.Stream,System.Byte[]@)">
            <summary>
            Writes a strings package to a stream.
            </summary>
            <param name="stream">A writable stream.</param>
            <exception cref="T:System.NotImplementedException">Overly long string in strings package.</exception>
        </member>
        <member name="M:Robust.Shared.Serialization.RobustMappedStringSerializer.MappedStringDict.ClearStrings">
            <summary>
            Remove all strings from the mapping, completely resetting it.
            </summary>
            <exception cref="T:System.InvalidOperationException">
            Thrown if the mapping is locked.
            </exception>
        </member>
        <member name="M:Robust.Shared.Serialization.RobustMappedStringSerializer.MappedStringDict.AddString(System.String)">
            <summary>
            Add a string to the constant mapping.
            </summary>
            <remarks>
            If the string has multiple detectable subcomponents, such as a
            filepath, it may result in more than one string being added to
            the mapping. As string parts are commonly sent as subsets or
            scoped names, this increases the likelyhood of a successful
            string mapping.
            </remarks>
            <exception cref="T:System.InvalidOperationException">
            Thrown if the string is not normalized (<see cref="M:System.String.IsNormalized"/>).
            </exception>
        </member>
        <member name="M:Robust.Shared.Serialization.RobustMappedStringSerializer.MappedStringDict.AddStrings(System.Reflection.Assembly)">
            <summary>
            Add the constant strings from an <see cref="T:System.Reflection.Assembly"/> to the
            mapping.
            </summary>
            <param name="asm">The assembly from which to collect constant strings.</param>
        </member>
        <member name="M:Robust.Shared.Serialization.RobustMappedStringSerializer.MappedStringDict.AddStrings(YamlDotNet.RepresentationModel.YamlStream)">
            <summary>
            Add strings from the given <see cref="T:YamlDotNet.RepresentationModel.YamlStream"/> to the mapping.
            </summary>
            <remarks>
            Strings are taken from YAML anchors, tags, and leaf nodes.
            </remarks>
            <param name="yaml">The YAML to collect strings from.</param>
        </member>
        <member name="M:Robust.Shared.Serialization.RobustMappedStringSerializer.MappedStringDict.AddStrings(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Add strings from the given enumeration to the mapping.
            </summary>
            <param name="strings">The strings to add.</param>
        </member>
        <member name="M:Robust.Shared.Serialization.RobustSerializer.FindSerializedType(System.Type,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Serialization.RobustSerializer.Handshake(Robust.Shared.Network.INetChannel)">
            <summary>
            Initiates any sequence of handshake extensions that
            need to occur before the serializer is initialized
            for a given client.
            </summary>
            <param name="channel"></param>
            <returns></returns>
        </member>
        <member name="E:Robust.Shared.Serialization.RobustSerializer.ClientHandshakeComplete">
             <summary>
             An event that occurs once all handshake extensions have
             completed for the client.
            
             Note: This should not occur on the server.
             </summary>
        </member>
        <member name="P:Robust.Shared.Serialization.SerializedTypeAttribute.SerializeName">
            <summary>
                Name of this type in serialized files.
            </summary>
        </member>
        <member name="T:Robust.Shared.Serialization.TypeSerializers.Implementations.Custom.AbstractDictionarySerializer`1">
            <summary>
            A custom type serializer for reading a set of types that inherit from some base type. 
            </summary>
        </member>
        <member name="T:Robust.Shared.Serialization.TypeSerializers.Implementations.Custom.ComponentNameSerializer">
            <summary>
            Simple string serializer that just validates that strings correspond to valid component names
            </summary>
        </member>
        <member name="T:Robust.Shared.Serialization.TypeSerializers.Implementations.Custom.Prototype.PrototypeIdSerializer`1">
            <summary>
            Checks that a string corresponds to a valid prototype id. Note that any data fields using this serializer will
            also be validated by <see cref="M:Robust.Shared.Prototypes.IPrototypeManager.ValidateStaticFields(System.Collections.Generic.Dictionary{System.Type,System.Collections.Generic.HashSet{System.String}})"/>
            </summary>
        </member>
        <member name="T:Robust.Shared.Serialization.TypeSerializers.Implementations.Custom.TimeOffsetSerializer">
            <summary>
            This serializer offsets a timespan by the game's current time. If the entity is currently paused, the pause time
            will also be accounted for,
            </summary>
            <remarks>
            Prototypes and pre map-init entities will always serialize this as zero. This is done mainly as a brute force fix
            to prevent time-offsets from being unintentionally saved to maps while mapping. If an entity must have an initial
            non-zero time, then that time should just be configured during map-init.
            </remarks>
        </member>
        <member name="T:Robust.Shared.Serialization.TypeSerializers.Implementations.DateTimeSerializer">
            <summary>
            Implements serialization for <see cref="T:System.DateTime"/>.
            </summary>
            <remarks>
            Serialization is implemented with <see cref="F:System.Globalization.DateTimeStyles.RoundtripKind"/> and the "o" format specifier.
            </remarks>
        </member>
        <member name="T:Robust.Shared.Serialization.TypeSerializers.Implementations.EntProtoIdSerializer">
            <summary>
                Serializer used automatically for <see cref="T:Robust.Shared.Prototypes.EntProtoId"/> types.
            </summary>
        </member>
        <member name="T:Robust.Shared.Serialization.TypeSerializers.Implementations.EntProtoIdSerializer`1">
            <summary>
                Serializer used automatically for <see cref="T:Robust.Shared.Prototypes.EntProtoId"/> types.
            </summary>
        </member>
        <member name="T:Robust.Shared.Serialization.TypeSerializers.Implementations.EnumSerializer">
            <summary>
                Attempts to resolve a string into an enum.
            </summary>
        </member>
        <member name="T:Robust.Shared.Serialization.TypeSerializers.Implementations.Generic.CustomHashSetSerializer`2">
            <summary>
                This is a variation of the <see cref="T:Robust.Shared.Serialization.TypeSerializers.Implementations.Generic.HashSetSerializer`1"/> that uses a custom type serializer to read the values.
            </summary>
        </member>
        <member name="T:Robust.Shared.Serialization.TypeSerializers.Implementations.Generic.CustomQueueSerializer`2">
            <summary>
                This is a variation of the <see cref="T:Robust.Shared.Serialization.TypeSerializers.Implementations.Generic.QueueSerializer`1"/> that uses a custom type serializer to read/write the values.
            </summary>
        </member>
        <member name="T:Robust.Shared.Serialization.TypeSerializers.Implementations.Generic.ProtoIdSerializer`1">
            <summary>
                Serializer used automatically for <see cref="T:Robust.Shared.Prototypes.ProtoId`1"/> types.
            </summary>
            <typeparam name="T">The type of the prototype for which the id is stored.</typeparam>
        </member>
        <member name="T:Robust.Shared.Serialization.TypeSerializers.Implementations.LocIdSerializer">
            <summary>
                Serializer used automatically for <see cref="T:Robust.Shared.Localization.LocId"/> types.
            </summary>
        </member>
        <member name="T:Robust.Shared.Serialization.YamlMappingFix">
            <summary>
            TODO: This fix exists because of https://github.com/aaubry/YamlDotNet/issues/409.
            Credit: https://stackoverflow.com/a/56452440
            </summary>
        </member>
        <member name="T:Robust.Shared.Serialization.YamlNoDocEndDotsFix">
            <summary>
                So by default, YamlDotNet appends "..." to the end of a serialized document.
                In the YAML spec, three dots signify the end of a document.
                If you're serializing a single document, this is pretty much useless. This emitter removes these dots entirely.
            </summary>
        </member>
        <member name="T:Robust.Shared.SharedWarmup">
            <summary>
            Logic for "warming up" things like slow static constructors concurrently.
            </summary>
        </member>
        <member name="T:Robust.Shared.Spawners.TimedDespawnComponent">
            <summary>
            Put this component on something you would like to despawn after a certain amount of time
            </summary>
            <remarks>
            NOT networked as we don't want clients predicting networked entity deletions.
            </remarks>
        </member>
        <member name="F:Robust.Shared.Spawners.TimedDespawnComponent.Lifetime">
            <summary>
            How long the entity will exist before despawning
            </summary>
        </member>
        <member name="M:Robust.Shared.Spawners.TimedDespawnComponent.InternalCopy(Robust.Shared.Spawners.TimedDespawnComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Spawners.TimedDespawnComponent.Copy(Robust.Shared.Spawners.TimedDespawnComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Spawners.TimedDespawnComponent.Copy(Robust.Shared.GameObjects.Component@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Spawners.TimedDespawnComponent.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Spawners.TimedDespawnComponent.InternalCopy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Spawners.TimedDespawnComponent.Copy(Robust.Shared.GameObjects.IComponent@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Spawners.TimedDespawnComponent.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Shared.Spawners.TimedDespawnEvent">
            <summary>
            Raised directed on an entity when its timed despawn is over.
            </summary>
        </member>
        <member name="T:Robust.Shared.Threading.IParallelRobustJob">
            <summary>
            Runs the job with the specified batch size per thread; Execute is still called per index.
            </summary>
        </member>
        <member name="P:Robust.Shared.Threading.IParallelRobustJob.MinimumBatchParallel">
            <summary>
            Minimum amount of batches required to engage in parallelism.
            </summary>
        </member>
        <member name="T:Robust.Shared.Threading.IRobustJob">
            <summary>
            Implement for code that needs to be runnable on a threadpool.
            </summary>
        </member>
        <member name="M:Robust.Shared.Threading.IParallelManager.AddAndInvokeParallelCountChanged(System.Action)">
            <summary>
            Add the delegate to <see cref="E:Robust.Shared.Threading.IParallelManager.ParallelCountChanged"/> and immediately invoke it.
            </summary>
        </member>
        <member name="M:Robust.Shared.Threading.IParallelManager.Process(Robust.Shared.Threading.IRobustJob)">
            <summary>
            Takes in a job that gets flushed.
            </summary>
            <param name="job"></param>
        </member>
        <member name="M:Robust.Shared.Threading.IParallelManager.ProcessNow(Robust.Shared.Threading.IParallelRobustJob,System.Int32)">
            <summary>
            Takes in a parallel job and runs it the specified amount.
            </summary>
        </member>
        <member name="M:Robust.Shared.Threading.IParallelManager.ProcessSerialNow(Robust.Shared.Threading.IParallelRobustJob,System.Int32)">
            <summary>
            Processes a robust job sequentially if desired.
            </summary>
        </member>
        <member name="M:Robust.Shared.Threading.IParallelManager.Process(Robust.Shared.Threading.IParallelRobustJob,System.Int32)">
            <summary>
            Takes in a parallel job and runs it without blocking.
            </summary>
        </member>
        <member name="F:Robust.Shared.Threading.ParallelManager._trackerPool">
            <summary>
            Used internally for Parallel jobs, for external callers it gets garbage collected.
            </summary>
        </member>
        <member name="M:Robust.Shared.Threading.ParallelManager.Process(Robust.Shared.Threading.IRobustJob)">
            <inheritdoc/>
        </member>
        <member name="M:Robust.Shared.Threading.ParallelManager.ProcessNow(Robust.Shared.Threading.IParallelRobustJob,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Robust.Shared.Threading.ParallelManager.ProcessSerialNow(Robust.Shared.Threading.IParallelRobustJob,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Robust.Shared.Threading.ParallelManager.Process(Robust.Shared.Threading.IParallelRobustJob,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Robust.Shared.Threading.ParallelManager.InternalProcess(Robust.Shared.Threading.IParallelRobustJob,System.Int32)">
            <summary>
            Runs a parallel job internally. Used so we can pool the tracker task for ProcessParallelNow
            and not rely on external callers to return it where they don't want to wait.
            </summary>
        </member>
        <member name="T:Robust.Shared.Threading.ParallelManager.InternalJob">
            <summary>
            Runs an <see cref="T:Robust.Shared.Threading.IRobustJob"/> and handles cleanup.
            </summary>
        </member>
        <member name="T:Robust.Shared.Threading.ParallelManager.InternalParallelJob">
            <summary>
            Runs an <see cref="T:Robust.Shared.Threading.IParallelRobustJob"/> and handles cleanup.
            </summary>
        </member>
        <member name="T:Robust.Shared.Threading.ParallelManager.ParallelTracker">
            <summary>
            Tracks jobs internally. This is because WaitHandle has a max limit of 64 tasks.
            So we'll just decrement PendingTasks in lieu.
            </summary>
        </member>
        <member name="M:Robust.Shared.Threading.ParallelManager.ParallelTracker.Set">
            <summary>
            Marks the tracker as having 1 less pending task.
            </summary>
        </member>
        <member name="T:Robust.Shared.Timing.FrameEventArgs">
            <summary>
                Arguments of the GameLoop frame event.
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.FrameEventArgs.DeltaSeconds">
            <summary>
                Seconds passed since this event was last called.
            </summary>
        </member>
        <member name="M:Robust.Shared.Timing.FrameEventArgs.#ctor(System.Single)">
            <summary>
                Constructs an instance of this object.
            </summary>
            <param name="deltaSeconds">Seconds passed since this event was last called.</param>
        </member>
        <member name="P:Robust.Shared.Timing.IGameLoop.SingleStep">
            <summary>
                Enables single step mode. If this is enabled, after every tick the GameTime will pause.
                Unpausing GameTime will run another single tick.
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.IGameLoop.Running">
            <summary>
                Setting this to false will stop the loop after it has started running.
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.IGameLoop.MaxQueuedTicks">
            <summary>
                How many ticks behind the simulation can get before it starts to slow down.
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.IGameLoop.SleepMode">
            <summary>
                The method currently being used to limit the Update rate.
            </summary>
        </member>
        <member name="M:Robust.Shared.Timing.IGameLoop.Run">
            <summary>
                Start running the loop. This function will block for as long as the loop is Running.
                Set Running to false to exit the loop and return from this function.
            </summary>
        </member>
        <member name="T:Robust.Shared.Timing.GameLoop">
            <summary>
                Manages the main game loop for a GameContainer.
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.GameLoop.SingleStep">
            <summary>
                Enables single step mode. If this is enabled, after every tick the GameTime will pause.
                Unpausing GameTime will run another single tick.
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.GameLoop.Running">
            <summary>
                Setting this to false will stop the loop after it has started running.
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.GameLoop.MaxQueuedTicks">
            <summary>
                How many ticks behind the simulation can get before it starts to slow down.
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.GameLoop.DetectSoftLock">
            <summary>
                If true and the same event causes an event 10 times in a row, the game loop will shut itself down.
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.GameLoop.SleepMode">
            <summary>
                The method currently being used to limit the Update rate.
            </summary>
        </member>
        <member name="M:Robust.Shared.Timing.GameLoop.Run">
            <summary>
                Start running the loop. This function will block for as long as the loop is Running.
                Set Running to false to exit the loop and return from this function.
            </summary>
        </member>
        <member name="T:Robust.Shared.Timing.SleepMode">
            <summary>
                Methods the GameLoop can use to limit the Update rate.
            </summary>
        </member>
        <member name="F:Robust.Shared.Timing.SleepMode.None">
            <summary>
                Thread will not yield to the scheduler or sleep, and consume 100% cpu. Use this if you are
                limiting the rate by other means (rendering FPS with vsync), otherwise your computer will turn into a heater.
            </summary>
        </member>
        <member name="F:Robust.Shared.Timing.SleepMode.Yield">
            <summary>
                Same as None, except you are yielding the rest of your timeslice to other OS threads at the end of each update.
                This will run at 100% CPU if another thread does not hog all the CPU time, and your OS scheduler will be happier.
            </summary>
        </member>
        <member name="F:Robust.Shared.Timing.SleepMode.Delay">
            <summary>
                Adds ~1ms thread sleep after every update. Use this to limit the Update rate of the loop, conserve power and
                have low CPU usage. You should use this on a dedicated server.
            </summary>
        </member>
        <member name="T:Robust.Shared.Timing.GameTick">
            <summary>
                Wraps a game tick value.
            </summary>
        </member>
        <member name="M:Robust.Shared.Timing.GameTick.#ctor(System.UInt32)">
            <summary>
                Constructs a new instance of <c>GameTick</c>.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Robust.Shared.Timing.GameTick.Equals(Robust.Shared.Timing.GameTick)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Timing.GameTick.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Timing.GameTick.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Timing.GameTick.op_Equality(Robust.Shared.Timing.GameTick,Robust.Shared.Timing.GameTick)">
            <summary>
                Check for equality by value between two objects.
            </summary>
        </member>
        <member name="M:Robust.Shared.Timing.GameTick.op_Inequality(Robust.Shared.Timing.GameTick,Robust.Shared.Timing.GameTick)">
            <summary>
                Check for inequality by value between two objects.
            </summary>
        </member>
        <member name="M:Robust.Shared.Timing.GameTick.CompareTo(Robust.Shared.Timing.GameTick)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Timing.GameTick.ToString">
            <inheritdoc />
        </member>
        <member name="T:Robust.Shared.Timing.GameTiming">
            <summary>
                This holds main loop timing information and helper functions.
            </summary>
        </member>
        <member name="M:Robust.Shared.Timing.GameTiming.#ctor">
            <summary>
                Default constructor.
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.GameTiming.InSimulation">
            <summary>
            Is program execution inside of the simulation update, or rendering?
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.GameTiming.Paused">
            <summary>
                Is the simulation currently paused?
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.GameTiming.CurTime">
            <summary>
                The current synchronized uptime of the simulation. Use this for in-game timing. This can be rewound for
                prediction, and is affected by Paused and TimeScale.
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.GameTiming.RealTime">
            <summary>
                The current real uptime of the simulation. Use this for UI and out of game timing.
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.GameTiming.FrameTime">
            <summary>
                The simulated time it took to render the last frame.
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.GameTiming.RealFrameTime">
            <summary>
                The real time it took to render the last frame.
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.GameTiming.RealFrameTimeAvg">
            <summary>
                Average real frame time over the last 50 frames.
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.GameTiming.RealFrameTimeStdDev">
            <summary>
                Standard Deviation of the real frame time over the last 50 frames.
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.GameTiming.FramesPerSecondAvg">
            <summary>
                Average real FPS over the last 50 frames.
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.GameTiming.CurTick">
            <summary>
                The current simulation tick being processed.
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.GameTiming.LastTick">
            <summary>
                Timespan for the last tick.
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.GameTiming.TickRate">
            <summary>
                The target ticks/second of the simulation.
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.GameTiming.TickPeriod">
            <summary>
                The length of a tick at the current TickRate. 1/TickRate.
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.GameTiming.TickRemainder">
            <summary>
            The remaining time left over after the last tick was ran.
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.GameTiming.CurFrame">
            <summary>
                Current graphics frame since init OpenGL which is taken as frame 1, from swapbuffer to swapbuffer. Useful to set a
                conditional breakpoint on specific frames, and synchronize with OGL debugging tools that capture frames.
                Depending on the tools used, this frame number will vary between 1 frame more or less due to how that tool is counting frames,
                i.e. starting from 0 or 1, having a separate counter, etc. Available in timing debug panel.
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.GameTiming.TickTimingAdjustment">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Timing.GameTiming.StartFrame">
            <summary>
                Ends the 'lap' of the timer, updating frame time info.
            </summary>
        </member>
        <member name="M:Robust.Shared.Timing.GameTiming.ResetSimTime">
            <summary>
            Resets the simulation time.
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.GameTiming.InPrediction">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Timing.GameTiming.ApplyingState">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Timing.GameTiming.CalcFpsAvg">
            <summary>
                Calculates the average FPS of the last 50 real frame times.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Robust.Shared.Timing.GameTiming.CalcRftStdDev">
            <summary>
                Calculates the standard deviation of the last 50 real frame times.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Robust.Shared.Timing.IGameTiming">
            <summary>
                This holds main loop timing information and helper functions.
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.IGameTiming.InSimulation">
            <summary>
            Is program execution inside of the simulation, or rendering?
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.IGameTiming.Paused">
            <summary>
                Is the simulation currently paused?
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.IGameTiming.CurTime">
            <summary>
                The current synchronized uptime of the simulation. Use this for in-game timing. This can be rewound for
                prediction, and is affected by Paused and TimeScale.
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.IGameTiming.RealTime">
            <summary>
                The current real uptime of the simulation. Use this for UI and out of game timing.
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.IGameTiming.ServerTime">
            <summary>
                The <see cref="P:Robust.Shared.Timing.IGameTiming.RealTime"/> of the server.
            </summary>
            <remarks>
                0 if we are the client and we are not connected to a server.
                <see cref="P:Robust.Shared.Timing.IGameTiming.RealTime"/> if we are the server.
            </remarks>
        </member>
        <member name="P:Robust.Shared.Timing.IGameTiming.FrameTime">
            <summary>
                The simulated time it took to render the last frame.
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.IGameTiming.RealFrameTime">
            <summary>
                The real time it took to render the last frame.
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.IGameTiming.RealFrameTimeAvg">
            <summary>
                Average real frame time over the last 50 frames.
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.IGameTiming.RealFrameTimeStdDev">
            <summary>
                Standard Deviation of the frame time over the last 50 frames.
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.IGameTiming.CurFrame">
            <summary>
                Current graphics frame since init OpenGL which is taken as frame 1. Useful to set a conditional breakpoint on specific frames, and
                synchronize with OGL debugging tools that capture frames. Depending on the tools used, this frame
                number will vary between 1 frame more or less due to how that tool is counting frames,
                i.e. starting from 0 or 1, having a separate counter, etc. Available in timing debug panel.
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.IGameTiming.FramesPerSecondAvg">
            <summary>
                Average real FPS over the last 50 frames.
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.IGameTiming.CurTick">
            <summary>
                The current simulation tick being processed.
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.IGameTiming.LastTick">
            <summary>
                Time, relative to <see cref="P:Robust.Shared.Timing.IGameTiming.RealTime"/>, the last tick started at.
                If we're currently in simulation, that's THIS tick.
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.IGameTiming.TickRate">
            <summary>
                The target ticks/second of the simulation.
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.IGameTiming.TimeBase">
            <summary>
            The baseline time value that CurTime is calculated relatively to.
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.IGameTiming.TickPeriod">
            <summary>
                The length of a tick at the current TickRate. 1/TickRate.
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.IGameTiming.TickRemainder">
            <summary>
            The remaining time left over after the last tick was ran.
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.IGameTiming.TickFraction">
            <summary>
                Fraction of how far into the tick we are. <c>0</c> is 0% and <see cref="F:System.UInt16.MaxValue"/> is 100%.
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.IGameTiming.TickTimingAdjustment">
            <summary>
                If the client clock is a little behind or ahead of the server, you can
                use the to adjust the timing of the clock speed. The default value is 0,
                and you can run the clock from -1 (almost stopped) to 1 (almost no delay).
                This has no effect on in-simulation timing, and only changes the speed at which
                the simulation progresses in relation to Real time. Don't mess with this unless
                you know what you are doing. DO NOT TOUCH THIS ON SERVER.
            </summary>
        </member>
        <member name="M:Robust.Shared.Timing.IGameTiming.StartFrame">
            <summary>
                Ends the 'lap' of the timer, updating frame time info.
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.IGameTiming.IsFirstTimePredicted">
            <summary>
            Is this the first time CurTick has been predicted?
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.IGameTiming.InPrediction">
            <summary>
            True if CurTick is ahead of LastRealTick, and <see cref="P:Robust.Shared.Timing.IGameTiming.ApplyingState"/> is false.
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.IGameTiming.ApplyingState">
            <summary>
            If true, the game is currently in the process of applying a game server-state.
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.IGameTiming.TickStampStatic">
            <summary>
            Statically-accessible version of <see cref="P:Robust.Shared.Timing.IGameTiming.TickStamp"/>.
            </summary>
            <remarks>
            This is intended as a debugging aid, and should not be used in regular committed code.
            </remarks>
        </member>
        <member name="M:Robust.Shared.Timing.IGameTiming.ResetSimTime">
            <summary>
            Resets the simulation time. This should be called on round restarts.
            </summary>
        </member>
        <member name="T:Robust.Shared.Timing.IStopwatch">
            <summary>
                Provides a set of methods and properties that you can use to accurately
                measure elapsed time.
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.IStopwatch.Elapsed">
            <summary>
                Gets the total elapsed time measured by the current instance.
            </summary>
        </member>
        <member name="M:Robust.Shared.Timing.IStopwatch.Restart">
            <summary>
                Stops time interval measurement, resets the elapsed time to zero,
                and starts measuring elapsed time.
            </summary>
        </member>
        <member name="M:Robust.Shared.Timing.IStopwatch.Start">
            <summary>
                Starts, or resumes, measuring elapsed time for an interval.
            </summary>
        </member>
        <member name="T:Robust.Shared.Timing.PrecisionSleep">
            <summary>
            Helper for more precise sleeping functionality than <see cref="M:System.Threading.Thread.Sleep(System.Int32)"/>.
            </summary>
        </member>
        <member name="M:Robust.Shared.Timing.PrecisionSleep.Sleep(System.TimeSpan)">
            <summary>
            Sleep for the specified amount of time.
            </summary>
        </member>
        <member name="M:Robust.Shared.Timing.PrecisionSleep.Create">
            <summary>
            Create the most optimal optimization for the current platform.
            </summary>
        </member>
        <member name="T:Robust.Shared.Timing.PrecisionSleepUniversal">
            <summary>
            Universal cross-platform implementation of <see cref="T:Robust.Shared.Timing.PrecisionSleep"/>. Not very precise!
            </summary>
        </member>
        <member name="T:Robust.Shared.Timing.PrecisionSleepWindowsHighResolution">
            <summary>
            High-precision implementation of <see cref="T:Robust.Shared.Timing.PrecisionSleep"/> that is available since Windows 10 1803.
            </summary>
        </member>
        <member name="T:Robust.Shared.Timing.PrecisionSleepLinuxNanosleep">
            <summary>
            High-precision implementation of <see cref="T:Robust.Shared.Timing.PrecisionSleep"/> that is available on Linux.
            </summary>
        </member>
        <member name="T:Robust.Shared.Timing.RStopwatch">
            <summary>
            Struct equivalent to <see cref="T:System.Diagnostics.Stopwatch"/>, avoids allocating.
            </summary>
        </member>
        <member name="T:Robust.Shared.Timing.Stopwatch">
            <summary>
                Provides a set of methods and properties that you can use to accurately
                measure elapsed time.
            </summary>
        </member>
        <member name="M:Robust.Shared.Timing.Stopwatch.#ctor">
            <summary>
                Constructs a new instance of this object.
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.Stopwatch.Elapsed">
            <summary>
                Gets the total elapsed time measured by the current instance.
            </summary>
        </member>
        <member name="M:Robust.Shared.Timing.Stopwatch.Start">
            <summary>
                Starts, or resumes, measuring elapsed time for an interval.
            </summary>
        </member>
        <member name="M:Robust.Shared.Timing.Stopwatch.Restart">
            <summary>
                Stops time interval measurement, resets the elapsed time to zero,
                and starts measuring elapsed time.
            </summary>
        </member>
        <member name="F:Robust.Shared.Timing.Timer._timeCounter">
            <summary>
            Counts the time (in milliseconds) before firing again.
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.Timer.Time">
            <summary>
            Time (in milliseconds) between firings.
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.Timer.IsRepeating">
            <summary>
            Whether or not this timer should repeat.
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.Timer.IsActive">
            <summary>
            Whether or not this timer is still running.
            </summary>
        </member>
        <member name="P:Robust.Shared.Timing.Timer.OnFired">
            <summary>
            Called when the timer is fired.
            </summary>
        </member>
        <member name="M:Robust.Shared.Timing.Timer.Delay(System.Int32,System.Threading.CancellationToken)">
            <summary>
                Creates a task that will complete after a given delay.
                The task is resumed on the main game logic thread.
            </summary>
            <param name="milliseconds">The length of time, in milliseconds, to delay for.</param>
            <param name="cancellationToken"></param>
            <returns>The task that can be awaited.</returns>
        </member>
        <member name="M:Robust.Shared.Timing.Timer.Delay(System.TimeSpan,System.Threading.CancellationToken)">
            <summary>
                Creates a task that will complete after a given delay.
                The task is resumed on the main game logic thread.
            </summary>
            <param name="duration">The length of time to delay for.</param>
            <param name="cancellationToken"></param>
            <returns>The task that can be awaited.</returns>
        </member>
        <member name="M:Robust.Shared.Timing.Timer.Spawn(System.Int32,System.Action,System.Threading.CancellationToken)">
            <summary>
                Schedule an action to be fired after a certain delay.
                The action will be resumed on the main game logic thread.
            </summary>
            <param name="milliseconds">The length of time, in milliseconds, to wait before firing the action.</param>
            <param name="onFired">The action to fire.</param>
            <param name="cancellationToken"></param>
        </member>
        <member name="M:Robust.Shared.Timing.Timer.Spawn(System.TimeSpan,System.Action,System.Threading.CancellationToken)">
            <summary>
                Schedule an action to be fired after a certain delay.
                The action will be resumed on the main game logic thread.
            </summary>
            <param name="duration">The length of time, to wait before firing the action.</param>
            <param name="onFired">The action to fire.</param>
            <param name="cancellationToken"></param>
        </member>
        <member name="M:Robust.Shared.Timing.Timer.SpawnRepeating(System.Int32,System.Action,System.Threading.CancellationToken)">
            <summary>
                Schedule an action that repeatedly fires after a delay specified in milliseconds.
            </summary>
            <param name="milliseconds">The length of time, in milliseconds, to delay before firing the repeated action.</param>
            <param name="onFired">The action to fire.</param>
            <param name="cancellationToken">The CancellationToken for stopping the Timer.</param>
        </member>
        <member name="M:Robust.Shared.Timing.Timer.SpawnRepeating(System.TimeSpan,System.Action,System.Threading.CancellationToken)">
            <summary>
                Schedule an action that repeatedly fires after a delay.
            </summary>
            <param name="duration">The length of time to delay before firing the repeated action.</param>
            <param name="onFired">The action to fire.</param>
            <param name="cancellationToken">The CancellationToken for stopping the Timer.</param>
        </member>
        <member name="T:Robust.Shared.Toolshed.ToolshedCommandAttribute">
            <summary>
                Used to mark a class so that <see cref="T:Robust.Shared.Toolshed.ToolshedManager"/> automatically discovers and registers it.
            </summary>
        </member>
        <member name="T:Robust.Shared.Toolshed.CommandImplementationAttribute">
            <summary>
                Marks a function in a <see cref="T:Robust.Shared.Toolshed.ToolshedCommand"/> as being an implementation of that command, so that Toolshed will use it's signature for parsing/etc.
            </summary>
        </member>
        <member name="T:Robust.Shared.Toolshed.PipedArgumentAttribute">
            <summary>
                Marks an argument in a function in a <see cref="T:Robust.Shared.Toolshed.ToolshedCommand"/> as being the "piped" argument, the return value of the prior command in the chain.
            </summary>
        </member>
        <member name="T:Robust.Shared.Toolshed.CommandArgumentAttribute">
            <summary>
                Marks an argument in a function as being an argument of a <see cref="T:Robust.Shared.Toolshed.ToolshedCommand"/>.
                This will make it so the argument will get parsed.
            </summary>
        </member>
        <member name="T:Robust.Shared.Toolshed.CommandInvertedAttribute">
            <summary>
                Marks an argument in a function as specifying whether or not this call to a <see cref="T:Robust.Shared.Toolshed.ToolshedCommand"/> is inverted.
            </summary>
        </member>
        <member name="T:Robust.Shared.Toolshed.CommandInvocationContextAttribute">
            <summary>
                Marks an argument in a function as being where the invocation context should be provided in a <see cref="T:Robust.Shared.Toolshed.ToolshedCommand"/>.
            </summary>
            <seealso cref="T:Robust.Shared.Toolshed.IInvocationContext"/>
        </member>
        <member name="T:Robust.Shared.Toolshed.TakesPipedTypeAsGenericAttribute">
            <summary>
                Marks a command implementation as taking the type of the previous command in sequence as a generic argument.
            </summary>
            <remarks>
                If the argument marked with <see cref="T:Robust.Shared.Toolshed.PipedArgumentAttribute"/> is not <c>T</c> but instead a pattern like <c>IEnumerable&lt;T&gt;</c>, Toolshed will account for this.
            </remarks>
        </member>
        <member name="T:Robust.Shared.Toolshed.Commands.Vfs.VfsCommand">
            <summary>
                A simple base class for commands that work with the VFS and would like to manipulate the user's current location within the VFS.
            </summary>
            <seealso cref="F:Robust.Shared.Toolshed.Commands.Vfs.VfsCommand.UserVfsLocVariableName"/>
        </member>
        <member name="F:Robust.Shared.Toolshed.Commands.Vfs.VfsCommand.UserVfsLocVariableName">
            <summary>
                The name of the variable storing a <see cref="T:Robust.Shared.Utility.ResPath">ResPath?</see> representing the user's current VFS location.
            </summary>
        </member>
        <member name="T:Robust.Shared.Toolshed.Errors.IConError">
            <summary>
                A Toolshed-oriented representation of an error.
                Contains metadata about where in an executed command it occurred, and supports formatting.
                <code>
                > entities runverbas self "yeet"
                entities runverbas self "yeet"
                                   ^^^^^
                You must be logged in with a client to use this, the server console isn't workable.
                </code>
            </summary>
        </member>
        <member name="M:Robust.Shared.Toolshed.Errors.IConError.Describe">
            <summary>
                Returns a user friendly description of the error.
            </summary>
            <remarks>
                This calls <see cref="M:Robust.Shared.Toolshed.Errors.IConError.DescribeInner"/> for the actual description by default.
                If you fully override this, you should provide your own context provider, as the default implementation includes where in the expression the error occurred.
            </remarks>
        </member>
        <member name="M:Robust.Shared.Toolshed.Errors.IConError.DescribeInner">
            <summary>
                Describes the error, called by <see cref="M:Robust.Shared.Toolshed.Errors.IConError.Describe"/>'s default implementation.
            </summary>
        </member>
        <member name="P:Robust.Shared.Toolshed.Errors.IConError.Expression">
            <summary>
                The expression this error was raised in or on.
            </summary>
        </member>
        <member name="P:Robust.Shared.Toolshed.Errors.IConError.IssueSpan">
            <summary>
                Where in the expression this error was raised.
            </summary>
        </member>
        <member name="P:Robust.Shared.Toolshed.Errors.IConError.Trace">
            <summary>
                The stack trace for this error if any.
            </summary>
            <remarks>
                This is not present in release builds.
            </remarks>
        </member>
        <member name="M:Robust.Shared.Toolshed.Errors.IConError.Contextualize(System.String,Robust.Shared.Maths.Vector2i)">
            <summary>
                Attaches additional context to an error, namely where it occurred.
            </summary>
            <param name="expression">Expression the error occured in or on.</param>
            <param name="issueSpan">Where in the expression it occurred.</param>
        </member>
        <member name="T:Robust.Shared.Toolshed.Errors.ConHelpers">
            <summary>
                Pile of helpers for console formatting.
            </summary>
        </member>
        <member name="M:Robust.Shared.Toolshed.Errors.ConHelpers.HighlightSpan(System.String,Robust.Shared.Maths.Vector2i,Robust.Shared.Maths.Color)">
            <summary>
                Highlights a section of the input a given color.
            </summary>
            <param name="input">Input text.</param>
            <param name="span">Span to highlight.</param>
            <param name="color">Color to use.</param>
            <returns>A formatted message with highlighting applied.</returns>
        </member>
        <member name="M:Robust.Shared.Toolshed.Errors.ConHelpers.ArrowSpan(Robust.Shared.Maths.Vector2i)">
            <summary>
                Creates a string with up arrows (<c>^</c>) under the given span.
            </summary>
            <param name="span">Span to underline.</param>
            <returns>A string of whitespace with (<c>^</c>) under the given span.</returns>
        </member>
        <member name="T:Robust.Shared.Toolshed.IInvocationContext">
            <summary>
                A context in which Toolshed commands can be run using <see cref="M:Robust.Shared.Toolshed.ToolshedManager.InvokeCommand(Robust.Shared.Toolshed.IInvocationContext,System.String,System.Object,System.Object@)"/>.
            </summary>
        </member>
        <member name="M:Robust.Shared.Toolshed.IInvocationContext.CheckInvokable(Robust.Shared.Toolshed.CommandSpec,Robust.Shared.Toolshed.Errors.IConError@)">
            <summary>
                Test if the given command spec can be invoked in this context.
            </summary>
            <param name="command">Command to test.</param>
            <param name="error">An error to report, if any.</param>
            <returns>Whether or not the given command can be invoked</returns>
            <remarks>
                THIS IS A SECURITY BOUNDARY.
                If you want to avoid players being able to just reboot your server, you should probably implement this!
                The default implementation defers to the active permission controller.
            </remarks>
        </member>
        <member name="P:Robust.Shared.Toolshed.IInvocationContext.Session">
            <summary>
                The session for the <see cref="P:Robust.Shared.Toolshed.IInvocationContext.User"/>, if any currently exists.
            </summary>
        </member>
        <member name="P:Robust.Shared.Toolshed.IInvocationContext.User">
            <summary>
                The session this context is for, if any.
            </summary>
        </member>
        <member name="M:Robust.Shared.Toolshed.IInvocationContext.WriteLine(System.String)">
            <summary>
                Writes a line to this context's output.
            </summary>
            <param name="line">The text to print.</param>
            <remarks>
                This can be stubbed safely, there's no requirement that the side effects of this function be observable.
            </remarks>
        </member>
        <member name="M:Robust.Shared.Toolshed.IInvocationContext.WriteLine(Robust.Shared.Utility.FormattedMessage)">
            <summary>
                Writes a formatted message to this context's output.
            </summary>
            <param name="line">The formatted message to print.</param>
            <remarks>
                This can be stubbed safely, there's no requirement that the side effects of this function be observable.
            </remarks>
        </member>
        <member name="M:Robust.Shared.Toolshed.IInvocationContext.WriteMarkup(System.String)">
            <summary>
                Writes the given markup to this context's output.
            </summary>
            <param name="markup">The markup to print.</param>
            <remarks>
                This can be stubbed safely, there's no requirement that the side effects of this function be observable.
            </remarks>
        </member>
        <member name="M:Robust.Shared.Toolshed.IInvocationContext.WriteError(Robust.Shared.Toolshed.Errors.IConError)">
            <summary>
                Writes the given error to the context's output.
            </summary>
            <param name="error">The error to write out.</param>
            <remarks>
                This can be stubbed safely, there's no requirement that the side effects of this function be observable.
            </remarks>
        </member>
        <member name="M:Robust.Shared.Toolshed.IInvocationContext.ReportError(Robust.Shared.Toolshed.Errors.IConError)">
            <summary>
                Reports the given error to the context.
            </summary>
            <param name="err">Error to report.</param>
            <remarks>
                This may have arbitrary side effects. Usually, it'll push the error to some list you can retrieve with GetErrors().
            </remarks>
        </member>
        <member name="M:Robust.Shared.Toolshed.IInvocationContext.GetErrors">
            <summary>
                Gets the list of unobserved errors.
            </summary>
            <returns>An enumerable of console errors.</returns>
            <remarks>
                This is not required to contain anything, may contain errors you did not ReportError(), and may not contain errors you did ReportError().
            </remarks>
        </member>
        <member name="M:Robust.Shared.Toolshed.IInvocationContext.ClearErrors">
            <summary>
                Clears the list of unobserved errors.
            </summary>
            <remarks>
                After calling this, assuming atomicity (no threads), GetErrors() MUST be empty in order for an IInvocationContext to be compliant.
            </remarks>
        </member>
        <member name="P:Robust.Shared.Toolshed.IInvocationContext.Variables">
            <summary>
                The backing variable storage.
            </summary>
            <remarks>
                You don't have to use this at all.
            </remarks>
        </member>
        <member name="M:Robust.Shared.Toolshed.IInvocationContext.ReadVar(System.String)">
            <summary>
                Reads the given variable from the context.
            </summary>
            <param name="name">The name of the variable.</param>
            <returns>The contents of the variable.</returns>
            <remarks>
                This may behave arbitrarily, but it's advised it behave somewhat sanely.
            </remarks>
        </member>
        <member name="M:Robust.Shared.Toolshed.IInvocationContext.WriteVar(System.String,System.Object)">
            <summary>
                Writes the given variable to the context.
            </summary>
            <param name="name">The name of the variable.</param>
            <param name="value">The contents of the variable.</param>
            <remarks>
                Writes may be ignored or manipulated.
            </remarks>
        </member>
        <member name="M:Robust.Shared.Toolshed.IInvocationContext.GetVars">
            <summary>
                Provides a list of all variables that have been written to at some point.
            </summary>
            <returns>List of all variables.</returns>
        </member>
        <member name="T:Robust.Shared.Toolshed.Invocation.OldShellInvocationContext">
            <inheritdoc />
        </member>
        <member name="F:Robust.Shared.Toolshed.Invocation.OldShellInvocationContext.Shell">
            <summary>
                Old system's shell associated with this context. May be null if the player is currently disconnected.
            </summary>
        </member>
        <member name="P:Robust.Shared.Toolshed.Invocation.OldShellInvocationContext.User">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Toolshed.Invocation.OldShellInvocationContext.Session">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Toolshed.Invocation.OldShellInvocationContext.WriteLine(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Toolshed.Invocation.OldShellInvocationContext.WriteLine(Robust.Shared.Utility.FormattedMessage)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Toolshed.Invocation.OldShellInvocationContext.ReportError(Robust.Shared.Toolshed.Errors.IConError)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Toolshed.Invocation.OldShellInvocationContext.GetErrors">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Toolshed.Invocation.OldShellInvocationContext.ClearErrors">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Toolshed.Invocation.OldShellInvocationContext.Variables">
            <inheritdoc />
        </member>
        <member name="T:Robust.Shared.Toolshed.Syntax.Block`1">
            <summary>
            Something more akin to actual expressions.
            </summary>
        </member>
        <member name="T:Robust.Shared.Toolshed.Syntax.CommandRun">
            <summary>
            A "run" of commands. Not a true expression.
            </summary>
        </member>
        <member name="M:Robust.Shared.Toolshed.Syntax.ParserContext.PeekChar">
            <remarks>
                This should only be used for comparisons! It'll return '\0' (NOT null) for large runes.
            </remarks>
        </member>
        <member name="M:Robust.Shared.Toolshed.Syntax.ParserContext.GetChar">
            <remarks>
                This should only be used for comparisons! It'll return '\0' (NOT null) for large runes.
            </remarks>
        </member>
        <member name="T:Robust.Shared.Toolshed.ToolshedCommand">
            <summary>
                This class is used for implementing new commands in Toolshed.
            </summary>
            <remarks>
                Toolshed's code generation will automatically handle creating command executor stubs, you don't need to override anything.
            </remarks>
            <example><code>
                [ToolshedCommand]
                public sealed class ExampleCommand : ToolshedCommand
                {
                    // Toolshed will automatically infer autocompletion information, type information, and parsing.
                    [CommandImplementation]
                    public IEnumerable&lt;EntityUid&gt; Example(
                            [PipedArgument] IEnumerable&lt;EntityUid&gt; input,
                            [CommandArgument] int amount
                        )
                    {
                        return input.Take(amount);
                    }
                }
            </code></example>
            <seealso cref="T:Robust.Shared.Toolshed.ToolshedManager"/>
            <seealso cref="T:Robust.Shared.Toolshed.ToolshedCommandAttribute"/>
            <seealso cref="T:Robust.Shared.Toolshed.CommandImplementationAttribute"/>
            <seealso cref="T:Robust.Shared.Toolshed.PipedArgumentAttribute"/>
            <seealso cref="T:Robust.Shared.Toolshed.CommandArgumentAttribute"/>
            <seealso cref="T:Robust.Shared.Toolshed.CommandInvertedAttribute"/>
            <seealso cref="T:Robust.Shared.Toolshed.CommandInvocationContextAttribute"/>
            <seealso cref="T:Robust.Shared.Toolshed.TakesPipedTypeAsGenericAttribute"/>
        </member>
        <member name="P:Robust.Shared.Toolshed.ToolshedCommand.Name">
            <summary>
                The user-facing name of the command.
            </summary>
            <remarks>This is automatically generated based on the type name unless overridden with <see cref="T:Robust.Shared.Toolshed.ToolshedCommandAttribute"/>.</remarks>
        </member>
        <member name="P:Robust.Shared.Toolshed.ToolshedCommand.HasSubCommands">
            <summary>
                Whether or not this command has subcommands.
            </summary>
        </member>
        <member name="P:Robust.Shared.Toolshed.ToolshedCommand.TypeParameterParsers">
            <summary>
                The additional type parameters of this command, specifically which parsers to use.
            </summary>
            <remarks>Every type specified must either be <see cref="T:System.Type"/> itself or something implementing <see cref="T:Robust.Shared.Toolshed.TypeParsers.IAsType`1"/> where T is Type.</remarks>
        </member>
        <member name="P:Robust.Shared.Toolshed.ToolshedCommand.Subcommands">
            <summary>
                The list of all subcommands on this command.
            </summary>
        </member>
        <member name="F:Robust.Shared.Toolshed.ToolshedCommand._readonlyParameters">
            <summary>
            List of parameters for this command and all sub commands. Used for command help usage.
            Dictionary(subCommand, List(pipedType, List(parameterType)))
            </summary>
        </member>
        <member name="M:Robust.Shared.Toolshed.ToolshedCommand.ExecutingEntity(Robust.Shared.Toolshed.IInvocationContext)">
            <summary>
                Returns the entity that's executing this command, if any.
            </summary>
        </member>
        <member name="M:Robust.Shared.Toolshed.ToolshedCommand.MetaData(Robust.Shared.GameObjects.EntityUid)">
            <summary>
                A shorthand for retrieving <see cref="T:Robust.Shared.GameObjects.MetaDataComponent"/> for an entity.
            </summary>
        </member>
        <member name="M:Robust.Shared.Toolshed.ToolshedCommand.Transform(Robust.Shared.GameObjects.EntityUid)">
            <summary>
                A shorthand for retrieving <see cref="T:Robust.Shared.GameObjects.TransformComponent"/> for an entity.
            </summary>
        </member>
        <member name="M:Robust.Shared.Toolshed.ToolshedCommand.EntName(Robust.Shared.GameObjects.EntityUid)">
            <summary>
                A shorthand for retrieving an entity's name.
            </summary>
        </member>
        <member name="M:Robust.Shared.Toolshed.ToolshedCommand.Spawn(System.String,Robust.Shared.Map.EntityCoordinates)">
            <summary>
                A shorthand for spawning an entity.
            </summary>
        </member>
        <member name="M:Robust.Shared.Toolshed.ToolshedCommand.Spawn(System.String,Robust.Shared.Map.MapCoordinates)">
            <summary>
                A shorthand for spawning an entity.
            </summary>
        </member>
        <member name="M:Robust.Shared.Toolshed.ToolshedCommand.Del(Robust.Shared.GameObjects.EntityUid)">
            <summary>
                A shorthand for deleting an entity.
            </summary>
        </member>
        <member name="M:Robust.Shared.Toolshed.ToolshedCommand.QDel(Robust.Shared.GameObjects.EntityUid)">
            <summary>
                A shorthand for queueing the deletion of an entity.
            </summary>
        </member>
        <member name="M:Robust.Shared.Toolshed.ToolshedCommand.Deleted(Robust.Shared.GameObjects.EntityUid)">
            <summary>
                A shorthand for checking if an entity is deleted or otherwise non-existant.
            </summary>
        </member>
        <member name="M:Robust.Shared.Toolshed.ToolshedCommand.Comp``1(Robust.Shared.GameObjects.EntityUid)">
            <summary>
                A shorthand for retrieving the given component for an entity.
            </summary>
        </member>
        <member name="M:Robust.Shared.Toolshed.ToolshedCommand.HasComp``1(Robust.Shared.GameObjects.EntityUid)">
            <summary>
                A shorthand for checking if an entity has the given component.
            </summary>
        </member>
        <member name="M:Robust.Shared.Toolshed.ToolshedCommand.TryComp``1(System.Nullable{Robust.Shared.GameObjects.EntityUid},``0@)">
            <summary>
                A shorthand for attempting to retrieve the given component for an entity.
            </summary>
        </member>
        <member name="M:Robust.Shared.Toolshed.ToolshedCommand.TryComp``1(Robust.Shared.GameObjects.EntityUid,``0@)">
            <inheritdoc cref="!:TryComp&lt;T&gt;(System.Nullable&lt;Robust.Shared.GameObjects.EntityUid&gt;,out T?)"/>
        </member>
        <member name="M:Robust.Shared.Toolshed.ToolshedCommand.AddComp``1(Robust.Shared.GameObjects.EntityUid)">
            <summary>
                A shorthand for adding a component to the given entity.
            </summary>
        </member>
        <member name="M:Robust.Shared.Toolshed.ToolshedCommand.RemComp``1(Robust.Shared.GameObjects.EntityUid)">
            <summary>
                A shorthand for removing a component from the given entity.
            </summary>
        </member>
        <member name="M:Robust.Shared.Toolshed.ToolshedCommand.EnsureComp``1(Robust.Shared.GameObjects.EntityUid)">
            <summary>
                A shorthand for ensuring an entity has the given component.
            </summary>
        </member>
        <member name="M:Robust.Shared.Toolshed.ToolshedCommand.GetSys``1">
            <summary>
                A shorthand for retrieving an entity system.
            </summary>
            <remarks>This may be replaced with some form of dependency attribute in the future.</remarks>
        </member>
        <member name="M:Robust.Shared.Toolshed.ToolshedCommand.GetEntityQuery``1">
            <summary>
                A shorthand for retrieving an entity query.
            </summary>
        </member>
        <member name="M:Robust.Shared.Toolshed.ToolshedCommand.Description(System.String)">
            <summary>
                Returns a command's localized description.
            </summary>
        </member>
        <member name="M:Robust.Shared.Toolshed.ToolshedCommand.UnlocalizedDescription(System.String)">
            <summary>
                Returns the locale string for a command's description.
            </summary>
        </member>
        <member name="M:Robust.Shared.Toolshed.ToolshedCommand.GetHelp(System.String)">
            <summary>
                Returns a command's help string.
            </summary>
        </member>
        <member name="M:Robust.Shared.Toolshed.ToolshedCommand.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Robust.Shared.Toolshed.ToolshedCommandImplementor.TryParseArguments(System.Boolean,Robust.Shared.Toolshed.Syntax.ParserContext,System.String,System.Type,System.Collections.Generic.Dictionary{System.String,System.Object}@,System.Type[]@,Robust.Shared.Toolshed.Errors.IConError@,System.Nullable{System.Threading.Tasks.ValueTask{System.ValueTuple{Robust.Shared.Console.CompletionResult,Robust.Shared.Toolshed.Errors.IConError}}}@)">
            <summary>
                You who tread upon this dreaded land, what is it that brings you here?
                For this place is not for you, this land of terror and death.
                It brings fear to all who tread within, terror to the homes ahead.
                Begone, foul maintainer, for this place is not for thee.
            </summary>
        </member>
        <member name="M:Robust.Shared.Toolshed.ToolshedCommandImplementor.TryGetImplementation(System.Type,System.Type[],System.Func{Robust.Shared.Toolshed.CommandInvocationArguments,System.Object}@)">
            <summary>
                Attempts to generate a callable shim for a command, aka it's implementation, using the given types.
            </summary>
        </member>
        <member name="M:Robust.Shared.Toolshed.ToolshedEnvironment.AllCommands">
            <summary>
                Provides every registered command, including subcommands.
            </summary>
            <returns>Enumerable of every command.</returns>
        </member>
        <member name="M:Robust.Shared.Toolshed.ToolshedEnvironment.GetCommand(System.String)">
            <summary>
                Gets a command's object by name.
            </summary>
            <param name="commandName">Command to get.</param>
            <returns>A command object.</returns>
            <exception cref="T:System.IndexOutOfRangeException">Thrown when there is no command of the given name.</exception>
        </member>
        <member name="M:Robust.Shared.Toolshed.ToolshedEnvironment.TryGetCommand(System.String,Robust.Shared.Toolshed.ToolshedCommand@)">
            <summary>
                Attempts to get a command's object by name.
            </summary>
            <param name="commandName">Command to get.</param>
            <param name="command">The command obtained, if any.</param>
            <returns>Success.</returns>
        </member>
        <member name="M:Robust.Shared.Toolshed.ToolshedEnvironment.#ctor">
            <summary>
                Initializes a default toolshed context.
            </summary>
        </member>
        <member name="M:Robust.Shared.Toolshed.ToolshedEnvironment.CommandsFittingConstraint(System.Type,System.Type)">
            <summary>
                Returns all commands that fit the given type constraints.
            </summary>
            <returns>Enumerable of matching command specs.</returns>
        </member>
        <member name="M:Robust.Shared.Toolshed.ToolshedEnvironment.CommandsTakingType(System.Type)">
            <summary>
                Returns all commands that accept the given type.
            </summary>
            <param name="t">Type to use in the query.</param>
            <returns>Enumerable of matching command specs.</returns>
            <remarks>Not currently type constraint aware.</remarks>
        </member>
        <member name="M:Robust.Shared.Toolshed.ToolshedEnvironment.GetCommandRetValues(Robust.Shared.Toolshed.CommandSpec)">
            <summary>
                Attempts to return the return values of the given command, if they can be decided.
            </summary>
            <remarks>
                Generics are flat out uncomputable so this doesn't bother.
            </remarks>
        </member>
        <member name="T:Robust.Shared.Toolshed.ToolshedManager">
            <summary>
                The overarching controller for Toolshed, providing invocation, reflection, commands, parsing, and other tools used by the language.
                <see href="https://docs.spacestation14.io/">External documentation</see> has a more in-depth look.
            </summary>
            <seealso cref="T:Robust.Shared.Toolshed.ToolshedCommand"/>
            <seealso cref="T:Robust.Shared.Toolshed.IInvocationContext"/>
        </member>
        <member name="M:Robust.Shared.Toolshed.ToolshedManager.Initialize">
            <summary>
                If you're not an engine developer, you probably shouldn't call this.
            </summary>
        </member>
        <member name="M:Robust.Shared.Toolshed.ToolshedManager.InvokeCommand(Robust.Shared.Player.ICommonSession,System.String,System.Object,System.Object@)">
            <summary>
                Invokes a command as the given user.
            </summary>
            <param name="session">User to run as.</param>
            <param name="command">Command to invoke.</param>
            <param name="input">An input value to use, if any.</param>
            <param name="result">The resulting value, if any.</param>
            <returns>Invocation success.</returns>
            <example><code>
                ToolshedManager toolshed = ...;
                ICommonSession ctx = ...;
                // Now run some user provided command and get a result!
                toolshed.InvokeCommand(ctx, userCommand, "my input value", out var result);
            </code></example>
            <remarks>
                This will use the same IInvocationContext as the one used by the user for debug console commands.
            </remarks>
        </member>
        <member name="M:Robust.Shared.Toolshed.ToolshedManager.InvokeCommand(Robust.Shared.Console.IConsoleShell,System.String,System.Object,System.Object@,Robust.Shared.Toolshed.IInvocationContext@)">
            <summary>
                Invokes a command as the given user.
            </summary>
            <param name="session">User to run as.</param>
            <param name="command">Command to invoke.</param>
            <param name="input">An input value to use, if any.</param>
            <param name="result">The resulting value, if any.</param>
            <returns>Invocation success.</returns>
            <example><code>
                ToolshedManager toolshed = ...;
                IConsoleShell ctx = ...;
                // Now run some user provided command and get a result!
                toolshed.InvokeCommand(ctx, userCommand, "my input value", out var result);
            </code></example>
            <remarks>
                This will use the same IInvocationContext as the one used by the user for debug console commands.
            </remarks>
        </member>
        <member name="M:Robust.Shared.Toolshed.ToolshedManager.InvokeCommand(Robust.Shared.Toolshed.IInvocationContext,System.String,System.Object,System.Object@)">
            <summary>
                Invokes a command with the given context.
            </summary>
            <param name="ctx">The context to run in.</param>
            <param name="command">Command to invoke.</param>
            <param name="input">An input value to use, if any.</param>
            <param name="result">The resulting value, if any.</param>
            <returns>Invocation success.</returns>
            <example><code>
                ToolshedManager toolshed = ...;
                IInvocationContext ctx = ...;
                // Now run some user provided command and get a result!
                toolshed.InvokeCommand(ctx, userCommand, "my input value", out var result);
            </code></example>
        </member>
        <member name="M:Robust.Shared.Toolshed.ToolshedManager.TryParse``1(Robust.Shared.Toolshed.Syntax.ParserContext,``0@,Robust.Shared.Toolshed.Errors.IConError@)">
            <summary>
                Attempts to parse the given type.
            </summary>
            <param name="parserContext">The input to parse from.</param>
            <param name="parsed">The parsed value, if any.</param>
            <param name="error">A console error, if any, that can be reported to explain the parsing failure.</param>
            <typeparam name="T">The type to parse from the input.</typeparam>
            <returns>Success.</returns>
        </member>
        <member name="M:Robust.Shared.Toolshed.ToolshedManager.TryAutocomplete(Robust.Shared.Toolshed.Syntax.ParserContext,System.Type,System.String)">
            <summary>
                iunno man it does autocomplete what more do u want
            </summary>
        </member>
        <member name="M:Robust.Shared.Toolshed.ToolshedManager.TryParse(Robust.Shared.Toolshed.Syntax.ParserContext,System.Type,System.Object@,Robust.Shared.Toolshed.Errors.IConError@)">
            <summary>
                Attempts to parse the given type.
            </summary>
            <param name="parserContext">The input to parse from.</param>
            <param name="t">The type to parse from the input.</param>
            <param name="parsed">The parsed value, if any.</param>
            <param name="error">A console error, if any, that can be reported to explain the parsing failure.</param>
            <returns>Success.</returns>
        </member>
        <member name="P:Robust.Shared.Toolshed.ToolshedManager.ActivePermissionController">
            <summary>
                The active permission controller, if any.
            </summary>
            <remarks>
                Invocation contexts can entirely ignore this, though it's bad form to do so if they have a session on hand.
            </remarks>
        </member>
        <member name="M:Robust.Shared.Toolshed.ToolshedManager.PrettyPrintType(System.Object,System.Collections.IEnumerable@,System.Boolean,System.Nullable{System.Int32})">
            <summary>
                Pretty prints a value for use in the console.
            </summary>
            <param name="value">Value to pretty print.</param>
            <param name="maxOutput">The maximum number of values that can be output in a list.</param>
            <returns>The stringified value.</returns>
            <remarks>
                This returns markup.
            </remarks>
        </member>
        <member name="T:Robust.Shared.Toolshed.CommandSpec">
            <summary>
                A command specification, containing both the command object and the selected subcommand if any.
            </summary>
            <param name="Cmd">Command object.</param>
            <param name="SubCommand">Subcommand, if any.</param>
        </member>
        <member name="M:Robust.Shared.Toolshed.CommandSpec.#ctor(Robust.Shared.Toolshed.ToolshedCommand,System.String)">
            <summary>
                A command specification, containing both the command object and the selected subcommand if any.
            </summary>
            <param name="Cmd">Command object.</param>
            <param name="SubCommand">Subcommand, if any.</param>
        </member>
        <member name="P:Robust.Shared.Toolshed.CommandSpec.Cmd">
            <summary>Command object.</summary>
        </member>
        <member name="P:Robust.Shared.Toolshed.CommandSpec.SubCommand">
            <summary>Subcommand, if any.</summary>
        </member>
        <member name="M:Robust.Shared.Toolshed.CommandSpec.AsType">
            <inheritdoc/>
        </member>
        <member name="M:Robust.Shared.Toolshed.CommandSpec.AsCompletion">
            <summary>
                Returns a completion option for this command, for use in autocomplete.
            </summary>
        </member>
        <member name="M:Robust.Shared.Toolshed.CommandSpec.FullName">
            <summary>
                Returns the full name of the command.
            </summary>
        </member>
        <member name="M:Robust.Shared.Toolshed.CommandSpec.DescLocStr">
            <summary>
                Returns the localization string for the description of this command.
            </summary>
        </member>
        <member name="M:Robust.Shared.Toolshed.CommandSpec.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Robust.Shared.Toolshed.UnparseableValueError">
            <summary>
                Error that's given if a type cannot be parsed due to lack of parser.
            </summary>
            <param name="T">The type being parsed.</param>
        </member>
        <member name="M:Robust.Shared.Toolshed.UnparseableValueError.#ctor(System.Type)">
            <summary>
                Error that's given if a type cannot be parsed due to lack of parser.
            </summary>
            <param name="T">The type being parsed.</param>
        </member>
        <member name="P:Robust.Shared.Toolshed.UnparseableValueError.T">
            <summary>The type being parsed.</summary>
        </member>
        <member name="T:Robust.Shared.Toolshed.TypeParsers.IAsType`1">
            <summary>
            Generalized unboxing of a value from a containing structure.
            </summary>
        </member>
        <member name="T:Robust.Shared.Toolshed.TypeParsers.SessionTypeParser">
            <summary>
            Parse a username to an <see cref="T:Robust.Shared.Player.ICommonSession"/>
            </summary>
        </member>
        <member name="T:Robust.Shared.Upload.SharedNetworkResourceManager">
            <summary>
                Manager that allows resources to be added at runtime by admins.
                They will be sent to all clients automatically.
            </summary>
        </member>
        <member name="F:Robust.Shared.Upload.SharedNetworkResourceManager.Prefix">
            <summary>
                The prefix for any and all downloaded network resources.
            </summary>
        </member>
        <member name="T:Robust.Shared.Upload.SharedPrototypeLoadManager">
            <summary>
                Manages sending runtime-loaded prototypes from game staff to clients.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.Base64Helpers.ConvertToBase64Url(System.Byte[])">
            <summary>
            Converts a byte array such as a hash to a Base64 representation that is URL safe.
            </summary>
            <param name="data"></param>
            <returns>A base64url string form of the byte array.</returns>
        </member>
        <member name="M:Robust.Shared.Utility.Base64Helpers.ConvertToBase64Url(System.String)">
            <summary>
            Converts a a Base64 string to one that is URL safe.
            </summary>
            <returns>A base64url formed string.</returns>
        </member>
        <member name="M:Robust.Shared.Utility.Base64Helpers.ConvertFromBase64Url(System.String)">
            <summary>
            Converts a URL-safe Base64 string into a byte array.
            </summary>
            <param name="s">A base64url formed string.</param>
            <returns>The represented byte array.</returns>
        </member>
        <member name="T:Robust.Shared.Utility.BufferHelpers">
            <summary>
            Helpers for dealing with buffer-like arrays.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.BufferHelpers.EnsureBuffer``1(``0[]@,System.Int32)">
            <summary>
            Resize the given buffer to the next power of two that fits the needed size.
            The contents of the buffer are NOT preserved if resized.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.BufferHelpers.EnsurePooledBuffer``1(``0[]@,System.Buffers.ArrayPool{``0},System.Int32)">
            <summary>
            Resize the given buffer to the next power of two that fits the needed size.
            Takes an array pool to rent/return with.
            The contents of the buffer are NOT preserved across resizes.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.BufferHelpers.FittingPowerOfTwo(System.Int32)">
            <summary>
            Calculate the smallest power of two that fits the required size.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.Extensions.EnsureLength``1(``0[]@,System.Int32)">
            <summary>
            Ensures that the specified array has the specified length.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.Extensions.ShallowClone``1(System.Collections.Generic.List{``0})">
            <summary>
                Creates a shallow clone of a list.
                Basically a new list with all the same elements.
            </summary>
            <param name="self">The list to shallow clone.</param>
            <typeparam name="T">The type of the list's elements.</typeparam>
            <returns>A new list with the same elements as <paramref name="list" />.</returns>
        </member>
        <member name="M:Robust.Shared.Utility.Extensions.RemoveSwap``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>
                Remove an item from the list, replacing it with the one at the very end of the list.
                This means that the order will not be preserved, but it should be an O(1) operation.
            </summary>
            <param name="index">The index to remove</param>
            <returns>The removed element</returns>
        </member>
        <member name="M:Robust.Shared.Utility.Extensions.Pop``1(System.Collections.Generic.IList{``0})">
            <summary>
                Pop an element from the end of a list, removing it from the list and returning it.
            </summary>
            <param name="list">The list to pop from.</param>
            <typeparam name="T">The type of the elements of the list.</typeparam>
            <returns>The popped off element.</returns>
            <exception cref="T:System.InvalidOperationException">
                Thrown if the list is empty.
            </exception>
        </member>
        <member name="M:Robust.Shared.Utility.Extensions.FirstOrNull``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
                Just like <see cref="M:System.Linq.Enumerable.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})"/> but returns null for value types as well.
            </summary>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> to return an element from.</param>
            <param name="predicate">A function to test each element for a condition.</param>
            <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
            <returns> null if <paramref name="source" /> is empty or if no element passes the test specified by <paramref name="predicate" />; otherwise, the first element in <paramref name="source" /> that passes the test specified by <paramref name="predicate" />.</returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:Robust.Shared.Utility.Extensions.FirstOrNull``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
                Just like <see cref="M:System.Linq.Enumerable.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0})"/> but returns null for value types as well.
            </summary>
            <param name="source">
                An <see cref="T:System.Collections.Generic.IEnumerable`1" /> to return the first element from.
            </param>
            <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
            <returns>
                <see langword="null" /> if <paramref name="source" /> is empty, otherwise,
                the first element in <paramref name="source" />.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="source" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:Robust.Shared.Utility.Extensions.TryFirstOrNull``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},System.Nullable{``0}@)">
            <summary>
                Just like <see cref="M:System.Linq.Enumerable.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})"/> but returns null for value types as well.
            </summary>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> to return an element from.</param>
            <param name="predicate">A function to test each element for a condition.</param>
            <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
            <returns>True if an element has been found.</returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:Robust.Shared.Utility.Extensions.TryFirstOrNull``1(System.Collections.Generic.IEnumerable{``0},System.Nullable{``0}@)">
            <summary>
                Just like <see cref="M:System.Linq.Enumerable.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})"/> but returns null for value types as well.
            </summary>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> to return an element from.</param>
            <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
            <returns>True if an element has been found.</returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="source" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:Robust.Shared.Utility.Extensions.TryFirstOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},``0@)">
            <summary>
                Wraps Linq's FirstOrDefault.
            </summary>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> to return an element from.</param>
            <param name="predicate">A function to test each element for a condition.</param>
            <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
            <returns>True if an element has been found.</returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:Robust.Shared.Utility.Extensions.TryFirstOrDefault``1(System.Collections.Generic.IEnumerable{``0},``0@)">
            <summary>
                Wraps Linq's FirstOrDefault.
            </summary>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> to return an element from.</param>
            <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
            <returns>True if an element has been found.</returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="source" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:Robust.Shared.Utility.Extensions.TryCastValue``3(System.Collections.Generic.Dictionary{``1,``2},``1,``0@)">
            <summary>
            Tries to get a value from a dictionary and checks if that value is of type T
            </summary>
            <typeparam name="T">The type that sould be casted to</typeparam>
            <returns>Whether the value was present in the dictionary and of the required type</returns>
        </member>
        <member name="M:Robust.Shared.Utility.CommandParsing.ParseArguments(System.ReadOnlySpan{System.Char},System.Collections.Generic.List{System.String})">
            <summary>
            Parses a full console command into a list of arguments.
            </summary>
            <param name="text">Full input string.</param>
            <param name="args">List of arguments to write into.</param>
        </member>
        <member name="M:Robust.Shared.Utility.DebugTools.Assert(System.String)">
            <summary>
                An assertion that will always <see langword="throw" /> an exception.
            </summary>
            <param name="message">Exception message.</param>
        </member>
        <member name="M:Robust.Shared.Utility.DebugTools.Assert(System.Boolean)">
            <summary>
                An assertion that will <see langword="throw" /> an exception if the
                <paramref name="condition" /> is not true.
            </summary>
            <param name="condition">Condition that must be true.</param>
        </member>
        <member name="M:Robust.Shared.Utility.DebugTools.AssertEqual(System.Object,System.Object)">
            <summary>
                An assertion that will <see langword="throw"/> an exception if
                <see cref="!:objA"/> and <see cref="!:objB"/> are not equal.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.DebugTools.AssertEqual(System.Object,System.Object,System.String)">
            <summary>
                An assertion that will <see langword="throw"/> an exception with <see cref="!:message"/> embedded if
                <see cref="!:objA"/> and <see cref="!:objB"/> are not equal.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.DebugTools.AssertEqual``1(``0,``0)">
            <summary>
                A non-boxing assertion that will <see langword="throw"/> an exception if
                <see cref="!:objA"/> and <see cref="!:objB"/> are not equal.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.DebugTools.AssertEqual``1(``0,``0,System.String)">
            <summary>
                A non-boxing assertion that will <see langword="throw"/> an exception with <see cref="!:message"/> embedded if
                <see cref="!:objA"/> and <see cref="!:objB"/> are not equal.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.DebugTools.AssertNotEqual(System.Object,System.Object)">
            <summary>
                An assertion that will <see langword="throw"/> an exception if
                <see cref="!:objA"/> and <see cref="!:objB"/> are equal.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.DebugTools.AssertNotEqual(System.Object,System.Object,System.String)">
            <summary>
                An assertion that will <see langword="throw"/> an exception with <see cref="!:message"/> embedded if
                <see cref="!:objA"/> and <see cref="!:objB"/> are not equal.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.DebugTools.AssertNotEqual``1(``0,``0)">
            <summary>
                A non-boxing assertion that will <see langword="throw"/> an exception if
                <see cref="!:objA"/> and <see cref="!:objB"/> are equal.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.DebugTools.AssertNotEqual``1(``0,``0,System.String)">
            <summary>
                An assertion that will <see langword="throw"/> an exception with <see cref="!:message"/> embedded if
                <see cref="!:objA"/> and <see cref="!:objB"/> are not equal.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.DebugTools.Assert(System.Boolean,System.String)">
            <summary>
                An assertion that will <see langword="throw" /> an exception if the
                <paramref name="condition" /> is not true.
            </summary>
            <param name="condition">Condition that must be true.</param>
            <param name="message">Exception message.</param>
        </member>
        <member name="M:Robust.Shared.Utility.DebugTools.Assert(System.Boolean,Robust.Shared.Utility.DebugTools.AssertInterpolatedStringHandler@)">
            <summary>
                An assertion that will <see langword="throw" /> an exception if the
                <paramref name="condition" /> is not true.
            </summary>
            <param name="condition">Condition that must be true.</param>
            <param name="message">Exception message.</param>
        </member>
        <member name="M:Robust.Shared.Utility.DebugTools.AssertNotNull(System.Object,System.String)">
            <summary>
                An assertion that will <see langword="throw" /> an exception if the
                <paramref name="arg" /> is <see langword="null" />.
            </summary>
            <param name="arg">Condition that must be true.</param>
            <param name="message">Exception message.</param>
        </member>
        <member name="M:Robust.Shared.Utility.DebugTools.AssertNull(System.Object,System.String)">
            <summary>
                An assertion that will <see langword="throw" /> an exception if the
                <paramref name="arg" /> is not <see langword="null" />.
            </summary>
            <param name="arg">Condition that must be true.</param>
            <param name="message">Exception message.</param>
        </member>
        <member name="M:Robust.Shared.Utility.DebugTools.Break">
            <summary>
            If a debugger is attached to the process, calling this function will cause the
            debugger to break. Equivalent to a software interrupt (INT 3).
            </summary>
        </member>
        <member name="F:Robust.Shared.Utility.EncodingHelpers.UTF8">
            <summary>
                Custom version of <see cref="P:System.Text.Encoding.UTF8"/> that DOESN'T do BOMs.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.FileHelper.TryOpenFileRead(System.String,System.IO.FileStream@)">
            <summary>
            Try to open a file for reading. If the file does not exist, the operation fails without exception.
            </summary>
            <remarks>
            This API is not atomic and can thus be vulnerable to TOCTOU attacks. Don't use it if that's relevant.
            </remarks>
            <param name="path">The path to try to open.</param>
            <param name="stream">The resulting file stream.</param>
            <returns>True if the file existed and was opened.</returns>
        </member>
        <member name="T:Robust.Shared.Utility.FixedArray">
            <summary>
            Fixed size array stack allocation helpers.
            </summary>
            <remarks>
            <para>
            This helper class can be used to work around the limitation that <c>stackalloc</c>
            cannot be used with ref types.
            </para>
            <para>
            To use, call it like so:
            <code>
            var span = FixedArray.Alloc32&lt;object&gt;(out _);
            </code>
            There is an <c>out</c> parameter that you should probably always discard (as shown in the example).
            This is so that stack space is properly allocated in your stack frame.
            </para>
            <para>
            Do NOT under ANY CIRCUMSTANCE return the span given up the stack in any way.
            You will break the GC and stack and (worst of all) I will shed you.
            </para>
            <para>
            This class cannot be used with variable size allocations.
            Just allocate a we'll-never-need-more bound like 128 and slim it down.
            </para>
            </remarks>
        </member>
        <member name="T:Robust.Shared.Utility.FormattedMessage">
            <summary>
                Represents a formatted message in the form of a list of "tags".
                Does not do any concrete formatting, simply useful as an API surface.
            </summary>
        </member>
        <member name="P:Robust.Shared.Utility.FormattedMessage.Nodes">
            <summary>
            The list of nodes the formatted message is made out of
            </summary>
        </member>
        <member name="P:Robust.Shared.Utility.FormattedMessage.IsEmpty">
            <summary>
            true if the formatted message doesn't contain any nodes
            </summary>
        </member>
        <member name="F:Robust.Shared.Utility.FormattedMessage._openNodeStack">
            <summary>
            Used for inserting the correct closing node when calling <see cref="M:Robust.Shared.Utility.FormattedMessage.Pop"/>
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.FormattedMessage.#ctor(Robust.Shared.Utility.FormattedMessage)">
            <summary>
                Create a new <c>FormattedMessage</c> by copying another one.
            </summary>
            <param name="toCopy">The message to copy.</param>
        </member>
        <member name="M:Robust.Shared.Utility.FormattedMessage.TryFromMarkup(System.String,Robust.Shared.Utility.FormattedMessage@,System.String@)">
            <summary>
            Attempt to create a new formatted message from some markup text. Returns an error if it fails.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.FormattedMessage.TryFromMarkup(System.String,Robust.Shared.Utility.FormattedMessage@)">
            <summary>
            Attempt to create a new formatted message from some markup text.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.FormattedMessage.FromMarkupOrThrow(System.String)">
            <summary>
            Attempt to create a new formatted message from some markup text. Throws if the markup is invalid.
            </summary>
            <exception cref="T:Nett.Parser.ParseException">Thrown when an error occurs while trying to parse the markup.</exception>
        </member>
        <member name="M:Robust.Shared.Utility.FormattedMessage.FromMarkupPermissive(System.String,System.String@)">
            <summary>
            Variant of <see cref="M:Robust.Shared.Utility.FormattedMessage.TryFromMarkup(System.String,Robust.Shared.Utility.FormattedMessage@,System.String@)"/> that
            attempts to fall back to using the permissive parser that interprets invalid markup tags as normal text.
            This may still throw if the permissive parser fails.
            </summary>
            <exception cref="T:Nett.Parser.ParseException">Thrown when an error occurs while trying to parse the markup.</exception>
        </member>
        <member name="M:Robust.Shared.Utility.FormattedMessage.FromMarkupPermissive(System.String)">
            <inheritdoc cref="M:Robust.Shared.Utility.FormattedMessage.FromMarkupPermissive(System.String,System.String@)"/>
        </member>
        <member name="M:Robust.Shared.Utility.FormattedMessage.EscapeText(System.String)">
            <summary>
                Escape a string of text to be able to be formatted into markup.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.FormattedMessage.RemoveMarkupOrThrow(System.String)">
            <summary>
                Remove all markup, leaving only the basic text content behind. Throws if it fails to parse the markup tags.
            </summary>
            <exception cref="T:Nett.Parser.ParseException">Thrown when an error occurs while trying to parse the markup.</exception>
        </member>
        <member name="M:Robust.Shared.Utility.FormattedMessage.RemoveMarkupPermissive(System.String)">
            <summary>
            Attempts to remove all valid markup tags, leaving only the basic text content behind.
            If this markup contains invalid tags that cannot be parsed, they will not be removed and will instead be trated
            as normal text. Hence the output should probably only be parsed using try-parse the permissive parser.
            </summary>
            <exception cref="T:Nett.Parser.ParseException">Thrown when an error occurs while trying to fall back to the permissive parser.</exception>
        </member>
        <member name="M:Robust.Shared.Utility.FormattedMessage.AddText(System.String)">
            <summary>
            Adds a text node.
            This node doesn't need to be closed with <see cref="M:Robust.Shared.Utility.FormattedMessage.Pop"/>.
            </summary>
            <param name="text">The text to add</param>
        </member>
        <member name="M:Robust.Shared.Utility.FormattedMessage.PushColor(Robust.Shared.Maths.Color)">
            <summary>
            Adds an open color node. It needs to later be closed by calling <see cref="M:Robust.Shared.Utility.FormattedMessage.Pop"/>
            </summary>
            <param name="color">The color of the node to add</param>
        </member>
        <member name="M:Robust.Shared.Utility.FormattedMessage.PushNewline">
            <summary>
            Adds a newline as a text node.
            This node doesn't need to be closed with <see cref="M:Robust.Shared.Utility.FormattedMessage.Pop"/>.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.FormattedMessage.PushTag(Robust.Shared.Utility.MarkupNode,System.Boolean)">
            <summary>
            Adds a new open node to the formatted message.
            The method for inserting closed nodes: <see cref="M:Robust.Shared.Utility.FormattedMessage.Pop"/>. It needs to be
            called once for each inserted open node that isn't self closing.
            </summary>
            <param name="markupNode">The node to add</param>
            <param name="selfClosing">Whether the node is self closing or not.
            Self closing nodes automatically insert a closing node after the open one</param>
        </member>
        <member name="M:Robust.Shared.Utility.FormattedMessage.Pop">
            <summary>
            Closes the last added node that wasn't self closing
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.FormattedMessage.AddMessage(Robust.Shared.Utility.FormattedMessage)">
            <summary>
            Adds a formatted message to this one.
            </summary>
            <param name="other">The formatted message to be added</param>
        </member>
        <member name="M:Robust.Shared.Utility.FormattedMessage.Clear">
            <summary>
            Clears the formatted message
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.FormattedMessage.EnumerateRunes">
            <summary>
            Returns an enumerator that enumerates every rune for each text node contained in this formatted text instance.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.FormattedMessage.ToString">
            <returns>The string without markup tags.</returns>
        </member>
        <member name="M:Robust.Shared.Utility.FormattedMessage.ToMarkup">
            <returns>The string without filtering out markup tags.</returns>
        </member>
        <member name="M:Robust.Shared.Utility.FormattedMessage.ValidMarkup(System.String)">
            <summary>
            Runs the given markup through the parser and returns if the markup is valid or not
            </summary>
            <param name="markup">The markup to check for validity</param>
            <returns>true if the markup is valid</returns>
        </member>
        <member name="M:Robust.Shared.Utility.FormattedMessage.TryAddMarkup(System.String,System.String@)">
            <summary>
            Attempts to add markup. If an error occurs, it will do nothing and return an error message.
            This method does NOT fall back to using the permissive parser (which parses invalid markup as text).
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.FormattedMessage.AddMarkupOrThrow(System.String)">
            <summary>
            Parses the given markup and adds the resulting nodes to this formatted message
            </summary>
            <param name="markup">The markup to parse</param>
            <exception cref="T:Pidgin.ParseException">Thrown when an error occurs while trying to parse the markup.</exception>
        </member>
        <member name="M:Robust.Shared.Utility.FormattedMessage.AddMarkupPermissive(System.String,System.String@)">
            <summary>
                Same as <see cref="M:Robust.Shared.Utility.FormattedMessage.AddMarkup(System.String)"/> but will attempt to parse invalid markup tags as text.
            </summary>
            <exception cref="T:Pidgin.ParseException">Thrown when an error occurs even when using the permissive parser.</exception>
        </member>
        <member name="M:Robust.Shared.Utility.FormattedMessage.AddMarkupPermissive(System.String)">
            <inheritdoc cref="M:Robust.Shared.Utility.FormattedMessage.AddMarkupPermissive(System.String,System.String@)"/>
        </member>
        <member name="M:Robust.Shared.Utility.FormattedMessage.PushMarkup(System.String)">
            <summary>
            Same as <see cref="M:Robust.Shared.Utility.FormattedMessage.AddMarkup(System.String)"/> but adds a newline too.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.FormattedMessage.ParseOrThrow(System.String)">
            <summary>
            This parser doesn't use backtracking by chaining pidgins parsers in such a way that branches that don't apply
            always fail on the first character
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.FormattedMessage.TryParse(System.String,System.Collections.Generic.List{Robust.Shared.Utility.MarkupNode}@,System.String@)">
            <summary>
            Attempt to parse the given input. Returns an error message if it fails. Does not fall back to the permissive parser
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.FormattedMessage.ParsePermissive(System.String,System.String@)">
            <summary>
            Variant of <see cref="M:Robust.Shared.Utility.FormattedMessage.TryParse(System.String,System.Collections.Generic.List{Robust.Shared.Utility.MarkupNode}@,System.String@)"/> that falls back to using the permissive parser if an error occurs.
            </summary>
            <exception cref="T:Pidgin.ParseException">Thrown when an error occurs even when using the permissive parser.</exception>
        </member>
        <member name="M:Robust.Shared.Utility.FormattedMessage.CreateTag(System.String,Robust.Shared.Utility.MarkupParameter,System.Collections.Generic.IEnumerable{Robust.Shared.Utility.FormattedMessage.TagInfo},System.Boolean)">
            <summary>
            Creates a tag node-
            </summary>
            <param name="name">The tag name</param>
            <param name="parameter">An optional parameter</param>
            <param name="attributesEnumerator">A list of attributes</param>
            <param name="selfClosing">Whether the node is self closing or node. Self closing nodes immediately </param>
            <returns></returns>
        </member>
        <member name="M:Robust.Shared.Utility.FormattedMessage.FlattenTagLists(System.Collections.Generic.IEnumerable{System.Collections.Generic.List{Robust.Shared.Utility.MarkupNode}})">
            <summary>
            Both node parsers return a list containing short lists of parsed tags.
            This method flattens that list.
            </summary>
        </member>
        <member name="T:Robust.Shared.Utility.GridLineEnumerator">
            <summary>
                Iterate points of grid line from start to finish.
            </summary>
            <remarks>
                Start and finish points are included. The order is guaranteed
                and always goes from start to finish.
            </remarks>
        </member>
        <member name="T:Robust.Shared.Utility.GrowableStack`1">
            <summary>
            This is a growable LIFO stack with an initial capacity of N.
            If the stack size exceeds the initial capacity, the heap is used
            to increase the size of the stack.
            </summary>
            <typeparam name="T">The type of elements in the stack.</typeparam>
        </member>
        <member name="M:Robust.Shared.Utility.GrowableStack`1.#ctor(System.Span{`0})">
            <summary>
                Creates the growable stack with the allocated space as stack space.
            </summary>
        </member>
        <member name="T:Robust.Shared.Utility.HashCodeHelpers">
            <summary>
            Utility functions for working with <see cref="T:System.HashCode"/>.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.HashCodeHelpers.AddArray``1(System.HashCode@,``0[])">
            <summary>
            Add the contents of an array to a <see cref="T:System.HashCode"/>.
            </summary>
        </member>
        <member name="T:Robust.Shared.Utility.HasherStream">
            <summary>
                Stream that passes through data to/from another stream while running a <see cref="T:System.Security.Cryptography.IncrementalHash"/> on it.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.HttpClientUserAgent.AddUserAgent(System.Net.Http.HttpClient)">
            <summary>
            Add a Robust-specific user agent to the default request headers of the given <see cref="T:System.Net.Http.HttpClient"/>.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.ImageOps.Blit``1(SixLabors.ImageSharp.Image{``0},Robust.Shared.Maths.UIBox2i,SixLabors.ImageSharp.Image{``0},Robust.Shared.Maths.Vector2i)">
            <summary>
                Blit an image into another, with the specified offset.
            </summary>
            <param name="source">The image to copy data from.</param>
            <param name="sourceRect">The sub section of <see cref="!:source"/> that will be copied.</param>
            <param name="destinationOffset">
                The offset into <see cref="!:destination"/> that data will be copied into.
            </param>
            <param name="destination">The image to copy to.</param>
            <typeparam name="T">The type of pixel stored in the images.</typeparam>
        </member>
        <member name="M:Robust.Shared.Utility.ImageOps.GetPixelSpan``1(SixLabors.ImageSharp.Image{``0})">
            <summary>
            Gets a <see cref="T:System.Span`1" /> to the backing data if the backing group consists of a single contiguous memory buffer.
            </summary>
            <returns>The <see cref="T:System.Span`1" /> referencing the memory area.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the image is not a single contiguous buffer.</exception>
        </member>
        <member name="T:Robust.Shared.Utility.IUniqueIndex`2">
            <summary>
            A dictionary of mutable and immutable sets for use as an index of unique values related to another collection.
            Imitates the behavior of an index in a RDBMS.
            </summary>
            <remarks>
            Implementations may or may not be intended to be explicitly constructed before use.
            Do not use this interface directly as it is inherited by structs which will cause boxing.
            This interface is used for conformity and documentation.
            </remarks>
            <typeparam name="TKey">The type of key.</typeparam>
            <typeparam name="TValue">The type of value.</typeparam>
            <seealso cref="T:Robust.Shared.Utility.UniqueIndexExtensions"/>
        </member>
        <member name="P:Robust.Shared.Utility.IUniqueIndex`2.KeyCount">
            <summary>
            The count of keys (and thus sets) in this index.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.IUniqueIndex`2.Add(`0,`1)">
            <summary>
            Adds a value.
            </summary>
            <param name="key">The associated key.</param>
            <param name="value">A value to be added.</param>
            <returns><c>true</c> upon success, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Robust.Shared.Utility.IUniqueIndex`2.AddRange(`0,System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Adds a collection of values to a set.
            </summary>
            <param name="key">The associated key.</param>
            <param name="values">A collection of values.</param>
            <returns>The count of values that were added to the set.</returns>
        </member>
        <member name="M:Robust.Shared.Utility.IUniqueIndex`2.Remove(`0)">
            <summary>
            Removes a set.
            </summary>
            <param name="key">The associated key.</param>
            <returns><c>true</c> upon success, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Robust.Shared.Utility.IUniqueIndex`2.Remove(`0,`1)">
            <summary>
            Removes a value.
            </summary>
            <param name="key">The associated key.</param>
            <param name="value">A value to be removed.</param>
            <returns><c>true</c> upon success, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Robust.Shared.Utility.IUniqueIndex`2.RemoveRange(`0,System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Removes a collection of values from a set.
            </summary>
            <param name="key">The associated key.</param>
            <param name="values">A collection of values.</param>
            <returns>The count of values that were removed from the set.</returns>
        </member>
        <member name="M:Robust.Shared.Utility.IUniqueIndex`2.Replace(`0,`1,`1)">
            <summary>
            Replaces a old value with a new value.
            </summary>
            <param name="key">The associated key.</param>
            <param name="oldValue">A value to be replaced.</param>
            <param name="newValue">A value to replace with.</param>
            <returns><c>true</c> upon success, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Robust.Shared.Utility.IUniqueIndex`2.Touch(`0)">
            <summary>
            Ensures an empty mutable set for a given key.
            </summary>
            <param name="key">A given key.</param>
        </member>
        <member name="M:Robust.Shared.Utility.IUniqueIndex`2.Initialize(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Initializes the index from a collection of keys.
            </summary>
            <param name="keys">A collection of keys.</param>
            <exception cref="T:System.InvalidOperationException">Already initialized.</exception>
        </member>
        <member name="M:Robust.Shared.Utility.IUniqueIndex`2.Initialize(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.HashSet{`1}}})">
            <summary>
            Initializes the index from an equivalent collection.
            </summary>
            <param name="index">An equivalent collection.</param>
            <exception cref="T:System.InvalidOperationException">Already initialized.</exception>
        </member>
        <member name="T:Robust.Shared.Utility.LineEnumerator">
            <summary>
            Helper for iterating over the lines in some text.
            </summary>
            <remarks>
            Supports both LF and CRLF.
            </remarks>
        </member>
        <member name="M:Robust.Shared.Utility.LineEnumerator.#ctor(System.ReadOnlyMemory{System.Char})">
            <param name="text">The memory that will be scanned over for lines.</param>
        </member>
        <member name="M:Robust.Shared.Utility.LineEnumerator.MoveNext(System.Int32@,System.Int32@)">
            <summary>
            Scan for the next line. Gives back the line's start and end position in the given memory.
            </summary>
            <remarks>
            The returned end position includes the newline character (LF or CRLF),
            except for the last line in the data if there's no trailing newline.
            </remarks>
            <returns>True if another line is available, false if the given text is exhausted.</returns>
        </member>
        <member name="T:Robust.Shared.Utility.LockUtility">
            <summary>
            Convenience utilities for working with various locking classes.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.LockUtility.ReadGuard(System.Threading.ReaderWriterLockSlim)">
            <summary>
            Enter a read lock on a <see cref="T:System.Threading.ReaderWriterLockSlim"/>. Dispose the returned value to exit the read lock.
            </summary>
            <remarks>
            This is intended to be used with a <see langword="using" /> statement or block.
            </remarks>
        </member>
        <member name="M:Robust.Shared.Utility.LockUtility.WriteGuard(System.Threading.ReaderWriterLockSlim)">
            <summary>
            Enter a write lock on a <see cref="T:System.Threading.ReaderWriterLockSlim"/>. Dispose the returned value to exit the write lock.
            </summary>
            <remarks>
            This is intended to be used with a <see langword="using" /> statement or block.
            </remarks>
        </member>
        <member name="M:Robust.Shared.Utility.LockUtility.WaitGuard(System.Threading.SemaphoreSlim)">
            <summary>
            Wait on a <see cref="T:System.Threading.SemaphoreSlim"/>. Dispose the returned value to release.
            </summary>
            <remarks>
            This is intended to be used with a <see langword="using" /> statement or block.
            </remarks>
        </member>
        <member name="M:Robust.Shared.Utility.LockUtility.WaitGuardAsync(System.Threading.SemaphoreSlim)">
            <summary>
            Wait on a <see cref="T:System.Threading.SemaphoreSlim"/> asynchronously. Dispose the returned value to release.
            </summary>
            <remarks>
            This is intended to be used with a <see langword="using" /> statement or block.
            </remarks>
        </member>
        <member name="M:Robust.Shared.Utility.MarkupNode.#ctor(System.String)">
            <summary>
            Creates a nameless tag for plaintext
            </summary>
            <param name="text">The plaintext the tag will consist of</param>
        </member>
        <member name="M:Robust.Shared.Utility.NullableHelper.IsMarkedAsNullable(Robust.Shared.Utility.AbstractFieldInfo)">
            <summary>
            Checks if the field has a nullable annotation [?]
            </summary>
            <param name="field"></param>
            <returns></returns>
        </member>
        <member name="T:Robust.Shared.Utility.Parse">
            <summary>
            Helpers for parsing culture-invariant data.
            </summary>
            <remarks>
            APIs like <see cref="M:System.Int32.TryParse(System.String,System.Int32@)"/> are culture sensitive by default,
            and making them not culture sensitive is extremely verbose.
            These helpers are culture insensitive without requiring you to write a whole shakespeare novel
            for the privilege of having code that isn't gonna break for French people.</remarks>
        </member>
        <member name="T:Robust.Shared.Utility.PoolHelpers">
            <summary>
            Helpers for working with memory pooling such as <see cref="T:System.Buffers.ArrayPool`1"/>
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.PoolHelpers.ReturnGuard``1(System.Buffers.ArrayPool{``0},``0[])">
            <summary>
            Provides a disposable guard to return an array pool entry.
            </summary>
            <remarks>
            This is intended to be used with using statements.
            </remarks>
        </member>
        <member name="T:Robust.Shared.Utility.PoolHelpers.PoolReturnGuard`1">
            <summary>
            Disposes the given array into the given array pool on dispose.
            </summary>
        </member>
        <member name="T:Robust.Shared.Utility.PrettyPrint">
            <summary>
                Utility class for producing debug menu representations.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.PrettyPrint.PrintUserFacing(System.Object)">
             <summary>
                 Get the user-facing string representation of a value.
            
                 This is intended for menus where users are required to look at
                 some kind of raw engine representation. It is not a substitute
                 for a proper UI.
             </summary>
             <param name="value">The object to represent.</param>
             <returns>A readable representation of the object.</returns>
        </member>
        <member name="M:Robust.Shared.Utility.PrettyPrint.PrintUserFacingWithType(System.Object,System.String@)">
             <summary>
                 Get the user-facing string representation of a value, along with
                 the representation of its type.
            
                 See <see cref='M:Robust.Shared.Utility.PrettyPrint.PrintUserFacing(System.Object)'/> for usage details. This
                 also returns a user-facing representation of the object's type in
                 <paramref name="typeRep"/> if it is different to that of the object.
                 If the object's <c>ToString()</c> implementation is the default
                 one, then <paramref name="typeRep"/> will be <c>""</c>.
             </summary>
             <param name="value">The object to represent.</param>
             <param name="typeRef">
               The representation of the object's type, if distinct from the
               returned value. Otherwise, <c>""</c>.
             </param>
             <returns>A readable representation of the object.</returns>
        </member>
        <member name="M:Robust.Shared.Utility.PrettyPrint.PrintUserFacingTypeShort(System.Type,System.Int32)">
            <summary>
                Creates an even shorter, even more readable abbreviation of a type.
                Reduces the amount of 'sections' (excluding the type name, which is always shown) to <see cref="!:maxSections"/>
            </summary>
            <remarks>
                Not guaranteed to make a unique name, obviously.
                This is mostly just for ViewVariables since the long type names don't give very useful info. and really
                the only things we need are whether it's engine/content, the project (client/shared/server) and the type name.
            </remarks>
            <param name="type">The type to abbreviate.</param>
            <param name="maxSections">Max sections that the full name should have, excluding the type name.</param>
            <returns>A shorter representation of the passed type than given by `ToString()` or <see cref="M:Robust.Shared.Utility.TypeAbbreviation.Abbreviate(System.Type)"/>.</returns>
        </member>
        <member name="T:Robust.Shared.Utility.PriorityQueue`1">
            <summary>
            Heap-based resizable max-priority queue.
            Elements with high priority are served before elements with low priority.
            Priority is defined by comparing elements, so to separate priority from value use
            KeyValuePair or a custom class and provide corresponding Comparer.
            </summary>
            <typeparam name="T">Any comparable type, either through a specified Comparer or implementing IComparable&lt;<typeparamref name="T"/>&gt;</typeparam>
        </member>
        <member name="M:Robust.Shared.Utility.PriorityQueue`1.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Create a max-priority queue with default capacity of 10.
            </summary>
            <param name="comparer">Custom comparer to compare elements. If omitted - default will be used.</param>
        </member>
        <member name="M:Robust.Shared.Utility.PriorityQueue`1.#ctor(System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>
            Create a max-priority queue with provided capacity.
            </summary>
            <param name="capacity">Initial capacity</param>
            <param name="comparer">Custom comparer to compare elements. If omitted - default will be used.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws <see cref="T:System.ArgumentOutOfRangeException"/> when capacity is less than or equal to zero.</exception>
            <exception cref="T:System.ArgumentException">Throws <see cref="T:System.ArgumentException"/> when comparer is null and <typeparamref name="T"/> does not implement IComparable.</exception>
        </member>
        <member name="P:Robust.Shared.Utility.PriorityQueue`1.Capacity">
            <summary>
            Current queue capacity
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.PriorityQueue`1.Take">
            <summary>
            Removes and returns a max element from the priority queue.
            </summary>
            <returns>Max element in the collection</returns>
            <exception cref="T:System.InvalidOperationException">Throws <see cref="T:System.InvalidOperationException"/> when queue is empty.</exception>
        </member>
        <member name="M:Robust.Shared.Utility.PriorityQueue`1.Peek">
            <summary>
            Returns a max element from the priority queue without removing it.
            </summary>
            <returns>Max element in the collection</returns>
            <exception cref="T:System.InvalidOperationException">Throws <see cref="T:System.InvalidOperationException"/> when queue is empty.</exception>
        </member>
        <member name="M:Robust.Shared.Utility.PriorityQueue`1.RemoveAt(System.Int32,System.Int32)">
            <summary>
            Removes item at given index
            </summary>
            <param name="index">1-based index of the element to remove</param>
            <param name="shift">Shift allows to compensate and work with arrays where heap starts not from the element at position 1.
            Shift -1 allows to work with 0-based heap as if it was 1-based. But the main reason for this is the CopyTo method.</param>
        </member>
        <member name="M:Robust.Shared.Utility.PriorityQueue`1.GetItemIndex(`0)">
            <summary>
            Returns the real index of the first occurrence of the given item or -1.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.HeapMethods.Sink``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0},System.Int32)">
            <summary>
            Moves the item with given index "down" the heap while heap principles are not met.
            </summary>
            <typeparam name="T">Any comparable type</typeparam>
            <param name="heap">Array, containing the heap</param>
            <param name="i">1-based index of the element to sink</param>
            <param name="count">Number of items in the heap</param>
            <param name="comparer">Comparer to compare the items</param>
            <param name="shift">Shift allows to compensate and work with arrays where heap starts not from the element at position 1.
            Shift -1 allows to work with 0-based heap as if it was 1-based. But the main reason for this is the CopyTo method.
            </param>
        </member>
        <member name="M:Robust.Shared.Utility.HeapMethods.Sift``1(``0[],System.Int32,System.Collections.Generic.IComparer{``0},System.Int32)">
            <summary>
            Moves the item with given index "up" the heap while heap principles are not met.
            </summary>
            <typeparam name="T">Any comparable type</typeparam>
            <param name="heap">Array, containing the heap</param>
            <param name="i">1-based index of the element to sink</param>
            <param name="comparer">Comparer to compare the items</param>
            <param name="shift">Shift allows to compensate and work with arrays where heap starts not from the element at position 1.
            Value -1 allows to work with 0-based heap as if it was 1-based. But the main reason for this is the CopyTo method.
            </param>
        </member>
        <member name="M:Robust.Shared.Utility.HeapMethods.HeapSort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the heap in descending order.
            </summary>
            <typeparam name="T">Any comparable type</typeparam>
            <param name="heap">Array, containing the heap</param>
            <param name="startIndex">Index in the array, from which the heap structure begins</param>
            <param name="count">Number of items in the heap</param>
            <param name="comparer">Comparer to compare the items</param>
        </member>
        <member name="T:Robust.Shared.Utility.PrototypeFlags`1">
            <summary>
                Data structure for storing prototype IDs, and ensuring that all stored IDs resolve to valid prototypes.
            </summary>
            <typeparam name="T">The prototype variant.</typeparam>
        </member>
        <member name="M:Robust.Shared.Utility.PrototypeFlags`1.Add(System.String,Robust.Shared.Prototypes.IPrototypeManager)">
            <summary>
                Adds a prototype flag, but only if it's valid.
            </summary>
            <param name="flag">The prototype identifier.</param>
            <param name="prototypeManager">The prototype manager containing the prototype.</param>
            <returns>Whether the flag was added or not.</returns>
        </member>
        <member name="M:Robust.Shared.Utility.PrototypeFlags`1.Contains(System.String)">
            <summary>
                Checks whether a specific flag is contained here or not.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.PrototypeFlags`1.ContainsAll(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                Checks whether all specified flags are contained here or not.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.PrototypeFlags`1.ContainsAll(System.String[])">
            <summary>
                Checks whether all specified flags are contained here or not.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.PrototypeFlags`1.ContainsAny(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                Checks whether any of the specified flags are contained here or not.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.PrototypeFlags`1.ContainsAny(System.String[])">
            <summary>
                Checks whether any of the specified flags are contained here or not.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.PrototypeFlags`1.Remove(System.String)">
            <summary>
                Removes a flag, if present.
            </summary>
            <param name="flag">The flag to be removed.</param>
            <returns>Whether the prototype flag was successfully removed.</returns>
        </member>
        <member name="M:Robust.Shared.Utility.PrototypeFlags`1.Clear">
            <summary>
                Empties the collection of all prototype flags.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.IReadOnlyPrototypeFlags`1.GetPrototypes(Robust.Shared.Prototypes.IPrototypeManager)">
            <summary>
                Enumerates all prototype flags and returns their actual prototype instances.
            </summary>
            <param name="prototypeManager">The prototype manager where the prototypes are stored.</param>
            <exception cref="T:System.InvalidOperationException">Thrown if prototypes in the <see cref="T:Robust.Shared.Prototypes.IPrototypeManager"/>
                haven't been loaded yet.
            </exception>
            <exception cref="T:Robust.Shared.Prototypes.UnknownPrototypeException">Thrown if any of the prototype flags in this class does not
                correspond to a valid, known prototype in the <see cref="T:Robust.Shared.Prototypes.IPrototypeManager"/>.
            </exception>
            <returns>The prototype instances for all prototype flags in this object.</returns>
        </member>
        <member name="T:Robust.Shared.Utility.Ptr`1">
            <summary>
            Pointer-wrapper struct so pointers can be sanely stored in generics and records.
            </summary>
            <typeparam name="T">The actual type pointed to</typeparam>
        </member>
        <member name="M:Robust.Shared.Utility.QuadTree`1.#ctor(System.Numerics.Vector2,System.Int32,System.Boolean)">
             <summary>
            
             </summary>
             <param name="minLeafSizeF">The smallest SizeF a leaf will split into</param>
             <param name="maxObjectsPerLeaf">Maximum number of objects per leaf before it forces a split into sub quadrants</param>
             <param name="sort">Whether or not queries will return objects in the order in which they were added</param>
        </member>
        <member name="T:Robust.Shared.Utility.RefList`1">
            <summary>
                Supposedly a high-performance version of <see cref="T:System.Collections.Generic.List`1"/>,
                that allows fetching direct references to the underlying contents.
            </summary>
            <remarks>
                Due to this type's nature,
                keeping references to the contents of this list while mutating it is undefined behavior.
                Don't do it.
            </remarks>
            <typeparam name="T">The type of the contents of the list. This must be an unmanaged type.</typeparam>
        </member>
        <member name="M:Robust.Shared.Utility.RefList`1.AllocAdd">
            <summary>
                Allocate a new member in the list and return the reference to it for initialization.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Robust.Shared.Utility.RefList`1.Add(`0)">
            <summary>
                It is probably advisable to use <see cref="M:Robust.Shared.Utility.RefList`1.AllocAdd"/> instead for better performance.
            </summary>
        </member>
        <member name="T:Robust.Shared.Utility.RemQueue`1">
            <summary>
                Simple helper struct for "iterate collection and have a queue of things to remove when you're done",
                to avoid concurrent iteration/modification.
            </summary>
        </member>
        <member name="T:Robust.Shared.Utility.ResizableMemoryRegionMetrics">
            <summary>
            Implementation detail to store metrics for <see cref="T:Robust.Shared.Utility.ResizableMemoryRegion`1"/>.
            </summary>
        </member>
        <member name="T:Robust.Shared.Utility.ResizableMemoryRegion`1">
            <summary>
            An unmanaged region of memory that can be dynamically resized without requiring copying.
            </summary>
            <remarks>
            <para>
            The maximum size of the memory region must be specified in the constructor. This reserves virtual memory for later,
            but does not charge actual physical memory or commit charge and therefore costs nothing.
            </para>
            <para>
            The "real" allocated memory region can be expanded by calling <see cref="M:Robust.Shared.Utility.ResizableMemoryRegion`1.Expand(System.Int32)"/>.
            This will increase resource consumption and make more memory available for use.
            </para>
            <para>
            Allocated memory starts initialized to 0.
            </para>
            </remarks>
            <typeparam name="T">The type of elements stored in the memory region.</typeparam>
        </member>
        <member name="P:Robust.Shared.Utility.ResizableMemoryRegion`1.BaseAddress">
            <summary>
            The pointer to the start of the allocated memory region. Use with care!
            </summary>
        </member>
        <member name="P:Robust.Shared.Utility.ResizableMemoryRegion`1.MaxSize">
            <summary>
            The maximum amount of elements that can be stored in this memory region.
            </summary>
        </member>
        <member name="P:Robust.Shared.Utility.ResizableMemoryRegion`1.CurrentSize">
            <summary>
            The current space (in elements) commit that is directly accessible.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.ResizableMemoryRegion`1.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a new <see cref="T:Robust.Shared.Utility.ResizableMemoryRegion`1"/> with a certain maximum and initial size.
            </summary>
            <param name="maxElementSize">The maximum amount of elements ever stored in this memory region.</param>
            <param name="initialElementSize">
            The initial amount of elements that will be immediately accessible without using <see cref="M:Robust.Shared.Utility.ResizableMemoryRegion`1.Expand(System.Int32)"/>.
            </param>
            <exception cref="T:System.InvalidOperationException">
            Thrown if the memory region is already initialized.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown if <paramref name="maxElementSize"/> is zero
            or <paramref name="initialElementSize"/> is greater than <paramref name="maxElementSize"/>.
            </exception>
        </member>
        <member name="M:Robust.Shared.Utility.ResizableMemoryRegion`1.Expand(System.Int32)">
            <summary>
            Expand the committed space for this <see cref="T:Robust.Shared.Utility.ResizableMemoryRegion`1"/> to have space for at least
            <paramref name="newElementSize"/> elements.
            </summary>
            <remarks>
            This operation happens without copying and existing references to the memory region remain valid.
            </remarks>
            <param name="newElementSize">The minimum amount of elements that should fit in the memory region.</param>
            <exception cref="T:System.ArgumentException">
            Thrown if <paramref name="newElementSize"/> is greater than <see cref="P:Robust.Shared.Utility.ResizableMemoryRegion`1.MaxSize"/>.
            </exception>
        </member>
        <member name="M:Robust.Shared.Utility.ResizableMemoryRegion`1.Shrink(System.Int32)">
            <summary>
            Shrink this <see cref="T:Robust.Shared.Utility.ResizableMemoryRegion`1"/> to reduce the amount of memory used.
            </summary>
            <remarks>
            Existing references inside the shrank-away region of memory become undefined to read or write from,
            and can cause access violations.
            </remarks>
            <param name="newElementSize">
            The new size of the committed region of memory.
            </param>
            <exception cref="T:System.ArgumentException">
            Thrown if trying to shrink to a size larger than the current size, or when trying to shrink to a negative size.
            </exception>
        </member>
        <member name="M:Robust.Shared.Utility.ResizableMemoryRegion`1.GetSpan">
            <summary>
            Get a <see cref="T:System.Span`1"/> over the committed region of memory.
            </summary>
            <returns>A <see cref="T:System.Span`1"/> over the committed region of memory.</returns>
        </member>
        <member name="M:Robust.Shared.Utility.ResizableMemoryRegion`1.GetSpan``1">
            <summary>
            Get a <see cref="T:System.Span`1"/> over the committed region of memory, cast to a different type.
            </summary>
            <remarks>
            This is equivalent to using <see cref="M:System.Runtime.InteropServices.MemoryMarshal.Cast``2(System.Span{``0})"/> on the result of <see cref="M:Robust.Shared.Utility.ResizableMemoryRegion`1.GetSpan"/>.
            </remarks>
            <typeparam name="TCast">The type to cast the memory region to.</typeparam>
            <returns>A <see cref="T:System.Span`1"/> over the committed region of memory.</returns>
        </member>
        <member name="M:Robust.Shared.Utility.ResizableMemoryRegion`1.GetRef(System.Int32)">
            <summary>
            Get a mutable reference to a single element of the memory region.
            </summary>
            <param name="index">The index of the element desired.</param>
            <exception cref="T:System.IndexOutOfRangeException">
            Thrown if <paramref name="index"/> is greater or equal to <see cref="P:Robust.Shared.Utility.ResizableMemoryRegion`1.CurrentSize"/>.
            </exception>
            <returns>A mutable reference to the element.</returns>
        </member>
        <member name="M:Robust.Shared.Utility.ResizableMemoryRegion`1.GetRef``1(System.Int32)">
            <summary>
            Get a mutable reference to a single element of the memory region, cast to a different type.
            </summary>
            <remarks>
            This is equivalent to using <see cref="M:System.Runtime.CompilerServices.Unsafe.As``2(``0@)"/> on the result of <see cref="M:Robust.Shared.Utility.ResizableMemoryRegion`1.GetSpan"/>.
            </remarks>
            <param name="index">The index of the element desired.</param>
            <exception cref="T:System.IndexOutOfRangeException">
            Thrown if <paramref name="index"/> is greater or equal to <see cref="P:Robust.Shared.Utility.ResizableMemoryRegion`1.CurrentSize"/>.
            </exception>
            <returns>A mutable reference to the element.</returns>
        </member>
        <member name="M:Robust.Shared.Utility.ResizableMemoryRegion`1.Clear">
            <summary>
            Clear the contents of the memory stored in this <see cref="T:Robust.Shared.Utility.ResizableMemoryRegion`1"/> back to zero.
            </summary>
            <remarks>
            This does not change the <see cref="P:Robust.Shared.Utility.ResizableMemoryRegion`1.CurrentSize"/>.
            </remarks>
        </member>
        <member name="M:Robust.Shared.Utility.ResizableMemoryRegion`1.Dispose">
            <summary>
            Release the backing memory for this <see cref="T:Robust.Shared.Utility.ResizableMemoryRegion`1"/>.
            </summary>
            <remarks>
            Existing references to memory of the memory region become invalid and should no longer be used.
            </remarks>
        </member>
        <member name="T:Robust.Shared.Utility.ResPath">
            <summary>
                Provides object-oriented path manipulation for resource paths.
                ResPath are immutable, and separator is always `/`
            </summary>
        </member>
        <member name="F:Robust.Shared.Utility.ResPath.SystemSeparator">
            <summary>
                The separator for the file system of the system we are compiling to.
                Backslash on Windows, forward slash on sane systems.
            </summary>
        </member>
        <member name="F:Robust.Shared.Utility.ResPath.Separator">
            <summary>
            Normalized separator character. Chosen because <c>/</c> is illegal path
            character on Linux and Windows.
            </summary>
        </member>
        <member name="F:Robust.Shared.Utility.ResPath.SeparatorStr">
            <summary>
            Normalized separator string. Chosen because <c>/</c> is illegal path
            character on Linux and Windows.
            </summary>
        </member>
        <member name="F:Robust.Shared.Utility.ResPath.Self">
            <summary>
                "." as a static.
            </summary>
        </member>
        <member name="F:Robust.Shared.Utility.ResPath.Root">
            <summary>
                "/" (root) as a static.
            </summary>
        </member>
        <member name="F:Robust.Shared.Utility.ResPath.Empty">
            <summary>
                "" (empty) as a static.
            </summary>
        </member>
        <member name="F:Robust.Shared.Utility.ResPath.CanonPath">
            <summary>
                Internal system independent path. It uses `/` internally as
                separator and will translate to it on creation.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.ResPath.#ctor">
            <summary>
            Needed for serv3
            </summary>
        </member>
        <member name="P:Robust.Shared.Utility.ResPath.IsSelf">
            <summary>
                Returns true if the path is equal to "."
            </summary>
        </member>
        <member name="P:Robust.Shared.Utility.ResPath.Directory">
            <summary>
                Returns the parent directory that this file resides in
                as a <see cref="T:Robust.Shared.Utility.ResPath"/>.
                If path points to folder, it will return parent directory
            </summary>
            <example>
            <code>
                // Directory property of a directory resourcePath.
                Assert.AreEqual("/foo", new ResPath("/foo/bar").Directory.ToString());
                // Directory of a file resourcePath.
                Assert.AreEqual("/foo", new ResPath("/foo/x.txt").Directory.ToString());
            </code>
            </example>
        </member>
        <member name="P:Robust.Shared.Utility.ResPath.Extension">
            <summary>
                Returns the file extension of <see cref="T:Robust.Shared.Utility.ResPath"/>, if any as string.
                Returns "" if there is no file extension. (Hidden) Files starting
                with period (".") are counted as files with no extension.
                The extension returned does NOT include a period.
            </summary>
            <example>
            <code>
                // file with normal extension
                var picPath = new ResPath("/a/b/c.png");
                Assert.AreEqual("png", picPath.Extension);
                // hidden file starting with `.`
                var gitignore = new ResPath("/a/b/.gitignore");
                Assert.AreEqual("", gitignore.Extension);
            </code>
            </example>
        </member>
        <member name="P:Robust.Shared.Utility.ResPath.FilenameWithoutExtension">
            <summary>
                Returns the file name part of a <see cref="T:Robust.Shared.Utility.ResPath"/>, as string.
                In essence reverse of <see cref="P:Robust.Shared.Utility.ResPath.Extension"/>.
                If last segment divided of a path (e.g. <c>/foo/bar/baz.png</c>) divided by separator (e.g <c>/</c>)
                is considered a filename (e.g. <c>baz.png</c>). In that segment part before period is
                considered filename (e.g. <c>baz</c>, unless file start with period, then whole segment
                is filename without extension.
            </summary>
            <example>
            <code>
                // file with normal extension
                var picPath = new ResPath("/a/b/foo.png");
                Assert.AreEqual("foo", picPath.FilenameWithoutExtension());
                // hidden file starting with `.`
                var gitignore = new ResPath("/a/b/.gitignore");
                Assert.AreEqual(".gitignore", gitignore.FilenameWithoutExtension());
            </code>
            </example>
        </member>
        <member name="P:Robust.Shared.Utility.ResPath.Filename">
            <summary>
                Returns the file name (folders are files) for given path,
                or "." if path is empty.
                If last segment divided of a path (e.g. <c>/foo/bar/baz.png</c>) divided by separator (e.g <c>/</c>)
                is considered a filename (e.g. <c>baz.png</c>).
            </summary>
            <example>
            <code>
                // file
                Assert.AreEqual("c.png", new ResPath("/a/b/c.png").Filename);
                // folder
                Assert.AreEqual("foo", new ResPath("/foo").Filename);
                // empty
                Assert.AreEqual(".", new ResPath("").Filename);
            </code>
            </example>
        </member>
        <member name="M:Robust.Shared.Utility.ResPath.ToString">
            <summary>
                Converts this element to String
            </summary>
            <returns> System independent representation of path</returns>
        </member>
        <member name="M:Robust.Shared.Utility.ResPath.Equals(Robust.Shared.Utility.ResPath)">
            <inheritdoc/>
        </member>
        <member name="M:Robust.Shared.Utility.ResPath.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Robust.Shared.Utility.ResPath.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Robust.Shared.Utility.ResPath.op_Division(Robust.Shared.Utility.ResPath,Robust.Shared.Utility.ResPath)">
            <summary>
                Joins two resource paths together, with separator in between.
                If the second path is absolute (i.e. rooted), the first path is completely ignored.
                <seealso cref="P:Robust.Shared.Utility.ResPath.IsRooted"/>
            </summary>
            <exception cref="T:System.ArgumentException">Thrown if the separators of the two paths do not match.</exception>
        </member>
        <member name="M:Robust.Shared.Utility.ResPath.op_Division(Robust.Shared.Utility.ResPath,System.String)">
            <summary>
                Joins resource and string path together, by converting string to <see cref="T:Robust.Shared.Utility.ResPath"/>
                If the second path is absolute (i.e. rooted), the first path is completely ignored.
                <seealso cref="P:Robust.Shared.Utility.ResPath.IsRooted"/>
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.ResPath.WithExtension(System.String)">
            <summary>
                Return a copy of this resource path with the file extension changed.
            </summary>
            <param name="newExtension">
                The new file extension.
            </param>
            <exception cref="T:System.ArgumentException">
                Thrown if <paramref name="newExtension"/> is null, empty,
                contains <c>/</c> or is equal to <c>.</c>
            </exception>
        </member>
        <member name="M:Robust.Shared.Utility.ResPath.WithName(System.String)">
            <summary>
                Return a copy of this resource path with the file name changed.
            </summary>
            <param name="name">
                The new file name.
            </param>
            <exception cref="T:System.ArgumentException">
                Thrown if <paramref name="name"/> is null, empty,
                contains <c>/</c> or is equal to <c>.</c>
            </exception>
        </member>
        <member name="P:Robust.Shared.Utility.ResPath.IsRooted">
            <summary>
                Returns true if the path is rooted/absolute (starts with the separator).
            </summary>
            <seealso cref="P:Robust.Shared.Utility.ResPath.IsRelative" />
            <seealso cref="M:Robust.Shared.Utility.ResPath.ToRootedPath"/>
        </member>
        <member name="P:Robust.Shared.Utility.ResPath.IsRelative">
            <summary>
                Returns true if the path is not rooted.
            </summary>
            <seealso cref="P:Robust.Shared.Utility.ResPath.IsRooted" />
            <seealso cref="M:Robust.Shared.Utility.ResPath.ToRelativePath"/>
        </member>
        <member name="M:Robust.Shared.Utility.ResPath.RelativeTo(Robust.Shared.Utility.ResPath)">
            <summary>
                Returns the path of how this instance is "relative" to <paramref name="basePath" />,
                such that <c>basePath/result == this</c>.
            </summary>
            <example>
                <code>
                var path1 = new ResPath("/a/b/c");
                var path2 = new ResPath("/a");
                Console.WriteLine(path1.RelativeTo(path2)); // prints "b/c".
                </code>
            </example>
            <exception cref="T:System.ArgumentException">Thrown if we are not relative to the base path.</exception>
        </member>
        <member name="M:Robust.Shared.Utility.ResPath.TryRelativeTo(Robust.Shared.Utility.ResPath,System.Nullable{Robust.Shared.Utility.ResPath}@)">
            <summary>
                Try pattern version of <see cref="M:Robust.Shared.Utility.ResPath.RelativeTo(Robust.Shared.Utility.ResPath)" />.
            </summary>
            <param name="basePath">The base path which we can be made relative to.</param>
            <param name="relative">The path of how we are relative to <paramref name="basePath" />, if at all.</param>
            <returns>True if we are relative to <paramref name="basePath" />, false otherwise.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the separators are not the same.</exception>
        </member>
        <member name="M:Robust.Shared.Utility.ResPath.ToRootedPath">
            <summary>
                Turns the path into a rooted path by prepending it with the separator.
                Does nothing if the path is already rooted.
            </summary>
            <seealso cref="P:Robust.Shared.Utility.ResPath.IsRooted" />
            <seealso cref="M:Robust.Shared.Utility.ResPath.ToRelativePath" />
        </member>
        <member name="M:Robust.Shared.Utility.ResPath.ToRelativePath">
            <summary>
                Turns the path into a relative path by removing the root separator, if any.
                Does nothing if the path is already relative.
            </summary>
            <seealso cref="P:Robust.Shared.Utility.ResPath.IsRelative" />
            <seealso cref="M:Robust.Shared.Utility.ResPath.ToRootedPath" />
        </member>
        <member name="M:Robust.Shared.Utility.ResPath.ToRelativeSystemPath">
            <summary>
                Turns the path into a relative path with system-specific separator.
                For usage in disk I/O.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.ResPath.FromRelativeSystemPath(System.String,System.Char)">
            <summary>
                Converts a system path into a resource path.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.ResPath.ChangeSeparator(System.String)">
            <summary>
                Turns the path into a relative path with system-specific separator.
                For usage in disk I/O.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.ResPathUtil.Clean(Robust.Shared.Utility.ResPath)">
            <summary>
                Returns cleaned version of the resource path, removing <c>..</c>.
            </summary>
            <remarks>
                If <c>..</c> appears at the base of a path, it is left alone. If it appears at root level (like <c>/..</c>) it is removed entirely.
            </remarks>
        </member>
        <member name="M:Robust.Shared.Utility.ResPathUtil.GetCommonSegments(Robust.Shared.Utility.ResPath,Robust.Shared.Utility.ResPath)">
            <summary>
            Gets the segments in common with 2 paths.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.ResPathUtil.GetNextSegment(Robust.Shared.Utility.ResPath,Robust.Shared.Utility.ResPath)">
            <summary>
            Gets the next segment after where the common segments end.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.ResPathUtil.EnumerateSegments(Robust.Shared.Utility.ResPath)">
            <summary>
              Enumerates segments skipping over first element in
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="T:Robust.Shared.Utility.SequenceMemoryStream">
            <summary>
            Stream that effectively writes to a <see cref="T:System.Buffers.ReadOnlySequence`1"/> of bytes.
            Less allocations over <see cref="T:System.IO.MemoryStream"/> in some scenarios.
            </summary>
        </member>
        <member name="T:Robust.Shared.Utility.SpriteSpecifier">
            <summary>
                Is a reference to EITHER an RSI + RSI State, OR a bare texture path.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.SpriteSpecifier.Rsi.InternalCopy(Robust.Shared.Utility.SpriteSpecifier.Rsi@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Utility.SpriteSpecifier.Rsi.Copy(Robust.Shared.Utility.SpriteSpecifier.Rsi@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Utility.SpriteSpecifier.Rsi.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.Utility.SpriteSpecifier.Rsi.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Shared.Utility.StreamExt">
            <summary>
                Extension methods for working with streams.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.StreamExt.CopyToArray(System.IO.Stream)">
            <summary>
                Copies any stream into a byte array.
            </summary>
            <param name="stream">The stream to copy.</param>
            <returns>The byte array.</returns>
        </member>
        <member name="M:Robust.Shared.Utility.StreamExt.CopyToPinnedArray(System.IO.Stream)">
            <summary>
            <see cref="M:Robust.Shared.Utility.StreamExt.CopyToArray(System.IO.Stream)"/> but to the Pinned Object Heap.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.StreamExt.ReadExact(System.IO.Stream,System.Int32)">
            <exception cref="T:System.IO.EndOfStreamException">
            Thrown if not exactly <paramref name="amount"/> bytes could be read.
            </exception>
        </member>
        <member name="M:Robust.Shared.Utility.StreamExt.ReadExact(System.IO.Stream,System.Span{System.Byte})">
            <exception cref="T:System.IO.EndOfStreamException">
            Thrown if not exactly <paramref name="buffer.Length.Length"/> bytes could be read.
            </exception>
        </member>
        <member name="M:Robust.Shared.Utility.StreamExt.AsSpan(System.IO.MemoryStream)">
            <summary>
            Gets the span over the currently filled region of the memory stream, based on its length.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.StreamExt.AsMemory(System.IO.MemoryStream)">
            <summary>
            Gets the memory over the currently filled region of the memory stream, based on its length.
            </summary>
        </member>
        <member name="T:Robust.Shared.Utility.SystemInformation">
            <summary>
            Helper class to get additional system information.
            </summary>
        </member>
        <member name="T:Robust.Shared.Utility.TextParser">
            <summary>
                Helper class for parsing text.
            </summary>
        </member>
        <member name="P:Robust.Shared.Utility.TextParser.CurrentIndex">
            <summary>
                Index of the next character to be read.
            </summary>
        </member>
        <member name="T:Robust.Shared.Utility.Rope">
            <summary>
            A binary tree data structure for efficient storage of large mutable text.
            </summary>
            <remarks>
            <para>
            <see href="https://en.wikipedia.org/wiki/Rope_(data_structure)">Read the Wikipedia article, nerd</see>
            Also read the original paper, it's useful too.
            </para>
            <para>
            Like strings, ropes are immutable and all "mutating" operations return new copies.
            </para>
            <para>
            All indexing functions use <see langword="long"/> indices.
            While individual rope leaves cannot be larger than an <see langword="int"/>, ropes with many leaves may exceed that.
            </para>
            </remarks>
        </member>
        <member name="M:Robust.Shared.Utility.Rope.CalcTotalLength(Robust.Shared.Utility.Rope.Node)">
            <summary>
            Calculate the total text length of the rope given.
            </summary>
            <remarks>
            For a balanced tree, this is O(log n).
            </remarks>
        </member>
        <member name="M:Robust.Shared.Utility.Rope.CollectLeaves(Robust.Shared.Utility.Rope.Node)">
            <summary>
            Enumerate all leaves in the rope from left to right.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.Rope.CollectLeavesReverse(Robust.Shared.Utility.Rope.Node)">
            <summary>
            Enumerate all leaves in the rope from right to left.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.Rope.EnumerateRunes(Robust.Shared.Utility.Rope.Node)">
            <summary>
            Enumerate all text runes in the rope from left to right.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.Rope.EnumerateRunes(Robust.Shared.Utility.Rope.Node,System.Int64)">
            <summary>
            Enumerate all text runes in the rope from left to right, starting at the specified position.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.Rope.EnumerateRunesReverse(Robust.Shared.Utility.Rope.Node)">
            <summary>
            Enumerate all the runes in the rope, from right to left.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.Rope.EnumerateRunesReverse(Robust.Shared.Utility.Rope.Node,System.Int64)">
            <summary>
            Enumerate all text runes in the rope from right to left, starting at the specified position.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.Rope.IsBalanced(Robust.Shared.Utility.Rope.Node)">
            <summary>
            Check whether the given rope is sufficiently balanced to avoid bad performance.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.Rope.Rebalance(Robust.Shared.Utility.Rope.Node)">
            <summary>
            Ensure the rope is balanced to ensure decent performance on various operations.
            </summary>
            <remarks>
            If the rope is already balanced, this method does nothing.
            </remarks>
        </member>
        <member name="M:Robust.Shared.Utility.Rope.Index(Robust.Shared.Utility.Rope.Node,System.Int64)">
            <summary>
            Get a <see langword="char" /> at the specified index in the rope.
            </summary>
            <remarks>
            For a balanced tree, this is O(log n).
            </remarks>
        </member>
        <member name="M:Robust.Shared.Utility.Rope.Insert(Robust.Shared.Utility.Rope.Node,System.Int64,System.String)">
            <summary>
            Create a new rope with text spliced in at an index.
            </summary>
            <param name="rope">The rope to splice text into.</param>
            <param name="index">The position the inserted text should start at.</param>
            <param name="value">The text to insert.</param>
            <returns>The new rope containing the spliced data.</returns>
        </member>
        <member name="M:Robust.Shared.Utility.Rope.Concat(Robust.Shared.Utility.Rope.Node,Robust.Shared.Utility.Rope.Node)">
            <summary>
            Create a new rope concatenating two given ropes.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.Rope.Concat(Robust.Shared.Utility.Rope.Node,System.String)">
            <summary>
            Create a new rope concatenating a rope and a string.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.Rope.Concat(System.String,Robust.Shared.Utility.Rope.Node)">
            <summary>
            Create a new rope concatenating a string with a rope.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.Rope.Split(Robust.Shared.Utility.Rope.Node,System.Int64)">
            <summary>
            Return two new ropes split from the given rope at a specified index.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.Rope.Delete(Robust.Shared.Utility.Rope.Node,System.Int64,System.Int64)">
            <summary>
            Create a new rope with a slice of text removed.
            </summary>
            <param name="rope">The rope to copy.</param>
            <param name="start">The position to start removing chars at.</param>
            <param name="length">How many chars to remove.</param>
        </member>
        <member name="M:Robust.Shared.Utility.Rope.ReplaceSubstring(Robust.Shared.Utility.Rope.Node,System.Int64,System.Int64,System.String)">
            <summary>
            Create a new rope with a given slice of text replaced with a new string.
            </summary>
            <param name="rope">The rope to copy.</param>
            <param name="start">The position to start removing characters at, and insert the new text at.</param>
            <param name="length">How many characters from the original rope to remove.</param>
            <param name="text">The new text to insert at the start position.</param>
        </member>
        <member name="M:Robust.Shared.Utility.Rope.TryGetRuneAt(Robust.Shared.Utility.Rope.Node,System.Int64,System.Text.Rune@)">
            <summary>
            Try to fetch a <see cref="T:System.Text.Rune"/> at a certain position in the rune.
            Fails if the given position is inside a surrogate pair.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.Rope.Collapse(Robust.Shared.Utility.Rope.Node)">
            <summary>
            Collapse the rope into a single string instance.
            </summary>
            <exception cref="T:System.OverflowException">The given rope is too large to fit in a single string.</exception>
        </member>
        <member name="M:Robust.Shared.Utility.Rope.CollapseSubstring(Robust.Shared.Utility.Rope.Node,System.Range)">
            <summary>
            Collapse a substring of a rope into a single string instance.
            </summary>
            <param name="rope">The rope to collapse part of.</param>
            <param name="range">The range of the substring to collapse.</param>
            <exception cref="T:System.OverflowException">The given rope is too large to fit in a single string.</exception>
        </member>
        <member name="M:Robust.Shared.Utility.Rope.RuneShiftLeft(System.Int64,Robust.Shared.Utility.Rope.Node)">
            <summary>
            Offset a cursor position in a rope to the left, skipping over the middle of surrogate pairs.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.Rope.RuneShiftRight(System.Int64,Robust.Shared.Utility.Rope.Node)">
            <summary>
            Offset a cursor position in a rope to the right, skipping over the middle of surrogate pairs.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.Rope.IsNullOrEmpty(Robust.Shared.Utility.Rope.Node)">
            <summary>
            Returns true if the given rope is either null or empty (length 0).
            </summary>
        </member>
        <member name="T:Robust.Shared.Utility.Rope.Node">
            <summary>
            A nope in a rope. This is either a <see cref="T:Robust.Shared.Utility.Rope.Leaf"/> or a <see cref="T:Robust.Shared.Utility.Rope.Branch"/>.
            </summary>
        </member>
        <member name="P:Robust.Shared.Utility.Rope.Node.Depth">
            <summary>
            The depth of the deepest leaf in this node tree. A leaf has depth 0, and a branch one above 1, etc...
            </summary>
        </member>
        <member name="T:Robust.Shared.Utility.Rope.Leaf">
            <summary>
            A leaf contains a string of text.
            </summary>
        </member>
        <member name="T:Robust.Shared.Utility.Rope.Branch">
            <summary>
            A branch contains other nodes to the left and right.
            </summary>
        </member>
        <member name="T:Robust.Shared.Utility.TimeSpanExt">
            <summary>
            Helper functions for <see cref="T:System.TimeSpan"/>
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.TimeSpanExt.Mul(System.TimeSpan,System.Int64)">
            <summary>
            Multiply a <see cref="T:System.TimeSpan"/> with an integer factor.
            </summary>
            <remarks>
            <see cref="T:System.TimeSpan"/> only has a multiplication operator for doubles,
            so this is necessary to avoid round-tripping through floating point calculations.
            </remarks>
        </member>
        <member name="T:Robust.Shared.Utility.TypeAbbreviation">
            <summary>
                Utility class for abbreviating common type names.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.TypeAbbreviation.Abbreviate(System.Type)">
            <summary>
                Attempt to produce a shorter version of a type's full representation.
            </summary>
            <param name="type">The type to abbreviate.</param>
            <returns>A shorter representation of the passed type than given by `ToString()`.</returns>
        </member>
        <member name="M:Robust.Shared.Utility.TypeAbbreviation.Abbreviate(System.String)">
             <summary>
                 Attempt to abbreviate a full name into something shorter.
            
                 For types, use <see cref="M:Robust.Shared.Utility.TypeAbbreviation.Abbreviate(System.Type)"/> instead, since it
                 correctly handles the more complex type logic.
             </summary>
             <param name="name">The name to abbreviate.</param>
             <returns>A shorter, but still unique, version of the passed named.</returns>
        </member>
        <member name="M:Robust.Shared.Utility.TypeHelpers.GetAllFields(System.Type)">
            <summary>
                Returns absolutely all fields, privates, readonlies, and ones from parents.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.TypeHelpers.GetAllProperties(System.Type)">
            <summary>
                Returns absolutely all instance properties on a type. Inherited and private included.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.TypeHelpers.IsBasePropertyDefinition(System.Reflection.PropertyInfo)">
            <summary>
                Checks whether a property is the "base" definition.
                So basically it returns false for overrides.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.TypeHelpers.GetAllNestedTypes(System.Type)">
            <summary>
                Returns ALL nested types of the specified type, including private types of its parent.
            </summary>
        </member>
        <member name="T:Robust.Shared.Utility.UniqueIndex`2">
            <summary>
            An immutable dictionary of mutable and immutable sets for use as an index of unique values related to another collection.
            Imitates the behavior of a read-focused index in a RDBMS.
            </summary>
            <remarks>
            Use when the index's keys don't change that rapidly or when fast lookup is preferred over creation time.
            It is not intended to explicitly construct this index before use.
            Do not refer to a <see cref="T:Robust.Shared.Utility.UniqueIndex`2"/> by it's interface.
            See <see cref="T:Robust.Shared.Utility.IUniqueIndex`2"/> for details.
            </remarks>
            <typeparam name="TKey">The type of key.</typeparam>
            <typeparam name="TValue">The type of value.</typeparam>
            <seealso cref="T:Robust.Shared.Utility.UniqueIndexExtensions"/>
            <seealso cref="T:Robust.Shared.Utility.IUniqueIndex`2" />
        </member>
        <member name="P:Robust.Shared.Utility.UniqueIndex`2.KeyCount">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Utility.UniqueIndex`2.Add(`0,`1)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Utility.UniqueIndex`2.AddRange(`0,System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Utility.UniqueIndex`2.Remove(`0)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Utility.UniqueIndex`2.Remove(`0,`1)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Utility.UniqueIndex`2.RemoveRange(`0,System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Utility.UniqueIndex`2.Replace(`0,`1,`1)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Utility.UniqueIndex`2.Touch(`0)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Utility.UniqueIndex`2.Initialize(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Utility.UniqueIndex`2.Initialize(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.HashSet{`1}}})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Utility.UniqueIndex`2.GetEnumerator">
            <inheritdoc cref="T:System.Collections.Generic.IEnumerable`1"/>
        </member>
        <member name="T:Robust.Shared.Utility.UniqueIndexExtensions">
            <summary>
            Extension methods for <see cref="T:Robust.Shared.Utility.UniqueIndex`2"/>.
            </summary>
        </member>
        <member name="M:Robust.Shared.Utility.UniqueIndexExtensions.Clear``2(Robust.Shared.Utility.UniqueIndex{``0,``1}@)">
            <summary>
            Completely resets a <see cref="T:Robust.Shared.Utility.UniqueIndex`2"/>.
            </summary>
            <param name="index">A given index.</param>
            <typeparam name="TKey">The type of key.</typeparam>
            <typeparam name="TValue">The type of value.</typeparam>
            <seealso cref="T:Robust.Shared.Utility.UniqueIndex`2"/>
        </member>
        <member name="T:Robust.Shared.Utility.UniqueIndexHkm`2">
            <summary>
            A mutable dictionary of mutable and immutable sets for use as an index of unique values related to another collection.
            Imitates the behavior of a write-focused index in a RDBMS.
            </summary>
            <remarks>
            Use when the index's keys change more rapidly or when insertion and removal of keys is preferred over read time.
            It is intended to explicitly construct this index before use.
            Do not refer to a <see cref="T:Robust.Shared.Utility.UniqueIndexHkm`2"/> by its interface.
            See <see cref="T:Robust.Shared.Utility.IUniqueIndex`2"/> for details.
            </remarks>
            <typeparam name="TKey">The type of key.</typeparam>
            <typeparam name="TValue">The type of value.</typeparam>
            <seealso cref="T:Robust.Shared.Utility.UniqueIndexExtensions"/>
            <seealso cref="T:Robust.Shared.Utility.IUniqueIndex`2" />
        </member>
        <member name="P:Robust.Shared.Utility.UniqueIndexHkm`2.KeyCount">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Utility.UniqueIndexHkm`2.Add(`0,`1)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Utility.UniqueIndexHkm`2.AddRange(`0,System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Utility.UniqueIndexHkm`2.Remove(`0)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Utility.UniqueIndexHkm`2.Remove(`0,`1)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Utility.UniqueIndexHkm`2.RemoveRange(`0,System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Utility.UniqueIndexHkm`2.Replace(`0,`1,`1)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Utility.UniqueIndexHkm`2.Touch(`0)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Utility.UniqueIndexHkm`2.Initialize(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Utility.UniqueIndexHkm`2.Initialize(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.HashSet{`1}}})">
            <inheritdoc />
        </member>
        <member name="P:Robust.Shared.Utility.UniqueIndexHkm`2.Item(`0)">
            <inheritdoc />
        </member>
        <member name="M:Robust.Shared.Utility.UniqueIndexHkm`2.GetEnumerator">
            <inheritdoc cref="T:System.Collections.Generic.IEnumerable`1"/>
        </member>
        <member name="M:Robust.Shared.Utility.YamlHelpers.GetNode``1(YamlDotNet.RepresentationModel.YamlMappingNode,System.String)">
            <summary>
            Get the node corresponding to a scalar node with value <paramref name="key" /> inside <paramref name="mapping" />,
            attempting to cast it to <typeparamref name="T" />.
            </summary>
            <param name="mapping">The mapping to retrieve the node from.</param>
            <param name="key">The value of the scalar node that will be looked up.</param>
            <returns>The corresponding node casted to <typeparamref name="T" />.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">
            Thrown if <paramref name="mapping" /> does not contain a scalar with value <paramref name="key" />.
            </exception>
            <exception cref="T:System.InvalidCastException">
            Thrown if the node could be found, but could not be cast to <typeparamref name="T" />.
            </exception>
            <seealso cref="M:Robust.Shared.Utility.YamlHelpers.GetNode(YamlDotNet.RepresentationModel.YamlMappingNode,System.String)" />
            <seealso cref="M:Robust.Shared.Utility.YamlHelpers.TryGetNode``1(YamlDotNet.RepresentationModel.YamlMappingNode,System.String,``0@)" />
        </member>
        <member name="M:Robust.Shared.Utility.YamlHelpers.GetNode(YamlDotNet.RepresentationModel.YamlMappingNode,System.String)">
            <summary>
            Same as <see cref="M:Robust.Shared.Utility.YamlHelpers.GetNode``1(YamlDotNet.RepresentationModel.YamlMappingNode,System.String)" />, but has <c>T</c> at <c>YamlNode</c>.
            </summary>
            <param name="mapping">The mapping to retrieve the node from.</param>
            <param name="key">The value of the scalar node that will be looked up.</param>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">
            Thrown if <paramref name="mapping" /> does not contain a scalar with value <paramref name="key" />.
            </exception>
            <returns>The node found.</returns>
        </member>
        <member name="M:Robust.Shared.Utility.YamlHelpers.TryGetNode``1(YamlDotNet.RepresentationModel.YamlMappingNode,System.String,``0@)">
            <summary>
            Attempts to fetch a node like <see cref="M:Robust.Shared.Utility.YamlHelpers.GetNode``1(YamlDotNet.RepresentationModel.YamlMappingNode,System.String)" />,
            but does not throw a <c>KeyNotFoundException</c> if the node doesn't exist.
            Instead it returns whether the node was successfully found.
            </summary>
            <param name="mapping">The mapping to retrieve the node from.</param>
            <param name="key">The value of the scalar node that will be looked up.</param>
            <param name="returnNode">The node casted to <typeparamref name="T" />, <c>null</c> if the node could not be found.</param>
            <returns>True if the value could be found, false otherwise.</returns>
            <exception cref="T:System.InvalidCastException">
            Thrown if the node could be found, but was the wrong type.
            This is intentional, as this most of the time means user error in the prototype definition.
            </exception>
        </member>
        <member name="M:Robust.Shared.Utility.YamlHelpers.TryGetNode(YamlDotNet.RepresentationModel.YamlMappingNode,System.String,YamlDotNet.RepresentationModel.YamlNode@)">
            <summary>
            Attempts to fetch a node like <see cref="M:Robust.Shared.Utility.YamlHelpers.GetNode(YamlDotNet.RepresentationModel.YamlMappingNode,System.String)" />,
            but does not throw a <c>KeyNotFoundException</c> if the node doesn't exist.
            Instead it returns whether the node was successfully found.
            </summary>
            <param name="mapping">The mapping to retrieve the node from.</param>
            <param name="key">The value of the scalar node that will be looked up.</param>
            <param name="returnNode">The node found, <c>null</c> if it could not be found.</param>
            <returns>True if the value could be found, false otherwise.</returns>
        </member>
        <member name="M:Robust.Shared.Utility.YamlHelpers.YamlMappingToDict(YamlDotNet.RepresentationModel.YamlMappingNode)">
            <summary>
            Copies a <see cref="T:YamlDotNet.RepresentationModel.YamlMappingNode" /> to a dictionary by using scalar values as keys for the dictionary.
            </summary>
            <param name="mapping">The mapping to copy from.</param>
            <returns>The dictionary.</returns>
        </member>
        <member name="M:Robust.Shared.ViewVariables.IViewVariablesManager.RegisterDomain(System.String,Robust.Shared.ViewVariables.DomainResolveObject,Robust.Shared.ViewVariables.DomainListPaths)">
             <summary>
                 Allows you to register the handlers for a domain.
                 Domains are the top-level segments of a VV path.
                 They provide ViewVariables with access to any number of objects.
                 A proper domain should only handle the next segment of the path.
            
                 <code>/entity/12345</code>
            
                 In the example above, "entity" would be a registered domain
                 and "12345" would be an object (entity UID) that is resolved by it.
            
             </summary>
             <param name="domain">The name of the domain to register.</param>
             <param name="resolveObject">The handler for resolving paths.</param>
             <param name="list">The handler for listing objects under the domain.</param>
             <seealso cref="M:Robust.Shared.ViewVariables.IViewVariablesManager.UnregisterDomain(System.String)"/>
        </member>
        <member name="M:Robust.Shared.ViewVariables.IViewVariablesManager.UnregisterDomain(System.String)">
            <summary>
                Unregisters the handlers for a given domain.
            </summary>
            <param name="domain">The name of the domain to unregister.</param>
            <returns>Whether the domain existed and was able to be unregistered or not.</returns>
            <seealso cref="M:Robust.Shared.ViewVariables.IViewVariablesManager.RegisterDomain(System.String,Robust.Shared.ViewVariables.DomainResolveObject,Robust.Shared.ViewVariables.DomainListPaths)"/>
        </member>
        <member name="M:Robust.Shared.ViewVariables.IViewVariablesManager.GetTypeHandler``1">
             <summary>
                 Retrieves the type handler for a given type.
                 Creates it if it didn't exist already. Allows you to register custom handlers for a type.
                 Type handlers expand the paths available under a certain type on VV.
            
                 <code>/entity/12345/Custom</code>
            
                 In the example above, "Custom" could be a path that the type handler for <see cref="T:Robust.Shared.GameObjects.EntityUid"/> provided.
                 It does not exist on the <see cref="T:Robust.Shared.GameObjects.EntityUid"/> declaration, but that does not matter:
                 VV treats it the same as a "real" member under that type.
            
             </summary>
             <returns>The type handler object, which allows you register handlers and paths for the type.</returns>
             <seealso cref="M:Robust.Shared.ViewVariables.IViewVariablesManager.RegisterDomain(System.String,Robust.Shared.ViewVariables.DomainResolveObject,Robust.Shared.ViewVariables.DomainListPaths)"/>
        </member>
        <member name="M:Robust.Shared.ViewVariables.IViewVariablesManager.ResolvePath(System.String)">
            <param name="path">The path to be resolved.</param>
            <returns>An object representing the path, or null if the path couldn't be resolved.</returns>
        </member>
        <member name="T:Robust.Shared.ViewVariables.ViewVariablesAttribute">
            <summary>
                Attribute to make a property or field accessible to VV.
            </summary>
        </member>
        <member name="F:Robust.Shared.ViewVariables.VVAccess.ReadOnly">
            <summary>
                This property can only be read, not written.
            </summary>
        </member>
        <member name="F:Robust.Shared.ViewVariables.VVAccess.ReadWrite">
            <summary>
                This property is read and writable.
            </summary>
        </member>
        <member name="T:Robust.Shared.ViewVariables.ViewVariablesBlob">
            <summary>
                Data blob that gets sent from server to client to display a VV window for a remote object.
                These blobs should be requested with a specific <see cref="T:Robust.Shared.ViewVariables.ViewVariablesRequest"/>.
            </summary>
        </member>
        <member name="T:Robust.Shared.ViewVariables.ViewVariablesBlobMetadata">
            <summary>
                Contains the fundamental metadata for an object, such as type, <see cref="M:System.Object.ToString"/> output, and the list of "traits".
            </summary>
        </member>
        <member name="P:Robust.Shared.ViewVariables.ViewVariablesBlobMetadata.Traits">
            <summary>
                A list of traits for this remote object.
                A trait is basically saying "this object can be viewed in a specific way".
                There's a trait for "this object has members that are directly accessible to VV (the usual),
                A trait for objects that are <see cref="T:System.Collections.IEnumerable"/>, etc...
                For flexibility, these traits can be any object that the server/client need to understand each other.
                At the moment though the only thing they're used with is <see cref="T:Robust.Shared.ViewVariables.ViewVariablesTraits"/>.
            </summary>
            <seealso cref="M:Robust.Shared.ViewVariables.ViewVariablesManager.TraitIdsFor(System.Type)" />
        </member>
        <member name="P:Robust.Shared.ViewVariables.ViewVariablesBlobMetadata.ObjectTypePretty">
            <summary>
                The pretty type name of the remote object.
            </summary>
        </member>
        <member name="P:Robust.Shared.ViewVariables.ViewVariablesBlobMetadata.ObjectType">
            <summary>
                The assembly qualified type name of the remote object.
            </summary>
        </member>
        <member name="P:Robust.Shared.ViewVariables.ViewVariablesBlobMetadata.Stringified">
            <summary>
                The <see cref="M:System.Object.ToString"/> output of the remote object.
            </summary>
        </member>
        <member name="T:Robust.Shared.ViewVariables.ViewVariablesBlobMembers">
            <summary>
                Contains the VV-accessible members (fields or properties) of a remote object.
                Requested by <see cref="T:Robust.Shared.ViewVariables.ViewVariablesRequestMembers"/>.
            </summary>
        </member>
        <member name="P:Robust.Shared.ViewVariables.ViewVariablesBlobMembers.MemberGroups">
            <summary>
                A list of VV-accessible the remote object has.
            </summary>
        </member>
        <member name="T:Robust.Shared.ViewVariables.ViewVariablesBlobMembers.ReferenceToken">
            <summary>
                Token used to indicate "this is a reference, but I can't send the actual reference over".
            </summary>
        </member>
        <member name="P:Robust.Shared.ViewVariables.ViewVariablesBlobMembers.ReferenceToken.Stringified">
            <summary>
                The <see cref="M:System.Object.ToString"/> output of the referenced object.
            </summary>
        </member>
        <member name="T:Robust.Shared.ViewVariables.ViewVariablesBlobMembers.PrototypeReferenceToken">
            <summary>
                Token used to indicate "this is a prototype reference, but I can't send the actual reference over".
            </summary>
        </member>
        <member name="P:Robust.Shared.ViewVariables.ViewVariablesBlobMembers.PrototypeReferenceToken.ID">
            <summary>
                The ID of the prototype.
            </summary>
        </member>
        <member name="P:Robust.Shared.ViewVariables.ViewVariablesBlobMembers.PrototypeReferenceToken.Variant">
            <summary>
                The Prototype Variant identifier.
            </summary>
        </member>
        <member name="T:Robust.Shared.ViewVariables.ViewVariablesBlobMembers.ServerValueTypeToken">
            <summary>
                Sent if the value is a server-side only value type.
            </summary>
        </member>
        <member name="P:Robust.Shared.ViewVariables.ViewVariablesBlobMembers.ServerValueTypeToken.Stringified">
            <summary>
                The <see cref="M:System.Object.ToString"/> output of the remote object.
            </summary>
        </member>
        <member name="T:Robust.Shared.ViewVariables.ViewVariablesBlobMembers.MemberData">
            <summary>
                Data for a specific property.
            </summary>
        </member>
        <member name="P:Robust.Shared.ViewVariables.ViewVariablesBlobMembers.MemberData.Editable">
            <summary>
                Whether the property can be edited by this client.
            </summary>
        </member>
        <member name="P:Robust.Shared.ViewVariables.ViewVariablesBlobMembers.MemberData.Type">
            <summary>
                Assembly qualified type name of the property.
            </summary>
        </member>
        <member name="P:Robust.Shared.ViewVariables.ViewVariablesBlobMembers.MemberData.TypePretty">
            <summary>
                Pretty type name of the property.
            </summary>
        </member>
        <member name="P:Robust.Shared.ViewVariables.ViewVariablesBlobMembers.MemberData.Name">
            <summary>
                Name of the property.
            </summary>
        </member>
        <member name="P:Robust.Shared.ViewVariables.ViewVariablesBlobMembers.MemberData.PropertyIndex">
            <summary>
                Index of the property to be referenced when modifying it.
            </summary>
        </member>
        <member name="P:Robust.Shared.ViewVariables.ViewVariablesBlobMembers.MemberData.Value">
            <summary>
                Value of the property.
                If it's a value type that can be serialized it's literally sent over,
                otherwise it's a meta token like <see cref="T:Robust.Shared.ViewVariables.ViewVariablesBlobMembers.ServerValueTypeToken"/> or <see cref="T:Robust.Shared.ViewVariables.ViewVariablesBlobMembers.ReferenceToken"/>.
            </summary>
        </member>
        <member name="T:Robust.Shared.ViewVariables.ViewVariablesBlobEntityComponents">
            <summary>
                Contains the type names of the components of a remote <see cref="T:Robust.Shared.GameObjects.EntityUid"/>.
                Requested by <see cref="T:Robust.Shared.ViewVariables.ViewVariablesRequestEntityComponents"/>.
            </summary>
        </member>
        <member name="T:Robust.Shared.ViewVariables.ViewVariablesBlobAllValidComponents">
            <summary>
                Contains a list of server-side component that can be added to a remote <see cref="T:Robust.Shared.GameObjects.EntityUid"/>.
                Requested by <see cref="T:Robust.Shared.ViewVariables.ViewVariablesRequestAllValidComponents"/>.
            </summary>
        </member>
        <member name="T:Robust.Shared.ViewVariables.ViewVariablesBlobAllPrototypes">
            <summary>
                Contains a list of all server-side prototypes of a variant.
                Requested by <see cref="T:Robust.Shared.ViewVariables.ViewVariablesRequestAllPrototypes"/>.
            </summary>
        </member>
        <member name="T:Robust.Shared.ViewVariables.ViewVariablesBlobEnumerable">
            <summary>
                Contains a range of a remote <see cref="T:System.Collections.IEnumerable"/>'s results.
                Requested by <see cref="T:Robust.Shared.ViewVariables.ViewVariablesRequestEnumerable"/>
            </summary>
        </member>
        <member name="P:Robust.Shared.ViewVariables.ViewVariablesBlobEnumerable.Objects">
            <summary>
                The list of objects inside the range specified by the
                <see cref="T:Robust.Shared.ViewVariables.ViewVariablesRequestEnumerable"/> used to request this blob.
            </summary>
        </member>
        <member name="T:Robust.Shared.ViewVariables.ViewVariablesRequest">
            <summary>
                Base class for a "request" that can be sent to get information about the remote object of a session.
                You should pass these requests to <c>IViewVariablesManagerInternal.RequestData</c>, which will return the corresponding blob over the wire.
            </summary>
        </member>
        <member name="T:Robust.Shared.ViewVariables.ViewVariablesRequestMetadata">
            <summary>
                Requests the server to send us a <see cref="T:Robust.Shared.ViewVariables.ViewVariablesRequestMembers"/>.
            </summary>
        </member>
        <member name="T:Robust.Shared.ViewVariables.ViewVariablesRequestMembers">
            <summary>
                Requests the server to send us a <see cref="T:Robust.Shared.ViewVariables.ViewVariablesRequestMembers"/>.
            </summary>
        </member>
        <member name="T:Robust.Shared.ViewVariables.ViewVariablesRequestEntityComponents">
            <summary>
                Requests the server to send us a <see cref="T:Robust.Shared.ViewVariables.ViewVariablesBlobEntityComponents"/>.
            </summary>
        </member>
        <member name="T:Robust.Shared.ViewVariables.ViewVariablesRequestAllValidComponents">
            <summary>
                Requests the server to send us a <see cref="T:Robust.Shared.ViewVariables.ViewVariablesBlobAllValidComponents"/>.
            </summary>
        </member>
        <member name="T:Robust.Shared.ViewVariables.ViewVariablesRequestAllPrototypes">
            <summary>
                Requests the server to send us a <see cref="T:Robust.Shared.ViewVariables.ViewVariablesBlobAllPrototypes"/>.
            </summary>
        </member>
        <member name="T:Robust.Shared.ViewVariables.ViewVariablesRequestEnumerable">
            <summary>
                Requests the server to send us a <see cref="T:Robust.Shared.ViewVariables.ViewVariablesBlobEnumerable"/> containing data in the specified range.
            </summary>
        </member>
        <member name="P:Robust.Shared.ViewVariables.ViewVariablesRequestEnumerable.FromIndex">
            <summary>
                The first index to be included.
            </summary>
        </member>
        <member name="P:Robust.Shared.ViewVariables.ViewVariablesRequestEnumerable.ToIndex">
            <summary>
                The last index to be included.
            </summary>
        </member>
        <member name="P:Robust.Shared.ViewVariables.ViewVariablesRequestEnumerable.Refresh">
            <summary>
                If true, wipe the enumerator used and clear the cached values.
                This is used for the refresh button in the VV window.
                We need to wipe the server side cache or else it wouldn't be a refresh.
            </summary>
        </member>
        <member name="M:Robust.Shared.ViewVariables.ViewVariablesManager.TraitIdsFor(System.Type)">
            <summary>
                Figures out which VV traits an object type has. This method is in shared so the client and server agree on this mess.
            </summary>
            <seealso cref="P:Robust.Shared.ViewVariables.ViewVariablesBlobMetadata.Traits"/>
        </member>
        <member name="T:Robust.Shared.ViewVariables.ViewVariablesManager.VvTest">
            <summary>
                Test class to test local VV easily without connecting to the server.
            </summary>
        </member>
        <member name="M:Robust.Shared.ViewVariables.ViewVariablesManager.VvTest.ComplexDataStructure.InternalCopy(Robust.Shared.ViewVariables.ViewVariablesManager.VvTest.ComplexDataStructure@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.ViewVariables.ViewVariablesManager.VvTest.ComplexDataStructure.Copy(Robust.Shared.ViewVariables.ViewVariablesManager.VvTest.ComplexDataStructure@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.ViewVariables.ViewVariablesManager.VvTest.ComplexDataStructure.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.ViewVariables.ViewVariablesManager.VvTest.ComplexDataStructure.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.ViewVariables.ViewVariablesManager.VvTest.InternalCopy(Robust.Shared.ViewVariables.ViewVariablesManager.VvTest@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.ViewVariables.ViewVariablesManager.VvTest.Copy(Robust.Shared.ViewVariables.ViewVariablesManager.VvTest@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.ViewVariables.ViewVariablesManager.VvTest.Copy(System.Object@,Robust.Shared.Serialization.Manager.ISerializationManager,Robust.Shared.Serialization.SerializationHookContext,Robust.Shared.Serialization.Manager.ISerializationContext)">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CopyTo(System.Object,System.Object@,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Robust.Shared.ViewVariables.ViewVariablesManager.VvTest.Instantiate">
            <seealso cref = "M:Robust.Shared.Serialization.Manager.ISerializationManager.CreateCopy(System.Object,Robust.Shared.Serialization.Manager.ISerializationContext,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Robust.Shared.ViewVariables.ViewVariablesMemberSelector">
            <summary>
                When used as an index in <see cref="P:Robust.Shared.ViewVariables.ViewVariablesSessionRelativeSelector.PropertyIndex"/>,
                refers to a member (field or property) on the object of the session.
            </summary>
        </member>
        <member name="P:Robust.Shared.ViewVariables.ViewVariablesMemberSelector.Index">
            <summary>
                The index of the member. These indices assigned by the server-side member trait.
                It's an index instead of a dump string to solve the theoretical case of member hiding.
            </summary>
        </member>
        <member name="T:Robust.Shared.ViewVariables.ViewVariablesEnumerableIndexSelector">
            <summary>
                When used as an index in <see cref="P:Robust.Shared.ViewVariables.ViewVariablesSessionRelativeSelector.PropertyIndex"/>,
                refers to an index in the results of a <see cref="T:System.Collections.IEnumerable"/>.
            </summary>
        </member>
        <member name="T:Robust.Shared.ViewVariables.ViewVariablesObjectSelector">
            <summary>
                A type that allows to select a remote object.
            </summary>
        </member>
        <member name="T:Robust.Shared.ViewVariables.ViewVariablesEntitySelector">
            <inheritdoc />
            <summary>
                Specifies an entity with a certain entity UID.
            </summary>
        </member>
        <member name="T:Robust.Shared.ViewVariables.ViewVariablesComponentSelector">
            <inheritdoc />
            <summary>
                Specifies a component of a specified entity.
            </summary>
        </member>
        <member name="T:Robust.Shared.ViewVariables.ViewVariablesSessionRelativeSelector">
            <inheritdoc />
            <summary>
                Specifies a specific property of an object currently opened in a remote VV session.
            </summary>
        </member>
        <member name="P:Robust.Shared.ViewVariables.ViewVariablesSessionRelativeSelector.SessionId">
            <summary>
                The session to which this selection is relative.
            </summary>
        </member>
        <member name="P:Robust.Shared.ViewVariables.ViewVariablesSessionRelativeSelector.PropertyIndex">
            <summary>
                A list of objects that can be "resolved" in some way to figure out which object is being talked about,
                relative to this session.
            </summary>
            <remarks>
                The reason it's an array is that we might, in the future, want the ability to display tuples inline or whatever, and then perhaps not open a new remote session.
                Using an array would allow you to go "property name -> index -> index -> index" for as long as that madman is nesting tuples.
                This is not used yet.
                The reason it's <see cref="T:System.Object"/> is to avoid confusion about which trait gets to handle it.
                <see cref="T:Robust.Shared.ViewVariables.ViewVariablesMemberSelector"/> and <see cref="T:Robust.Shared.ViewVariables.ViewVariablesEnumerableIndexSelector"/> are used here.
            </remarks>
        </member>
        <member name="T:Robust.Shared.ViewVariables.ViewVariablesPath">
            <summary>
                Represents a ViewVariables path. Allows you to "Get", "Set" or "Invoke" the path.
            </summary>
        </member>
        <member name="P:Robust.Shared.ViewVariables.ViewVariablesPath.Type">
            <summary>
                The type that is both returned by the <see cref="M:Robust.Shared.ViewVariables.ViewVariablesPath.Get"/> method and used by the <see cref="M:Robust.Shared.ViewVariables.ViewVariablesPath.Set(System.Object)"/> method.
            </summary>
        </member>
        <member name="M:Robust.Shared.ViewVariables.ViewVariablesPath.Get">
            <summary>
                Gets the value of the path, if possible.
            </summary>
            <returns>The value of the path, or null. Same type as <see cref="P:Robust.Shared.ViewVariables.ViewVariablesPath.Type"/>.</returns>
        </member>
        <member name="M:Robust.Shared.ViewVariables.ViewVariablesPath.Set(System.Object)">
            <summary>
                Sets the value of the path, if possible.
            </summary>
            <param name="value">The new value to set the path to. Must be of the same type as <see cref="P:Robust.Shared.ViewVariables.ViewVariablesPath.Type"/>.</param>
        </member>
        <member name="M:Robust.Shared.ViewVariables.ViewVariablesPath.Invoke(System.Object[])">
            <summary>
                Invokes the path, if possible.
            </summary>
            <param name="parameters">The parameters that the function takes.</param>
            <returns>The object returned by invoking the function, or null.</returns>
        </member>
        <member name="P:Robust.Shared.ViewVariables.ViewVariablesPath.InvokeParameterTypes">
            <summary>
                The types of all parameters in the <see cref="M:Robust.Shared.ViewVariables.ViewVariablesPath.Invoke(System.Object[])"/> method.
            </summary>
            <seealso cref="P:Robust.Shared.ViewVariables.ViewVariablesPath.InvokeOptionalParameters"/>
        </member>
        <member name="P:Robust.Shared.ViewVariables.ViewVariablesPath.InvokeOptionalParameters">
            <summary>
                The number of optional parameters in the <see cref="M:Robust.Shared.ViewVariables.ViewVariablesPath.Invoke(System.Object[])"/> method, starting from the end of the array.
            </summary>
            <seealso cref="P:Robust.Shared.ViewVariables.ViewVariablesPath.InvokeParameterTypes"/>
        </member>
        <member name="P:Robust.Shared.ViewVariables.ViewVariablesPath.InvokeReturnType">
            <summary>
                The type of the object returned by the <see cref="M:Robust.Shared.ViewVariables.ViewVariablesPath.Invoke(System.Object[])"/> method, or <see cref="T:System.Void"/> if none.
            </summary>
        </member>
        <member name="F:Robust.Shared.ViewVariables.ViewVariablesPath.ParentComponent">
            <summary>
                Points to nearest parent component path. Will be null if none of the parent/base paths correspond to
                components.
            </summary>
        </member>
        <member name="M:Robust.Shared.ViewVariables.ViewVariablesPath.FromObject(System.Object)">
            <summary>
                Creates a <see cref="T:Robust.Shared.ViewVariables.ViewVariablesFakePath"/> given an object.
            </summary>
        </member>
        <member name="M:Robust.Shared.ViewVariables.ViewVariablesPath.FromGetter(System.Func{System.Object},System.Type)">
            <summary>
                Creates a <see cref="T:Robust.Shared.ViewVariables.ViewVariablesFakePath"/> given a getter function.
            </summary>
        </member>
        <member name="M:Robust.Shared.ViewVariables.ViewVariablesPath.FromSetter(System.Action{System.Object},System.Type)">
            <summary>
                Creates a <see cref="T:Robust.Shared.ViewVariables.ViewVariablesFakePath"/> given a setter function.
            </summary>
        </member>
        <member name="M:Robust.Shared.ViewVariables.ViewVariablesPath.FromInvoker(System.Func{System.Object,System.Object},System.Type[],System.UInt32,System.Type)">
            <summary>
                Creates a <see cref="T:Robust.Shared.ViewVariables.ViewVariablesFakePath"/> given a function to be invoked.
            </summary>
        </member>
        <member name="M:Robust.Shared.ViewVariables.ViewVariablesPath.FromInvoker(System.Action{System.Object},System.Type[],System.UInt32,System.Type)">
            <summary>
                Creates a <see cref="T:Robust.Shared.ViewVariables.ViewVariablesFakePath"/> given a function to be invoked.
            </summary>
        </member>
        <member name="F:Robust.Shared.ViewVariables.ViewVariablesResponseCode.Ok">
            <summary>
                Request went through successfully.
            </summary>
        </member>
        <member name="F:Robust.Shared.ViewVariables.ViewVariablesResponseCode.InvalidRequest">
            <summary>
                Request was invalid or something.
            </summary>
        </member>
        <member name="F:Robust.Shared.ViewVariables.ViewVariablesResponseCode.NoAccess">
            <summary>
                Come back with admin access.
            </summary>
        </member>
        <member name="F:Robust.Shared.ViewVariables.ViewVariablesResponseCode.NoObject">
            <summary>
                Object pointing to by the selector does not exist.
            </summary>
        </member>
        <member name="T:Robust.Shared.ViewVariables.ViewVariablesTraits">
            <summary>
                Pre-defined simple VV traits used by the engine.
            </summary>
        </member>
        <member name="F:Robust.Shared.ViewVariables.ViewVariablesTraits.Members">
            <summary>
                This object has VV-accessible members (field or property with the <see cref="T:Robust.Shared.ViewVariables.ViewVariablesAttribute"/>.
            </summary>
        </member>
        <member name="F:Robust.Shared.ViewVariables.ViewVariablesTraits.Enumerable">
            <summary>
                This object implements <see cref="T:System.Collections.IEnumerable"/> and as such can be viewed as a sequence.
            </summary>
        </member>
        <member name="F:Robust.Shared.ViewVariables.ViewVariablesTraits.Entity">
            <summary>
                This object is an entity and has a list of components that can be viewed.
            </summary>
        </member>
        <member name="M:Robust.Shared.ViewVariables.ViewVariablesTypeHandler`1.AddHandler(Robust.Shared.ViewVariables.HandleTypePath{`0},Robust.Shared.ViewVariables.ListTypeCustomPaths{`0})">
            <summary>
                Adding handler methods allow you to dynamically create and return ViewVariables paths for any sort of path.
            </summary>
            <remarks>
                The handlers are iterated in the order they were registered in.
                Handlers registered with this method take precedence over handlers registered for specific relative paths.
            </remarks>
            <returns>The same object instance, so you can chain method calls.</returns>
        </member>
        <member name="M:Robust.Shared.ViewVariables.ViewVariablesTypeHandler`1.AddHandlerNullable(Robust.Shared.ViewVariables.HandleTypePathNullable{`0},Robust.Shared.ViewVariables.ListTypeCustomPathsNullable{`0})">
            <inheritdoc cref="M:Robust.Shared.ViewVariables.ViewVariablesTypeHandler`1.AddHandler(Robust.Shared.ViewVariables.HandleTypePath{`0},Robust.Shared.ViewVariables.ListTypeCustomPaths{`0})"/>
            <!-- The reason this isn't called "AddHandler" is because it'd cause many ambiguous invocations.-->
        </member>
        <member name="M:Robust.Shared.ViewVariables.ViewVariablesTypeHandler`1.AddHandler(Robust.Shared.ViewVariables.HandleTypePathComponent{`0},Robust.Shared.ViewVariables.ListTypeCustomPathsComponent{`0})">
            <inheritdoc cref="M:Robust.Shared.ViewVariables.ViewVariablesTypeHandler`1.AddHandler(Robust.Shared.ViewVariables.HandleTypePath{`0},Robust.Shared.ViewVariables.ListTypeCustomPaths{`0})"/>
        </member>
        <member name="M:Robust.Shared.ViewVariables.ViewVariablesTypeHandler`1.AddHandler(Robust.Shared.ViewVariables.HandleTypePath,Robust.Shared.ViewVariables.ListTypeCustomPaths)">
            <inheritdoc cref="M:Robust.Shared.ViewVariables.ViewVariablesTypeHandler`1.AddHandler(Robust.Shared.ViewVariables.HandleTypePath{`0},Robust.Shared.ViewVariables.ListTypeCustomPaths{`0})"/>
        </member>
        <member name="M:Robust.Shared.ViewVariables.ViewVariablesTypeHandler`1.RemoveHandler(Robust.Shared.ViewVariables.HandleTypePath{`0},Robust.Shared.ViewVariables.ListTypeCustomPaths{`0})">
            <summary>
                Remove a specific handler method pair from the type handler.
            </summary>
            <returns>The same object instance, so you can chain method calls.</returns>
            <exception cref="T:System.ArgumentException">If the methods specified were not registered.</exception>
        </member>
        <member name="M:Robust.Shared.ViewVariables.ViewVariablesTypeHandler`1.RemoveHandlerNullable(Robust.Shared.ViewVariables.HandleTypePathNullable{`0},Robust.Shared.ViewVariables.ListTypeCustomPathsNullable{`0})">
            <inheritdoc cref="M:Robust.Shared.ViewVariables.ViewVariablesTypeHandler`1.RemoveHandler(Robust.Shared.ViewVariables.HandleTypePath{`0},Robust.Shared.ViewVariables.ListTypeCustomPaths{`0})"/>
        </member>
        <member name="M:Robust.Shared.ViewVariables.ViewVariablesTypeHandler`1.RemoveHandler(Robust.Shared.ViewVariables.HandleTypePathComponent{`0},Robust.Shared.ViewVariables.ListTypeCustomPathsComponent{`0})">
            <inheritdoc cref="M:Robust.Shared.ViewVariables.ViewVariablesTypeHandler`1.RemoveHandler(Robust.Shared.ViewVariables.HandleTypePath{`0},Robust.Shared.ViewVariables.ListTypeCustomPaths{`0})"/>
        </member>
        <member name="M:Robust.Shared.ViewVariables.ViewVariablesTypeHandler`1.RemoveHandler(Robust.Shared.ViewVariables.HandleTypePath,Robust.Shared.ViewVariables.ListTypeCustomPaths)">
            <inheritdoc cref="M:Robust.Shared.ViewVariables.ViewVariablesTypeHandler`1.RemoveHandler(Robust.Shared.ViewVariables.HandleTypePath{`0},Robust.Shared.ViewVariables.ListTypeCustomPaths{`0})"/>
        </member>
        <member name="M:Robust.Shared.ViewVariables.ViewVariablesTypeHandler`1.AddPath(System.String,Robust.Shared.ViewVariables.PathHandler{`0})">
            <summary>
                With this method you can register a handler to handle a specific path relative to the type instance.
            </summary>
            <returns>The same object instance, so you can chain method calls.</returns>
        </member>
        <member name="M:Robust.Shared.ViewVariables.ViewVariablesTypeHandler`1.AddPathNullable(System.String,Robust.Shared.ViewVariables.PathHandlerNullable{`0})">
            <inheritdoc cref="M:Robust.Shared.ViewVariables.ViewVariablesTypeHandler`1.AddPath(System.String,Robust.Shared.ViewVariables.PathHandler)"/>
            <remarks>As opposed to <see cref="M:Robust.Shared.ViewVariables.ViewVariablesTypeHandler`1.AddPath(System.String,Robust.Shared.ViewVariables.PathHandler)"/>, here the passed object is nullable.</remarks>
            <!-- The reason this isn't called "AddPath" is because it'd cause many ambiguous invocations.-->
        </member>
        <member name="M:Robust.Shared.ViewVariables.ViewVariablesTypeHandler`1.AddPath(System.String,Robust.Shared.ViewVariables.PathHandlerComponent{`0})">
            <inheritdoc cref="M:Robust.Shared.ViewVariables.ViewVariablesTypeHandler`1.AddPath(System.String,Robust.Shared.ViewVariables.PathHandler)"/>
            <remarks>As opposed to the rest of "AddPath" methods, this one is specific to entity components.</remarks>
        </member>
        <member name="M:Robust.Shared.ViewVariables.ViewVariablesTypeHandler`1.AddPath``1(System.String,Robust.Shared.ViewVariables.ComponentPropertyGetter{`0,``0},Robust.Shared.ViewVariables.ComponentPropertySetter{`0,``0})">
            <inheritdoc cref="M:Robust.Shared.ViewVariables.ViewVariablesTypeHandler`1.AddPath(System.String,Robust.Shared.ViewVariables.PathHandler)"/>
        </member>
        <member name="M:Robust.Shared.ViewVariables.ViewVariablesTypeHandler`1.AddPath(System.String,Robust.Shared.ViewVariables.PathHandler)">
            <inheritdoc cref="M:Robust.Shared.ViewVariables.ViewVariablesTypeHandler`1.AddPath(System.String,Robust.Shared.ViewVariables.PathHandler)"/>
        </member>
        <member name="M:Robust.Shared.ViewVariables.ViewVariablesTypeHandler`1.RemovePath(System.String)">
            <summary>
                Removes a handler for a specific relative path.
            </summary>
            <returns>The same object instance, so you can chain method calls.</returns>
        </member>
        <member name="M:Robust.Shared.ViewVariables.ViewVariablesUtility.TypeHasVisibleMembers(System.Type)">
            <summary>
                Check whether this type has any fields or properties with the <see cref="T:Robust.Shared.ViewVariables.ViewVariablesAttribute"/>,
                i.e. whether there are any members that are visible in a VV window.
            </summary>
            <remarks>
                This is quite an expensive operation, don't use it lightly.
            </remarks>
            <param name="type">The type to check.</param>
            <returns>True if there are members with the attribute, false otherwise.</returns>
        </member>
        <member name="M:Robust.Shared.ViewVariables.ViewVariablesUtility.TryGetViewVariablesAccess(System.Reflection.MemberInfo,System.Nullable{Robust.Shared.ViewVariables.VVAccess}@)">
            <summary>
            Gets the <see cref="T:Robust.Shared.ViewVariables.VVAccess"/> defined for the member, if defined.
            </summary>
            <param name="info">The member to check access for.</param>
            <param name="access">The found access. Will be null if no access is defined</param>
            <returns>True if access is defined, false if not.</returns>
        </member>
    </members>
</doc>
