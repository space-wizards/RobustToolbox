preset raw;

#include "/Shaders/Internal/shadow_cast_shared.swsl"

const highp float LIGHTING_HEIGHT = 1.0;

const highp float g_MinVariance = 0.0;

const highp float COLOR_POWER = 0.4586603672224416;

varying highp vec2 worldPosition;

uniform highp vec4 lightColor;
// Position of the light, in world coordinates.
uniform highp vec2 lightCenter;
uniform highp vec2 eyeCenter;
uniform highp vec2 eyeZoom;
uniform highp float lightRange;
uniform highp float lightPower;
uniform highp float lightSoftness;
uniform highp float lightIndex;
uniform highp int useNormals;
uniform highp float globalRotation;
uniform highp float maskRotation;
uniform sampler2D shadowMap;
uniform sampler2D normalMap;

void vertex()
{
    highp vec3 transformed = modelMatrix * vec3(VERTEX, 1.0);
    worldPosition = transformed.xy;
    transformed = projectionMatrix * viewMatrix * transformed;

    VERTEX = transformed.xy;
}

highp vec2 rotateVector(highp vec2 vector, highp float theta)
{
    return vector * cos(theta) + vector.yx * vec2(-1, 1) * sin(theta);
}

highp float shadowContrib(highp vec2 diff)
{
    highp float dist = length(diff);

    return smoothstep(0.0, 1.0, ChebyshevUpperBound(occludeDepth(diff, shadowMap, lightIndex), dist));
}

void fragment()
{
    highp float mask = zTexture(UV).r;

    highp vec2 diff = worldPosition - lightCenter;

    // Totally not hacky PCF on top of VSM.
    highp float occlusion = lightIndex < 0.0 ? 1.0 : createOcclusion(diff);

    if (occlusion == 0.0)
    {
        discard;
    }

    highp float dist = dot(diff, diff) + LIGHTING_HEIGHT;
    highp float val = clamp((1.0 - clamp(sqrt(dist) / lightRange, 0.0, 1.0)) * (1.0 / (sqrt(dist + 1.0))), 0.0, 1.0);

    val *= lightPower;
    val *= mask;

    highp float run = 1;

    if (useNormals == 1)
    {
        highp vec2 lightDir = rotateVector(normalize(diff), globalRotation);
        highp vec2 newUV = rotateVector(UV - vec2(0.5, 0.5) + rotateVector((lightCenter - eyeCenter) / vec2(2, -2) / lightRange, maskRotation), -globalRotation);
        newUV *= (projectionMatrix * vec3(1, 1, 0)).xy * vec2(1, -1) / eyeZoom * lightRange;
        newUV += vec2(0.5, 0.5);

        highp vec4 origSample = texture2D(normalMap, newUV);
        if (origSample.xyzw == vec4(0,0,0,1))
            discard;

        // origSample is on the range 0 - 1 in all components,
        // but every color component has been raised to the log_0.5(ln(2)/pi)th power (yes i know) by some unknown mechanism
        // so we first raise it to the log_(ln2/pi)(0.5)th power (yes, i know) to reset it
        highp vec3 normalSample = pow(origSample.xyz, vec3(COLOR_POWER)) * vec3(2,2,1) - vec3(1, 1, 0);
        run = dot(normalize(vec3(lightDir, LIGHTING_HEIGHT)), normalSample * vec3(-1, -1, 1));
        if (run <= 0)
            discard;
    }

    COLOR = vec4(lightColor.xyz, val * occlusion * run);
}

