using System;
using System.Collections.Generic;
using System.Numerics;
using System.Text.RegularExpressions;
using Robust.Client.AutoGenerated;
using Robust.Client.Graphics;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.ColorNaming;
using Robust.Shared.IoC;
using Robust.Shared.Localization;
using Robust.Shared.Maths;

namespace Robust.Client.UserInterface.Controls;

// condensed version of the original ColorSlider set
[GenerateTypedNameReferences]
public sealed partial class ColorSelectorSliders : Control
{
    [Dependency] private readonly ILocalizationManager _localization = default!;

    public Color Color
    {
        get => _currentColor;
        set
        {
            _currentColor = value;
            _colorData = GetStrategy().ToColorData(value);

            UpdateAllSliders();
            UpdateHexBox();
        }
    }

    public ColorSelectorType SelectorType
    {
        get => _currentType;
        set
        {
            _currentType = value;
            TypeSelector.Select(_types.IndexOf(value));
            _colorData = GetStrategy().ToColorData(_currentColor);

            UpdateType();
            UpdateAllSliders();
        }
    }

    public bool IsAlphaVisible
    {
        get => _isAlphaVisible;
        set
        {
            _isAlphaVisible = value;
            UpdateAlphaVisible();
            UpdateHexBox();
        }
    }

    public Action<Color>? OnColorChanged;

    private readonly static HsvSliderStrategy _hsvStrategy = new();
    private readonly static RgbSliderStrategy _rgbStrategy = new();

    private const float AlphaDivisor = 100.0f;

    private Color _currentColor = Color.White;
    private Vector4 _colorData;
    private ColorSelectorType _currentType = ColorSelectorType.Rgb;
    private bool _isAlphaVisible = false;

    private readonly List<ColorSelectorType> _types = new();

    private readonly ColorSelectorStyleBox _topStyle;
    private readonly ColorSelectorStyleBox _middleStyle;
    private readonly ColorSelectorStyleBox _bottomStyle;
    private readonly StyleBoxFlat _colorPanelStyle;
    private readonly MonoLineEdit _hexLineEdit;

    // TODO: There should probably be a generic reusable function somewhere to validate that a
    // string is 100% hex characters...? As opposed to putting it in color sliders. But I don't
    // know where I'd put a function like that.
    private readonly Regex HexCodeRegex = new(@"^[0-9A-F]*$", RegexOptions.IgnoreCase);
    private readonly Thickness ColorPanelPadding = new(0.0f, 2.0f);
    private const int HexLength = 8;
    private const int HexWithoutAlphaLength = 6;
    private int HexColorLength => _isAlphaVisible ? HexLength : HexWithoutAlphaLength;

    public ColorSelectorSliders()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);

        TopChannel.SliderStyleBoxOverride = _topStyle = new();
        MiddleChannel.SliderStyleBoxOverride = _middleStyle = new();
        BottomChannel.SliderStyleBoxOverride = _bottomStyle = new();

        InitializeChannel(TopChannel, ColorSliderOrder.Top);
        InitializeChannel(MiddleChannel, ColorSliderOrder.Middle);
        InitializeChannel(BottomChannel, ColorSliderOrder.Bottom);
        InitializeChannel(AlphaChannel, ColorSliderOrder.Alpha);

        foreach (var ty in Enum.GetValues<ColorSelectorType>())
        {
            TypeSelector.AddItem(Loc.GetString($"color-selector-sliders-{ty.ToString().ToLower()}"));
            _types.Add(ty);
        }

        TypeSelector.OnItemSelected += args =>
        {
            SelectorType = _types[args.Id];
            TypeSelector.Select(args.Id);
        };

        ColorPreviewPanel.PanelOverride = _colorPanelStyle = new();
        _colorPanelStyle.Padding = ColorPanelPadding;

        _hexLineEdit = new() { IsValid = IsHexCodeInputValid };
        _hexLineEdit.OnTextChanged += OnHexCodeChanged;
        HexEditBox.AddChild(_hexLineEdit);

        UpdateType();
        UpdateColorDescription();
        UpdateAlphaVisible();
        UpdateColorPanel();
        UpdateHexBox();
        Color = _currentColor;
    }

    private ColorSliderStrategy GetStrategy()
    {
        return SelectorType switch
        {
            ColorSelectorType.Rgb => _rgbStrategy,
            ColorSelectorType.Hsv => _hsvStrategy,
            _ => throw new ArgumentOutOfRangeException(),
        };
    }

    private ISliderChannel GetChannelByOrder(ColorSliderOrder order)
    {
        return order switch
        {
            ColorSliderOrder.Top => TopChannel,
            ColorSliderOrder.Middle => MiddleChannel,
            ColorSliderOrder.Bottom => BottomChannel,
            ColorSliderOrder.Alpha => AlphaChannel,
            _ => throw new ArgumentOutOfRangeException(),
        };
    }

    private float GetColorValueDivisor(ColorSliderOrder order)
    {
        return order == ColorSliderOrder.Alpha
            ? AlphaDivisor
            : GetStrategy().GetColorValueDivisor(order);
    }

    private void InitializeChannel(ISliderChannel channel, ColorSliderOrder order)
    {
        channel.OnSliderValueChanged += r => { OnSliderValueChanged(order); };
        channel.IsInputValid = value => IsSpinBoxValid(value, order);
        channel.OnSpinValueChanged += value => { OnInputBoxValueChanged(value, order); };
    }

    private void UpdateType()
    {
        var strategy = GetStrategy();
        var labels = strategy.GetSliderLabelTexts();
        TopChannel.LabelText = labels.top;
        MiddleChannel.LabelText = labels.middle;
        BottomChannel.LabelText = labels.bottom;

        _topStyle.ConfigureSlider(strategy.TopSliderStyle);
        _middleStyle.ConfigureSlider(strategy.MiddleSliderStyle);
        _bottomStyle.ConfigureSlider(strategy.BottomSliderStyle);
    }

    private void UpdateSlider(ColorSliderOrder order)
    {
        var channel = GetChannelByOrder(order);
        var divisor = GetColorValueDivisor(order);
        var dataValue = order switch
        {
            ColorSliderOrder.Top => _colorData.X,
            ColorSliderOrder.Middle => _colorData.Y,
            ColorSliderOrder.Bottom => _colorData.Z,
            ColorSliderOrder.Alpha => _colorData.W,
            _ => throw new ArgumentOutOfRangeException(nameof(order))
        };

        channel.OverrideValue(dataValue, divisor);
    }

    private void UpdateColorPanel()
    {
        _colorPanelStyle.BackgroundColor = _currentColor.WithAlpha(1.0f);
    }

    private void UpdateColorDescription()
    {
        ColorDescriptionLabel.Text = ColorNaming.Describe(Color, _localization);
    }

    private void UpdateSliderVisuals()
    {
        _topStyle.SetBaseColor(_colorData);
        _middleStyle.SetBaseColor(_colorData);
        _bottomStyle.SetBaseColor(_colorData);

        UpdateColorPanel();
        UpdateColorDescription();
    }

    private void UpdateHexBox()
    {
        var hexColor = _isAlphaVisible
            ? _currentColor.ToHex()
            : _currentColor.ToHexNoAlpha();

        _hexLineEdit.SetText(hexColor[1..], invokeEvent: false);
    }

    private void UpdateAllSliders()
    {
        UpdateSliderVisuals();
        UpdateSlider(ColorSliderOrder.Top);
        UpdateSlider(ColorSliderOrder.Middle);
        UpdateSlider(ColorSliderOrder.Bottom);
        UpdateSlider(ColorSliderOrder.Alpha);
    }

    private void UpdateAlphaVisible()
    {
        AlphaChannel.Visible = _isAlphaVisible;
        _hexLineEdit.MeasureText = new string('A', HexColorLength);
    }

    private bool IsSpinBoxValid(int value, ColorSliderOrder ordering)
    {
        var divisor = GetColorValueDivisor(ordering);
        var channelValue = value / divisor;

        return channelValue >= 0.0f && channelValue <= 1.0f;
    }

    private bool IsHexCodeInputValid(string value)
    {
        return value.Length <= HexColorLength
            && HexCodeRegex.IsMatch(value);
    }

    private void OnInputBoxValueChanged(ValueChangedEventArgs args, ColorSliderOrder order)
    {
        var channel = GetChannelByOrder(order);
        var value = args.Value / GetColorValueDivisor(order);

        // We are intentionally triggering the slider OnValueChanged event here.
        // This is so that the color data values of the sliders are updated accordingly.
        channel.Value = value;
    }

    private void OnHexCodeChanged(LineEdit.LineEditEventArgs args)
    {
        // I felt that allowing players to write 3-4 character hex codes in was kind of unintuitive;
        // for example, if you emptied the hex and typed in six characters manually, you would see the
        // alpha change on the fourth character, which felt weird.
        if (args.Text.Length < HexWithoutAlphaLength)
            return;

        var newColor = Color.TryFromHex("#" + args.Text);
        if (newColor is null)
            return;

        _currentColor = newColor.Value;
        _colorData = GetStrategy().ToColorData(_currentColor);
        OnColorChanged?.Invoke(_currentColor);

        UpdateAllSliders();
    }

    private void OnSliderValueChanged(ColorSliderOrder order)
    {
        _colorData = new Vector4(
            TopChannel.Value,
            MiddleChannel.Value,
            BottomChannel.Value,
            AlphaChannel.Value);

        _currentColor = GetStrategy().FromColorData(_colorData);
        OnColorChanged?.Invoke(_currentColor);

        UpdateSliderVisuals();
        UpdateSlider(order);
        UpdateHexBox();
    }

    private enum ColorSliderOrder
    {
        Top,
        Middle,
        Bottom,
        Alpha
    }

    public enum ColorSelectorType
    {
        Rgb,
        Hsv,
    }

    /// <summary>
    ///     A LineEdit control that displays in a monospace font.
    ///     This control can be resized to fit a particular text string using <see cref="MeasureText"/>.
    ///     Due to being monospace, this effectively allows the control to be sized to a certain # of characters.
    /// </summary>
    private sealed class MonoLineEdit : LineEdit
    {
        public string? MeasureText { get; set; } = null;

        public MonoLineEdit()
        {
            AddStyleClass("monospace");
        }

        protected override Vector2 MeasureOverride(Vector2 availableSize)
        {
            var baseOverride = base.MeasureOverride(availableSize);

            if (MeasureText is null)
                return baseOverride;

            var font = GetFont();
            var textOverride = new Vector2(1.0f, 0.0f);
            foreach (var rune in MeasureText.EnumerateRunes())
            {
                if (!font.TryGetCharMetrics(rune, UIScale, out var metrics))
                    continue;

                textOverride += new Vector2(metrics.Advance, 0);
            }

            return baseOverride + textOverride;
        }
    }

    private abstract class ColorSliderStrategy
    {
        /// <summary>
        ///     The style preset used by the top slider.
        /// </summary>
        public abstract ColorSelectorStyleBox.ColorSliderPreset TopSliderStyle { get; }

        /// <summary>
        ///     The style preset used by the middle slider.
        /// </summary>
        public abstract ColorSelectorStyleBox.ColorSliderPreset MiddleSliderStyle { get; }

        /// <summary>
        ///     The style preset used by the bottom slider.
        /// </summary>
        public abstract ColorSelectorStyleBox.ColorSliderPreset BottomSliderStyle { get; }

        /// <summary>
        ///     Converts a Color to a Vector4 representation of its components.
        /// </summary>
        /// <remarks>
        ///     Each value in the Vector4 must be between 0.0f and 1.0f; this is used in the
        ///     context of slider values, which are between these ranges.
        /// </remarks>
        /// <param name="color">A Color to convert into Vector4 slider values.</param>
        /// <returns>A Vector4 representation of a Color's slider values.</returns>
        public abstract Vector4 ToColorData(Color color);

        /// <summary>
        ///     Converts a Vector4 representation of color slider values into a Color.
        /// </summary>
        /// <param name="colorData">A Vector4 representation of color slider values.</param>
        /// <returns>A color generated from slider values.</returns>
        public abstract Color FromColorData(Vector4 colorData);

        /// <summary>
        ///     Gets a color component divisor for the given slider.
        /// </summary>
        /// <remarks>
        ///     This is used for converting slider values to/from color component values.
        ///     For example, in RGB coloration, each channel ranges from 0 to 255,
        ///     so if you had a slider value of 0.2, you would multiply 0.2 * 255 = 51
        ///     for the "channel" value.
        ///
        ///     This does not apply to the Alpha channel, as the Alpha channel
        ///     always uses the same divisor; this is defined in ColorSelectorSliders.
        /// </remarks>
        /// <param name="order">The slider to retrieve a divisor for.</param>
        /// <returns>The divisor for the given slider.</returns>
        public abstract float GetColorValueDivisor(ColorSliderOrder order);

        /// <summary>
        ///     Gets a label text string for the first three color sliders.
        /// </summary>
        /// <returns>Label text strings for the top, middle, and bottom sliders.</returns>
        public abstract (string top, string middle, string bottom) GetSliderLabelTexts();
    }

    private sealed class RgbSliderStrategy : ColorSliderStrategy
    {
        private const float ChannelMaxValue = byte.MaxValue;

        public override ColorSelectorStyleBox.ColorSliderPreset TopSliderStyle
            => ColorSelectorStyleBox.ColorSliderPreset.Red;
        public override ColorSelectorStyleBox.ColorSliderPreset MiddleSliderStyle
            => ColorSelectorStyleBox.ColorSliderPreset.Green;
        public override ColorSelectorStyleBox.ColorSliderPreset BottomSliderStyle
            => ColorSelectorStyleBox.ColorSliderPreset.Blue;

        public override Vector4 ToColorData(Color color) => new(color.R, color.G, color.B, color.A);
        public override Color FromColorData(Vector4 colorData)
            => new(colorData.X, colorData.Y, colorData.Z, colorData.W);

        public override float GetColorValueDivisor(ColorSliderOrder order) => ChannelMaxValue;

        public override (string top, string middle, string bottom) GetSliderLabelTexts()
        {
            return (
                Loc.GetString("color-selector-sliders-red"),
                Loc.GetString("color-selector-sliders-green"),
                Loc.GetString("color-selector-sliders-blue"));
        }
    }

    private sealed class HsvSliderStrategy : ColorSliderStrategy
    {
        private const float HueMaxValue = 360.0f;
        private const float SliderMaxValue = 100.0f;

        public override ColorSelectorStyleBox.ColorSliderPreset TopSliderStyle
            => ColorSelectorStyleBox.ColorSliderPreset.Hue;
        public override ColorSelectorStyleBox.ColorSliderPreset MiddleSliderStyle
            => ColorSelectorStyleBox.ColorSliderPreset.Saturation;
        public override ColorSelectorStyleBox.ColorSliderPreset BottomSliderStyle
            => ColorSelectorStyleBox.ColorSliderPreset.Value;

        public override Vector4 ToColorData(Color color) => Color.ToHsv(color);
        public override Color FromColorData(Vector4 colorData) => Color.FromHsv(colorData);

        public override float GetColorValueDivisor(ColorSliderOrder order)
        {
            return order switch
            {
                ColorSliderOrder.Top => HueMaxValue,
                _ => SliderMaxValue,
            };
        }

        public override (string top, string middle, string bottom) GetSliderLabelTexts()
        {
            return (
                Loc.GetString("color-selector-sliders-hue"),
                Loc.GetString("color-selector-sliders-saturation"),
                Loc.GetString("color-selector-sliders-value"));
        }
    }
}

public interface ISliderChannel
{
    event Action<Range>? OnSliderValueChanged;
    event Action<ValueChangedEventArgs>? OnSpinValueChanged;

    Func<int, bool>? IsInputValid { set; }
    float Value { get; set; }

    void OverrideValue(float value, float divisor);
}
